<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  The Schröder-Bernstein theorem, and well ordering of cardinals.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import order.fixed_points data.set.lattice logic.function logic.embedding order.zorn</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/fixed_points.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/zorn.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open lattice set classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  namespace function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  namespace embedding</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  section antisymm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variables {α : Type u} {β : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  theorem schroeder_bernstein {f : α → β} {g : β → α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    (hf : injective f) (hg : injective g) : ∃h:α→β, bijective h :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  let s : set α := lfp $ λs, - (g &#x27;&#x27; - (f &#x27;&#x27; s)) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.lfp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/fixed_points.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.complete_lattice.{u} α], (α → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Least fixed point of a monotone function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  have hs : s = - (g &#x27;&#x27; - (f &#x27;&#x27; s)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    from lfp_eq $ assume s t h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lattice.lfp_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/fixed_points.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : lattice.complete_lattice.{u} α] {f : α → α}, @monotone.{u u} α α (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1)))) (@partial_order.to_preorder.{u} α (@lattice.order_bot.to_partial_order.{u} α (@lattice.bounded_lattice.to_order_bot.{u} α (@lattice.complete_lattice.to_bounded_lattice.{u} α _inst_1)))) f → @eq.{u+1} α (@lattice.lfp.{u} α _inst_1 f) (f (@lattice.lfp.{u} α _inst_1 f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u} (set.{u} α) (@preorder.to_has_le.{u} (set.{u} α) (@partial_order.to_preorder.{u} (set.{u} α) (@lattice.order_bot.to_partial_order.{u} (set.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      compl_subset_compl.mpr $ image_subset _ $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.compl_subset_compl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 650, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, iff (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) t)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type v} {β : Type u} {a b : set.{v} α} (f : α → β), @has_subset.subset.{v} (set.{v} α) (@set.has_subset.{v} α) a b → @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.image.{v u} α β f a) (@set.image.{v u} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27      compl_subset_compl.mpr $ image_subset _ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.compl_subset_compl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 650, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {s t : set.{v} α}, iff (@has_subset.subset.{v} (set.{v} α) (@set.has_subset.{v} α) (@has_neg.neg.{v} (set.{v} α) (@set.has_neg.{v} α) s) (@has_neg.neg.{v} (set.{v} α) (@set.has_neg.{v} α) t)) (@has_subset.subset.{v} (set.{v} α) (@set.has_subset.{v} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {a b : set.{u} α} (f : α → β), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β) (@set.image.{u v} α β f a) (@set.image.{u v} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_le.le.{u} (set.{u} α) (@preorder.to_has_le.{u} (set.{u} α) (@partial_order.to_preorder.{u} (set.{u} α) (@lattice.order_bot.to_partial_order.{u} (set.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  have hns : - s = g &#x27;&#x27; - (f &#x27;&#x27; s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    from lattice.neg_eq_neg_of_eq $ by simp [hs.symm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lattice.neg_eq_neg_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/boolean_algebra.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} {x y : α} [_inst_1 : lattice.boolean_algebra.{u} α], @eq.{u+1} α (@has_neg.neg.{u} α (@lattice.boolean_algebra.to_has_neg.{u} α _inst_1) x) (@has_neg.neg.{u} α (@lattice.boolean_algebra.to_has_neg.{u} α _inst_1) y) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))))
⊢ @eq.{u+1} (set.{u} α)
    (@has_neg.neg.{u} (set.{u} α)
       (@lattice.boolean_algebra.to_has_neg.{u} (set.{u} α)
          (@lattice.complete_boolean_algebra.to_boolean_algebra.{u} (set.{u} α)
             (@set.lattice.complete_boolean_algebra.{u} α)))
       (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{u} (set.{u} α)
       (@lattice.boolean_algebra.to_has_neg.{u} (set.{u} α)
          (@lattice.complete_boolean_algebra.to_boolean_algebra.{u} (set.{u} α)
             (@set.lattice.complete_boolean_algebra.{u} α)))
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  let g&#x27; := λa, @inv_fun β ⟨f a⟩ α g a in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v} [_inst_1 : inhabited.{v+1} α] {β : Type u}, (α → β) → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The inverse of a function (which is a left inverse if `f` is injective
 and a right inverse if `f` is surjective).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  have g&#x27;g : g&#x27; ∘ g = id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    from funext $ assume b, @left_inverse_inv_fun _ ⟨f (g b)⟩ _ _ hg b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.left_inverse_inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type v} {β : α → Type v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v+1} (β x) (f₁ x) (f₂ x)) → @eq.{v+1} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : inhabited.{v+1} α] {β : Type u} {f : α → β}, @function.injective.{v+1 u+1} α β f → @function.left_inverse.{v+1 u+1} α β (@function.inv_fun.{v u+1} α _inst_1 β f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@function.injective.{v+1 u+1} β α g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  have hg&#x27;ns : g&#x27; &#x27;&#x27; (-s) = - (f &#x27;&#x27; s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    by rw [hns, ←image_comp, g&#x27;g, image_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hns'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g&#x27;g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u} {γ : Type v} (f : β → γ) (g : α → β) (a : set.{v} α), @eq.{(max (v+1) 1)} (set.{v} γ) (@set.image.{v v} α γ (@function.comp.{v+1 u+1 v+1} α β γ f g) a) (@set.image.{u v} β γ f (@set.image.{v u} α β g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} (s : set.{v} α), @eq.{(max (v+1) 1)} (set.{v} α) (@set.image.{v v} α α (@id.{v+1} α) s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)
⊢ @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)
⊢ @eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27;
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)
⊢ @eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{v v} β β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g)
       (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)
⊢ @eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{v v} β β (@id.{v+1} β)
       (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  let h := λa, if a ∈ s then f a else g&#x27; a in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  have h &#x27;&#x27; univ = univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, set.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    from calc h &#x27;&#x27; univ = h &#x27;&#x27; s ∪ h &#x27;&#x27; (- s) : by rw [←image_union, union_compl_self]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.image_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.union_compl_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 637, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_union.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : α → β) (s t : set.{u} α), @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β f (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)) (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β f s) (@set.image.{u v} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @eq.{u+1} (set.{u} α) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α))
    (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β h s)
       (@set.image.{u v} α β h (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α))
    (@set.image.{u v} α β h
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α))
    (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β h s)
       (@set.image.{u v} α β h (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      ... = f &#x27;&#x27; s ∪ g&#x27; &#x27;&#x27; (-s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_union.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α))
    (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β h s)
       (@set.image.{u v} α β h (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43        congr (congr_arg (∪)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type v} {f₁ f₂ : α → β} {a₁ a₂ : α}, @eq.{(max (v+1) 1)} (α → β) f₁ f₂ → @eq.{(max (v+1) 1)} α a₁ a₂ → @eq.{(max (v+1) 1)} β (f₁ a₁) (f₂ a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{(max (v+1) 1)} α a₁ a₂ → @eq.{(max (v+1) 1)} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_union.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44          (image_congr $ by simp [h, if_pos] {contextual := tt}))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.image_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 929, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f g : α → β} {s : set.{u} α}, (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β f s) (@set.image.{u v} α β g s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ ∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (h a) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45          (image_congr $ by simp [h, if_neg] {contextual := tt})</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.image_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 929, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f g : α → β} {s : set.{u} α}, (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β f s) (@set.image.{u v} α β g s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ ∀ (a : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
      (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) →
    @eq.{v+1} β (h a) (g&#x27; a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      ... = univ : by rw [hg&#x27;ns, union_compl_self],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hg&#x27;ns'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.union_compl_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 637, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type v}, set.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)) (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} (s : set.{v} α), @eq.{v+1} (set.{v} α) (@has_union.union.{v} (set.{v} α) (@set.has_union.{v} α) s (@has_neg.neg.{v} (set.{v} α) (@set.has_neg.{v} α) s)) (@set.univ.{v} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β)
    (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β f s)
       (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)))
    (@set.univ.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a)
⊢ @eq.{(max (v+1) 1)} (set.{v} β)
    (@has_union.union.{v} (set.{v} β) (@set.has_union.{v} β) (@set.image.{u v} α β f s)
       (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))
    (@set.univ.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  have surjective h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='function.surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    from assume b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    have b ∈ h &#x27;&#x27; univ, by rw [this]; trivial,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tries to solve the current goal using a canonical proof of `true`, or the `reflexivity` tactic, or the `contradiction` tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
b : β
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b (@set.image.{u v} α β h (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
b : β
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b (@set.univ.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
b : β
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b (@set.image.{u v} α β h (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    let ⟨a, _, eq⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b (@set.image.{u v} α β h (@set.univ.{u} α)) → @Exists.{u+1} α (λ (a : α), @eq.{v+1} β (h a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{v+1} β (h a) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b (@set.image.{u v} α β h (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    ⟨a, eq⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  have split : ∀x∈s, ∀y∉s, h x = h y → false,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    from assume x hx y hy eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (h x) (h y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    have y ∈ g &#x27;&#x27; - (f &#x27;&#x27; s), by rwa [←hns],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hns'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    let ⟨y&#x27;, hy&#x27;, eq_y&#x27;⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27; (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    have f x = y&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      from calc f x = g&#x27; y : by simp [h, hx, hy, if_pos, if_neg] at eq; assumption</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  false,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eq_y&#x27; : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (f x) (g&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59        ... = (g&#x27; ∘ g) y&#x27; : by simp [(∘), eq_y&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq_y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α (g y&#x27;) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  false,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eq_y&#x27; : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (f x) (g&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  false,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eq_y&#x27; : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (g&#x27; y) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60        ... = _ : by simp [g&#x27;g],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='g&#x27;g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  false,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eq_y&#x27; : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (g&#x27; y) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
x : α,
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
y : α,
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
eq : @_root_.eq.{v+1} β (h x) (h y),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  false,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eq_y&#x27; : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;) y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    have y&#x27; ∈ f &#x27;&#x27; s, from this ▸ mem_image_of_mem _ hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@eq.{v+1} β (f x) y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {P : α → Prop} {a b : α}, @eq.{v+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : set.{u} α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x a → @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f x) (@set.image.{u v} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    hy&#x27; this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27; (@set.image.{u v} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  have injective h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    from assume x y eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (h x) (h y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    by_cases</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p q : Prop}, (p → q) → (not p → q) → q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66      (assume hx : x ∈ s, by_cases</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p q : Prop}, (p → q) → (not p → q) → q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        (assume hy : y ∈ s, by simp [h, hx, hy, if_pos, if_neg] at eq; exact hf eq)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@function.injective.{u+1 v+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (f x) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s,
hy : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s
⊢ @_root_.eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68        (assume hy : y ∉ s, (split x hx y hy eq).elim))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='false.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → ∀ (y : α), not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @eq.{v+1} β (h x) (h y) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (h x) (h y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Prop}, false → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69      (assume hx : x ∉ s, by_cases</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p q : Prop}, (p → q) → (not p → q) → q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70        (assume hy : y ∈ s, (split y hy x hx eq.symm).elim)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='false.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → ∀ (y : α), not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @eq.{v+1} β (h x) (h y) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (h x) (h y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Prop}, false → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71        (assume hy : y ∉ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72          have x ∈ g &#x27;&#x27; - (f &#x27;&#x27; s), by rwa [←hns],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hns'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73          let ⟨x&#x27;, hx&#x27;, eqx⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eqx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@eq.{u+1} α (g x&#x27;) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74          have y ∈ g &#x27;&#x27; - (f &#x27;&#x27; s), by rwa [←hns],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hns'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, (α → β) → set.{v} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{u} α → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75          let ⟨y&#x27;, hy&#x27;, eqy⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eqy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) → @eq.{u+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@eq.{u+1} α (g y&#x27;) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76          have g&#x27; x = g&#x27; y, by simp [h, hx, hy, if_pos, if_neg] at eq; assumption,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Sort ?l_1} {t e : α}, @eq.{?l_1} α (@ite.{?l_1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y
⊢ @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77          have (g&#x27; ∘ g) x&#x27; = (g&#x27; ∘ g) y&#x27;, by simp [(∘), eqx, eqy, this],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eqx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eqy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α (g x&#x27;) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α (g y&#x27;) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (g&#x27; x) (g&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y)
⊢ @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78          have x&#x27; = y&#x27;, by rwa [g&#x27;g] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='g&#x27;g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this :
  @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;)
⊢ @_root_.eq.{v+1} β x&#x27; y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this : @_root_.eq.{v+1} β (@id.{v+1} β x&#x27;) (@id.{v+1} β y&#x27;)
⊢ @_root_.eq.{v+1} β x&#x27; y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this :
  @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;)
⊢ @_root_.eq.{v+1} β x&#x27; y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79          calc x = g x&#x27; : eqx.symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{u+1} α a b → @eq.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80            ... = g y&#x27; : by rw [this]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β x&#x27; y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this :
  @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;),
this : @_root_.eq.{v+1} β x&#x27; y&#x27;
⊢ @_root_.eq.{u+1} α (g x&#x27;) (g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this :
  @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;),
this : @_root_.eq.{v+1} β x&#x27; y&#x27;
⊢ @_root_.eq.{u+1} α (g x&#x27;) (g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81            ... = y : eqy)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : α → β,
g : β → α,
hf : @function.injective.{u+1 v+1} α β f,
hg : @function.injective.{v+1 u+1} β α g,
s : set.{u} α :=
  @lattice.lfp.{u} (set.{u} α) (@set.lattice_set.{u} α)
    (λ (s : set.{u} α),
       @has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
         (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hs :
  @_root_.eq.{(max (u+1) 1)} (set.{u} α) s
    (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
       (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)))),
hns :
  @_root_.eq.{u+1} (set.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
g&#x27; : α → β := λ (a : α), @function.inv_fun.{v u+1} β (@inhabited.mk.{v+1} β (f a)) α g a,
g&#x27;g : @_root_.eq.{v+1} (β → β) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g) (@id.{v+1} β),
hg&#x27;ns :
  @_root_.eq.{(max (v+1) 1)} (set.{v} β)
    (@set.image.{u v} α β g&#x27; (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s))
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
h : α → β :=
  λ (a : α),
    @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
      (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
      β
      (f a)
      (g&#x27; a),
this : @_root_.eq.{(max (v+1) 1)} (set.{v} β) (@set.image.{u v} α β h (@set.univ.{u} α)) (@set.univ.{v} β),
this : @function.surjective.{u+1 v+1} α β h,
split :
  ∀ (x : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s →
    ∀ (y : α),
      not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s) → @_root_.eq.{v+1} β (h x) (h y) → false,
x y : α,
eq : @_root_.eq.{v+1} β (h x) (h y),
hx : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s),
hy : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y s),
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
x&#x27; : β,
hx&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) x&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqx : @_root_.eq.{u+1} α (g x&#x27;) x,
this :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))),
_let_match :
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) y
    (@set.image.{v u} β α g (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s))) →
  @_root_.eq.{u+1} α x y,
y&#x27; : β,
hy&#x27; :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) y&#x27;
    (@has_neg.neg.{v} (set.{v} β) (@set.has_neg.{v} β) (@set.image.{u v} α β f s)),
eqy : @_root_.eq.{u+1} α (g y&#x27;) y,
this : @_root_.eq.{v+1} β (g&#x27; x) (g&#x27; y),
this :
  @_root_.eq.{v+1} β (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g x&#x27;) (@function.comp.{v+1 u+1 v+1} β α β g&#x27; g y&#x27;),
this : @_root_.eq.{v+1} β x&#x27; y&#x27;
⊢ @_root_.eq.{u+1} α (g x&#x27;) (g y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  ⟨h, ‹injective h›, ‹surjective h›⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='function.surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  theorem antisymm : (α ↪ β) → (β ↪ α) → nonempty (α ≃ β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='function.embedding.{u+1 v+1} α β → function.embedding.{v+1 u+1} β α → nonempty.{(max 1 (max (u+1) (v+1)) (v+1) (u+1))} (equiv.{u+1 v+1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u → Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (max (max u v) v u) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max (max u v) v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  | ⟨e₁, h₁⟩ ⟨e₂, h₂⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@function.injective.{u+1 v+1} α β e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@function.injective.{v+1 u+1} β α e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    let ⟨f, hf⟩ := schroeder_bernstein h₁ h₂ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='function.embedding.schroeder_bernstein'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 21, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) (v+1))} (α → β) (λ (h : α → β), @function.bijective.{u+1 v+1} α β h) → nonempty.{(max 1 (max (u+1) (v+1)) (v+1) (u+1))} (equiv.{u+1 v+1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@function.bijective.{u+1 v+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f : α → β} {g : β → α}, @function.injective.{u+1 v+1} α β f → @function.injective.{v+1 u+1} β α g → @Exists.{(max (u+1) (v+1))} (α → β) (λ (h : α → β), @function.bijective.{u+1 v+1} α β h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    ⟨equiv.of_bijective hf⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.of_bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 808, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} {f : α → β}, @function.bijective.{u+1 v+1} α β f → equiv.{u+1 v+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  end antisymm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  section wo</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  parameters {ι : Type u} {β : ι → Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  @[reducible] private def sets := {s : set (∀ i, β i) |</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → set.{(max u v)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    ∀ (x ∈ s) (y ∈ s) i, (x : ∀ i, β i) i = y i → x = y}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  theorem injective_min (I : nonempty ι) : ∃ i, nonempty (∀ j, β i ↪ β j) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (β i) (f i) (y i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  let ⟨s, hs, ms⟩ := show ∃s∈sets, ∀a∈sets, s ⊆ a → a = s, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ms'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_private.3996186431.sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_private.3996186431.sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) (λ (s : set.{(max u v)} (Π (i : ι), β i)), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) s sets.{u v}) (λ (H : @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) s sets.{u v}), ∀ (a : set.{(max u v)} (Π (i : ι), β i)), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) a sets.{u v} → @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.has_subset.{(max u v)} (Π (i : ι), β i)) s a → @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) → @Exists.{u+1} ι (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (a : set.{(max u v)} (Π (i : ι), β i)), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) a sets.{u v} → @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.has_subset.{(max u v)} (Π (i : ι), β i)) s a → @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u} {β : ι → Type v}, set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u} {β : ι → Type v}, set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)} [c : has_subset.{(max u v)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    zorn.zorn_subset sets (λ c hc hcc, ⟨⋃₀ c,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zorn.zorn_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_private.3996186431.sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hcc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.sUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/zorn.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u v)} (S : set.{(max u v)} (set.{(max u v)} α)), (∀ (c : set.{(max u v)} (set.{(max u v)} α)), @has_subset.subset.{(max u v)} (set.{(max u v)} (set.{(max u v)} α)) (@set.has_subset.{(max u v)} (set.{(max u v)} α)) c S → @zorn.chain.{(max u v)} (set.{(max u v)} α) (@has_subset.subset.{(max u v)} (set.{(max u v)} α) (@set.has_subset.{(max u v)} α)) c → @Exists.{(max u v)+1} (set.{(max u v)} α) (λ (ub : set.{(max u v)} α), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) ub S) (λ (H : @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) ub S), ∀ (s : set.{(max u v)} α), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) s c → @has_subset.subset.{(max u v)} (set.{(max u v)} α) (@set.has_subset.{(max u v)} α) s ub))) → @Exists.{(max u v)+1} (set.{(max u v)} α) (λ (m : set.{(max u v)} α), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) m S) (λ (H : @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) m S), ∀ (a : set.{(max u v)} α), @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) a S → @has_subset.subset.{(max u v)} (set.{(max u v)} α) (@set.has_subset.{(max u v)} α) m a → @eq.{(max u v)+1} (set.{(max u v)} α) a m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u} {β : ι → Type v}, set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) c sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@zorn.chain.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.has_subset.{(max u v)} (Π (i : ι), β i))) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type (max u v)}, set.{(max u v)} (set.{(max u v)} α) → set.{(max u v)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101      λ x ⟨p, hpc, hxp⟩ y ⟨q, hqc, hyq⟩ i hi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hpc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hqc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hyq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x (@set.sUnion.{(max u v)} (Π (i : ι), β i) c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) p c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y (@set.sUnion.{(max u v)} (Π (i : ι), β i) c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) q c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (β i) (x i) (y i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102        (hcc.total hpc hqc).elim (λ h, hc hqc x (h hxp) y hyq i hi) (λ h, hc hpc x hxp y (h hyq) i hi),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hcc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='zorn.chain.total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/zorn.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@zorn.chain.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.has_subset.{(max u v)} (Π (i : ι), β i))) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u v)} [_inst_1 : preorder.{(max u v)} α] {c : set.{(max u v)} α}, @zorn.chain.{(max u v)} α (@has_le.le.{(max u v)} α (@preorder.to_has_le.{(max u v)} α _inst_1)) c → ∀ {x y : α}, @has_mem.mem.{(max u v) (max u v)} α (set.{(max u v)} α) (@set.has_mem.{(max u v)} α) x c → @has_mem.mem.{(max u v) (max u v)} α (set.{(max u v)} α) (@set.has_mem.{(max u v)} α) y c → or (@has_le.le.{(max u v)} α (@preorder.to_has_le.{(max u v)} α _inst_1) x y) (@has_le.le.{(max u v)} α (@preorder.to_has_le.{(max u v)} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@preorder.to_has_le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@partial_order.to_preorder.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.order_bot.to_partial_order.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.bounded_lattice.to_order_bot.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.complete_lattice.to_bounded_lattice.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.lattice_set.{(max u v)} (Π (i : ι), β i))))))) p q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) c sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@preorder.to_has_le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@partial_order.to_preorder.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.order_bot.to_partial_order.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.bounded_lattice.to_order_bot.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.complete_lattice.to_bounded_lattice.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.lattice_set.{(max u v)} (Π (i : ι), β i))))))) p q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (β i) (x i) (y i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@preorder.to_has_le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@partial_order.to_preorder.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.order_bot.to_partial_order.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.bounded_lattice.to_order_bot.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.complete_lattice.to_bounded_lattice.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.lattice_set.{(max u v)} (Π (i : ι), β i))))))) q p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{(max u v)} (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) c sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@preorder.to_has_le.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@partial_order.to_preorder.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.order_bot.to_partial_order.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.bounded_lattice.to_order_bot.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@lattice.complete_lattice.to_bounded_lattice.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)) (@set.lattice_set.{(max u v)} (Π (i : ι), β i))))))) q p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (β i) (x i) (y i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    λ _, subset_sUnion_of_mem⟩) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_sUnion_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{(max u v)} (Π (i : ι), β i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u v)} {S : set.{(max u v)} (set.{(max u v)} α)} {t : set.{(max u v)} α}, @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} α) (set.{(max u v)} (set.{(max u v)} α)) (@set.has_mem.{(max u v)} (set.{(max u v)} α)) t S → @has_subset.subset.{(max u v)} (set.{(max u v)} α) (@set.has_subset.{(max u v)} α) t (@set.sUnion.{(max u v)} α S)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  let ⟨i, e⟩ := show ∃ i, ∀ y, ∃ x ∈ s, (x : ∀ i, β i) i = y, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} ι (λ (i : ι), ∀ (y : β i), @Exists.{(max u v)+1} (Π (i : ι), β i) (λ (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y))) → @Exists.{u+1} ι (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (y : β i), @Exists.{(max u v)+1} (Π (i : ι), β i) (λ (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (max u v)}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    classical.by_contradiction $ λ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {p : Prop}, (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@Exists.{u+1} ι (λ (i : ι), ∀ (y : β i), @Exists.{(max u v)+1} (Π (i : ι), β i) (λ (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    have h : ∀ i, ∃ y, ∀ x ∈ s, (x : ∀ i, β i) i ≠ y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107      by simpa only [not_exists, classical.not_forall] using h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='not_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 447, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 576, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (@Exists.{?l_1} α (λ (x : α), p x))) (∀ (x : α), not (p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {p : α → Prop}, iff (not (∀ (x : α), p x)) (@Exists.{?l_1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@Exists.{u+1} ι (λ (i : ι), ∀ (y : β i), @Exists.{(max u v)+1} (Π (i : ι), β i) (λ (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y))))
⊢ ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    let ⟨f, hf⟩ := axiom_of_choice h in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='classical.axiom_of_choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x) (λ (f : Π (x : ι), (λ (i : ι), β i) x), Π (x : ι), (λ (i : ι) (y : β i), ∀ (x : Π (i : ι), β i), @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s → @ne.{v+1} (β i) (x i) y) x (f x)) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : ι), (λ (i : ι), β i) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : ι), (λ (i : ι) (y : β i), ∀ (x : Π (i : ι), β i), @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s → @ne.{v+1} (β i) (x i) y) x (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {β : α → Type v} {r : Π (x : α), β x → Prop}, (∀ (x : α), @Exists.{v+1} (β x) (λ (y : β x), r x y)) → @Exists.{(max (u+1) (v+1))} (Π (x : α), β x) (λ (f : Π (x : α), β x), ∀ (x : α), r x (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @Exists.{v+1} (β i) (λ (y : β i), ∀ (x : Π (i : ι), β i), @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s → @ne.{v+1} (β i) (x i) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    have f ∈ s, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      have insert f s ∈ sets := λ x hx y hy, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_private.3996186431.sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 389, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α γ : Type (max u v)} [_inst_1 : has_insert.{(max u v) (max u v)} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type u} {β : ι → Type v}, set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_insert.{(max u v)} (Π (i : ι), β i)) f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_insert.{(max u v)} (Π (i : ι), β i)) f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i))
       (@set.has_insert.{(max u v)} (Π (i : ι), β i))
       f
       s),
y : Π (i : ι), β i,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i))
       (@set.has_insert.{(max u v)} (Π (i : ι), β i))
       f
       s)
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111        cases hx; cases hy, {simp [hx, hy]},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_insert.{(max u v)} (Π (i : ι), β i)) f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_insert.{(max u v)} (Π (i : ι), β i)) f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u v)+1} (Π (i : ι), β i) x f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u v)+1} (Π (i : ι), β i) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i))
       (@set.has_insert.{(max u v)} (Π (i : ι), β i))
       f
       s),
y : Π (i : ι), β i,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i))
       (@set.has_insert.{(max u v)} (Π (i : ι), β i))
       f
       s)
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx : @eq.{(max u v)+1} (Π (i : ι), β i) x f,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx : @eq.{(max u v)+1} (Π (i : ι), β i) x f,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx : @eq.{(max u v)+1} (Π (i : ι), β i) x f,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112        { subst x, exact λ i e, (hf i y hy e.symm).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : ι), (λ (i : ι) (y : β i), ∀ (x : Π (i : ι), β i), @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s → @ne.{v+1} (β i) (x i) y) x (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx : @eq.{(max u v)+1} (Π (i : ι), β i) x f,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx : @eq.{(max u v)+1} (Π (i : ι), β i) x f,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
y : Π (i : ι), β i,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (f i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) f y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113        { subst y, exact λ i e, (hf i x hx e).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : ι), (λ (i : ι) (y : β i), ∀ (x : Π (i : ι), β i), @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s → @ne.{v+1} (β i) (x i) y) x (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y

case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy : @eq.{(max u v)+1} (Π (i : ι), β i) y f
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (f i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114        { exact hs x hx y hy }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) s sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (i : ι), β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
h :
  not
    (@Exists.{u+1} ι
       (λ (i : ι),
          ∀ (y : β i),
            @Exists.{(max u v)+1} (Π (i : ι), β i)
              (λ (x : Π (i : ι), β i),
                 @Exists.{0}
                   (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                      (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                      x
                      s)
                   (λ
                    (H :
                      @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                        (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                        x
                        s), @eq.{v+1} (β i) (x i) y)))),
h :
  ∀ (i : ι),
    @Exists.{v+1} (β i)
      (λ (y : β i),
         ∀ (x : Π (i : ι), β i),
           @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
             (@set.has_mem.{(max u v)} (Π (i : ι), β i))
             x
             s →
           @ne.{v+1} (β i) (x i) y),
_let_match :
  @Exists.{(max (u+1) (v+1))} (Π (x : ι), (λ (i : ι), β i) x)
    (λ (f : Π (x : ι), (λ (i : ι), β i) x),
       ∀ (x : ι),
         (λ (i : ι) (y : β i),
            ∀ (x : Π (i : ι), β i),
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s →
              @ne.{v+1} (β i) (x i) y)
           x
           (f x)) →
  false,
f : Π (x : ι), (λ (i : ι), β i) x,
hf :
  ∀ (x : ι),
    (λ (i : ι) (y : β i),
       ∀ (x : Π (i : ι), β i),
         @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
           (@set.has_mem.{(max u v)} (Π (i : ι), β i))
           x
           s →
         @ne.{v+1} (β i) (x i) y)
      x
      (f x),
x y : Π (i : ι), β i,
hx :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    x
    s,
hy :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    y
    s
⊢ ∀ (i : ι), @eq.{v+1} (β i) (x i) (y i) → @eq.{(max (u+1) (v+1))} (Π (i : ι), β i) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115      end, ms _ this (subset_insert f s) ▸ mem_insert _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.mem_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 445, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@insert.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_insert.{(max u v)} (Π (i : ι), β i)) f s) sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u v)} (x : α) (s : set.{(max u v)} α), @has_subset.subset.{(max u v)} (set.{(max u v)} α) (@set.has_subset.{(max u v)} α) s (@insert.{(max u v) (max u v)} α (set.{(max u v)} α) (@set.has_insert.{(max u v)} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type (max u v)} {P : α → Prop} {a b : α}, @eq.{(max u v)+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u v)} (x : α) (s : set.{(max u v)} α), @has_mem.mem.{(max u v) (max u v)} α (set.{(max u v)} α) (@set.has_mem.{(max u v)} α) x (@insert.{(max u v) (max u v)} α (set.{(max u v)} α) (@set.has_insert.{(max u v)} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    let ⟨i⟩ := I in hf i f this rfl in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nonempty.{u+1} ι → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nonempty.{u+1} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (x : ι), (λ (i : ι), β i) x) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  let ⟨f, hf⟩ := axiom_of_choice e in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='classical.axiom_of_choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (v+1) ((max u v)+1))} (Π (x : β i), (λ (y : β i), Π (i : ι), β i) x) (λ (f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x), ∀ (x : β i), (λ (y : β i) (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y)) x (f x)) → @Exists.{u+1} ι (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : β i), (λ (y : β i), Π (i : ι), β i) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (x : β i), (λ (y : β i) (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y)) x (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {β : α → Type (max u v)} {r : Π (x : α), β x → Prop}, (∀ (x : α), @Exists.{(max u v)+1} (β x) (λ (y : β x), r x y)) → @Exists.{(max (v+1) ((max u v)+1))} (Π (x : α), β x) (λ (f : Π (x : α), β x), ∀ (x : α), r x (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  ⟨i, ⟨λ j, ⟨λ a, f a j, λ a b e&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (β j) ((λ (a : β i), f a j) a) ((λ (a : β i), f a j) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    let ⟨sa, ea⟩ := hf a, ⟨sb, eb⟩ := hf b in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(λ (y : β i) (x : Π (i : ι), β i), @Exists.{0} (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s) (λ (H : @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) x s), @eq.{v+1} (β i) (x i) y)) a (f a) → @eq.{v+1} (β i) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='β i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    by rw [← ea, ← eb, hs _ sa _ sb _ e&#x27;]⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ea'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β i) (f a i) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β i) (f b i) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i)) (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))) s sets.{u v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) (f a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i)) (@set.has_mem.{(max u v)} (Π (i : ι), β i)) (f b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (β j) ((λ (a : β i), f a j) a) ((λ (a : β i), f a j) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
_let_match :
  @Exists.{u+1} ι
    (λ (i : ι),
       ∀ (y : β i),
         @Exists.{(max u v)+1} (Π (i : ι), β i)
           (λ (x : Π (i : ι), β i),
              @Exists.{0}
                (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s)
                (λ
                 (H :
                   @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                     (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                     x
                     s), @eq.{v+1} (β i) (x i) y))) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
i : ι,
e :
  ∀ (y : β i),
    @Exists.{(max u v)+1} (Π (i : ι), β i)
      (λ (x : Π (i : ι), β i),
         @Exists.{0}
           (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s)
           (λ
            (H :
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s), @eq.{v+1} (β i) (x i) y)),
_let_match :
  @Exists.{(max (v+1) ((max u v)+1))} (Π (x : β i), (λ (y : β i), Π (i : ι), β i) x)
    (λ (f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x),
       ∀ (x : β i),
         (λ (y : β i) (x : Π (i : ι), β i),
            @Exists.{0}
              (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                 (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                 x
                 s)
              (λ
               (H :
                 @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s), @eq.{v+1} (β i) (x i) y))
           x
           (f x)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x,
hf :
  ∀ (x : β i),
    (λ (y : β i) (x : Π (i : ι), β i),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s)
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s), @eq.{v+1} (β i) (x i) y))
      x
      (f x),
j : ι,
a b : β i,
e&#x27; : @eq.{v+1} (β j) ((λ (a : β i), f a j) a) ((λ (a : β i), f a j) b),
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    a
    (f a) →
  @eq.{v+1} (β i) a b,
sa :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f a)
    s,
ea : @eq.{v+1} (β i) (f a i) a,
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    b
    (f b) →
  @eq.{v+1} (β i) a b,
sb :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f b)
    s,
eb : @eq.{v+1} (β i) (f b i) b
⊢ @eq.{v+1} (β i) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
_let_match :
  @Exists.{u+1} ι
    (λ (i : ι),
       ∀ (y : β i),
         @Exists.{(max u v)+1} (Π (i : ι), β i)
           (λ (x : Π (i : ι), β i),
              @Exists.{0}
                (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s)
                (λ
                 (H :
                   @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                     (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                     x
                     s), @eq.{v+1} (β i) (x i) y))) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
i : ι,
e :
  ∀ (y : β i),
    @Exists.{(max u v)+1} (Π (i : ι), β i)
      (λ (x : Π (i : ι), β i),
         @Exists.{0}
           (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s)
           (λ
            (H :
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s), @eq.{v+1} (β i) (x i) y)),
_let_match :
  @Exists.{(max (v+1) ((max u v)+1))} (Π (x : β i), (λ (y : β i), Π (i : ι), β i) x)
    (λ (f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x),
       ∀ (x : β i),
         (λ (y : β i) (x : Π (i : ι), β i),
            @Exists.{0}
              (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                 (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                 x
                 s)
              (λ
               (H :
                 @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s), @eq.{v+1} (β i) (x i) y))
           x
           (f x)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x,
hf :
  ∀ (x : β i),
    (λ (y : β i) (x : Π (i : ι), β i),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s)
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s), @eq.{v+1} (β i) (x i) y))
      x
      (f x),
j : ι,
a b : β i,
e&#x27; : @eq.{v+1} (β j) ((λ (a : β i), f a j) a) ((λ (a : β i), f a j) b),
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    a
    (f a) →
  @eq.{v+1} (β i) a b,
sa :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f a)
    s,
ea : @eq.{v+1} (β i) (f a i) a,
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    b
    (f b) →
  @eq.{v+1} (β i) a b,
sb :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f b)
    s,
eb : @eq.{v+1} (β i) (f b i) b
⊢ @eq.{v+1} (β i) (f a i) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u,
β : ι → Type v,
I : nonempty.{u+1} ι,
_let_match :
  @Exists.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i))
    (λ (s : set.{(max u v)} (Π (i : ι), β i)),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
            (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
            s
            sets.{u v})
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
              (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
              s
              sets.{u v}),
            ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
              @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
                a
                sets.{u v} →
              @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_subset.{(max u v)} (Π (i : ι), β i))
                s
                a →
              @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
s : set.{(max u v)} (Π (i : ι), β i),
hs :
  @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
    (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
    s
    sets.{u v},
ms :
  ∀ (a : set.{(max u v)} (Π (i : ι), β i)),
    @has_mem.mem.{(max u v) (max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (set.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      (@set.has_mem.{(max u v)} (set.{(max u v)} (Π (i : ι), β i)))
      a
      sets.{u v} →
    @has_subset.subset.{(max u v)} (set.{(max u v)} (Π (i : ι), β i))
      (@set.has_subset.{(max u v)} (Π (i : ι), β i))
      s
      a →
    @eq.{(max u v)+1} (set.{(max u v)} (Π (i : ι), β i)) a s,
_let_match :
  @Exists.{u+1} ι
    (λ (i : ι),
       ∀ (y : β i),
         @Exists.{(max u v)+1} (Π (i : ι), β i)
           (λ (x : Π (i : ι), β i),
              @Exists.{0}
                (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s)
                (λ
                 (H :
                   @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                     (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                     x
                     s), @eq.{v+1} (β i) (x i) y))) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
i : ι,
e :
  ∀ (y : β i),
    @Exists.{(max u v)+1} (Π (i : ι), β i)
      (λ (x : Π (i : ι), β i),
         @Exists.{0}
           (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s)
           (λ
            (H :
              @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                x
                s), @eq.{v+1} (β i) (x i) y)),
_let_match :
  @Exists.{(max (v+1) ((max u v)+1))} (Π (x : β i), (λ (y : β i), Π (i : ι), β i) x)
    (λ (f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x),
       ∀ (x : β i),
         (λ (y : β i) (x : Π (i : ι), β i),
            @Exists.{0}
              (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                 (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                 x
                 s)
              (λ
               (H :
                 @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
                   (@set.has_mem.{(max u v)} (Π (i : ι), β i))
                   x
                   s), @eq.{v+1} (β i) (x i) y))
           x
           (f x)) →
  @Exists.{u+1} ι
    (λ (i : ι), nonempty.{(max (u+1) 1 (v+1))} (Π (j : ι), function.embedding.{v+1 v+1} (β i) (β j))),
f : Π (x : β i), (λ (y : β i), Π (i : ι), β i) x,
hf :
  ∀ (x : β i),
    (λ (y : β i) (x : Π (i : ι), β i),
       @Exists.{0}
         (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s)
         (λ
          (H :
            @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
              (@set.has_mem.{(max u v)} (Π (i : ι), β i))
              x
              s), @eq.{v+1} (β i) (x i) y))
      x
      (f x),
j : ι,
a b : β i,
e&#x27; : @eq.{v+1} (β j) ((λ (a : β i), f a j) a) ((λ (a : β i), f a j) b),
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    a
    (f a) →
  @eq.{v+1} (β i) a b,
sa :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f a)
    s,
ea : @eq.{v+1} (β i) (f a i) a,
_let_match :
  (λ (y : β i) (x : Π (i : ι), β i),
     @Exists.{0}
       (@has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
          (@set.has_mem.{(max u v)} (Π (i : ι), β i))
          x
          s)
       (λ
        (H :
          @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
            (@set.has_mem.{(max u v)} (Π (i : ι), β i))
            x
            s), @eq.{v+1} (β i) (x i) y))
    b
    (f b) →
  @eq.{v+1} (β i) a b,
sb :
  @has_mem.mem.{(max u v) (max u v)} (Π (i : ι), β i) (set.{(max u v)} (Π (i : ι), β i))
    (@set.has_mem.{(max u v)} (Π (i : ι), β i))
    (f b)
    s,
eb : @eq.{v+1} (β i) (f b i) b
⊢ @eq.{v+1} (β i) (f a i) (f b i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  end wo</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  theorem total {α : Type u} {β : Type v} : nonempty (α ↪ β) ∨ nonempty (β ↪ α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u → Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  match @injective_min bool (λ b, cond b (ulift α) (ulift.{(max u v) v} β)) ⟨tt⟩ with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='function.embedding.injective_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 98, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/bool/basic.lean&#x27;, &#x27;line&#x27;: 7, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {ι : Type} {β : ι → Type (max u v)}, nonempty.{1} ι → @Exists.{1} ι (λ (i : ι), nonempty.{(max 1 ((max u v)+1))} (Π (j : ι), function.embedding.{(max u v)+1 (max u v)+1} (β i) (β j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Type ((max u v)+1)}, bool → a → a → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  | ⟨tt, ⟨h⟩⟩ := let ⟨f, hf⟩ := h ff in or.inl ⟨embedding.congr equiv.ulift equiv.ulift ⟨f, hf⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.embedding.congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (j : bool), function.embedding.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='function.embedding.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff) → or (nonempty.{(max 1 (u+1) (v+1))} (function.embedding.{u+1 v+1} α β)) (nonempty.{(max 1 (v+1) (u+1))} (function.embedding.{v+1 u+1} β α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt → (λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@function.injective.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)} {β : Type u} {γ : Type (max u v)} {δ : Type v}, equiv.{(max u v)+1 u+1} α β → equiv.{(max u v)+1 v+1} γ δ → function.embedding.{(max u v)+1 (max u v)+1} α γ → function.embedding.{u+1 v+1} β δ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, equiv.{(max u v)+1 u+1} (ulift.{v u} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, equiv.{(max u v)+1 v+1} (ulift.{(max u v) v} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  | ⟨ff, ⟨h⟩⟩ := let ⟨f, hf⟩ := h tt in or.inr ⟨embedding.congr equiv.ulift equiv.ulift ⟨f, hf⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='bool.ff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.embedding.congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/embedding.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (j : bool), function.embedding.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='function.embedding.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt) → or (nonempty.{(max 1 (u+1) (v+1))} (function.embedding.{u+1 v+1} α β)) (nonempty.{(max 1 (v+1) (u+1))} (function.embedding.{v+1 u+1} β α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff → (λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@function.injective.{(max u v)+1 (max u v)+1} ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.ff) ((λ (b : bool), @cond.{(max u v)+1} (Type (max u v)) b (ulift.{v u} α) (ulift.{(max u v) v} β)) bool.tt) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)} {β : Type v} {γ : Type (max u v)} {δ : Type u}, equiv.{(max u v)+1 v+1} α β → equiv.{(max u v)+1 u+1} γ δ → function.embedding.{(max u v)+1 (max u v)+1} α γ → function.embedding.{v+1 u+1} β δ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, equiv.{(max u v)+1 v+1} (ulift.{(max u v) v} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, equiv.{(max u v)+1 u+1} (ulift.{v u} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  end embedding</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  end function</code></pre>
</body>