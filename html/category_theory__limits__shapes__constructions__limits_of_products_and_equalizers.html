<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  -- Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  -- Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  -- Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.limits.shapes.products</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.limits.shapes.equalizers</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import category_theory.limits.shapes.finite_limits</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import category_theory.limits.shapes.finite_products</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_products.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  # Constructing limits from products and equalizers.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  If a category has all products, and all equalizers, then it has all limits.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  Similarly, if it has all finite products, and all equalizers, then it has all finite limits.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  TODO: provide the dual result.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  namespace category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  universes v u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  variables {C : Type u} [𝒞 : category.{v} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  variables {J : Type v} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  -- We hide the &quot;implementation details&quot; inside a namespace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  namespace has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  -- We assume here only that we have exactly the products we need, so that we can prove</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  -- variations of the construction (all products gives all limits, finite products gives finite limits...)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  variables (F : J ⥤ C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38            [H₁ : has_limit.{v} (functor.of_function F.obj)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {I : Type u₁}, (I → C) → @category_theory.functor.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I) (category_theory.discrete_category.{u₁} I) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39            [H₂ : has_limit.{v} (functor.of_function (λ f : (Σ p : J × J, p.1 ⟶ p.2), F.obj f.1.2))]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {I : Type u₁}, (I → C) → @category_theory.functor.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I) (category_theory.discrete_category.{u₁} I) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : α → Type v}, @sigma.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  include H₁ H₂</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  Corresponding to any functor `F : J ⥤ C`, we construct a new functor from the walking parallel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  pair of morphisms to `C`, given by the diagram</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46           s</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  ∏_j F j ===&gt; Π_{f : j ⟶ j&#x27;} F j&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48           t</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  where the two morphisms `s` and `t` are defined componentwise:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  * The `s_f` component is the projection `∏_j F j ⟶ F j` followed by `f`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  * The `t_f` component is the projection `∏_j F j ⟶ F j&#x27;`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simp] def diagram : walking_parallel_pair ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.walking_parallel_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 33}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The type of objects for the diagram indexing a (co)equalizer.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  let pi_obj := limits.pi_obj F.obj in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] (f : β → C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`pi_obj f` computes the product of a family of elements `f`. (It is defined as an abbreviation
  for `limit (functor.of_function f)`, so for most facts about `pi_obj f`, you will just use general facts
  about limits.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  let pi_hom := limits.pi_obj (λ f : (Σ p : J × J, p.1 ⟶ p.2), F.obj f.1.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] (f : β → C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : α → Type v}, @sigma.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`pi_obj f` computes the product of a family of elements `f`. (It is defined as an abbreviation
  for `limit (functor.of_function f)`, so for most facts about `pi_obj f`, you will just use general facts
  about limits.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  let s : pi_obj ⟶ pi_hom :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    pi.lift (λ f : (Σ p : J × J, p.1 ⟶ p.2), pi.π F.obj f.1.1 ≫ F.map f.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] {f : β → C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)] {P : C}, (Π (b : β), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (f b)) → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (@category_theory.limits.pi_obj.{v u} β C 𝒞 f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] (f : β → C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)] (b : β), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.pi_obj.{v u} β C 𝒞 f _inst_1) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : α → Type v}, @sigma.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D] (c : @category_theory.functor.{v v v u} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v v} C (@category_theory.category_struct.to_has_hom.{v v} C (@category_theory.category.to_category_struct.{v v} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D _inst_2)) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : α → Type v} (c : @sigma.{v v} α β), β (@sigma.fst.{v v} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  let t : pi_obj ⟶ pi_hom :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    pi.lift (λ f : (Σ p : J × J, p.1 ⟶ p.2), pi.π F.obj f.1.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] {f : β → C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)] {P : C}, (Π (b : β), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (f b)) → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (@category_theory.limits.pi_obj.{v u} β C 𝒞 f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] (f : β → C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)] (b : β), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.pi_obj.{v u} β C 𝒞 f _inst_1) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : α → Type v}, @sigma.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  parallel_pair s t</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.parallel_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) pi_obj pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) pi_obj pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  /-- The morphism from cones over the walking pair diagram `diagram F` to cones over</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  the original diagram `F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] def cones_hom : (diagram F).cones ⟶ F.cones :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { app := λ X c,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    { app := λ j, c.app walking_parallel_pair.zero ≫ pi.π _ j,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      naturality&#x27; := λ j j&#x27; f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72        have L := c.naturality walking_parallel_pair_hom.left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73        have R := c.naturality walking_parallel_pair_hom.right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        have t := congr_arg (λ g, g ≫ pi.π _ (⟨(j, j&#x27;), f⟩ : Σ (p : J × J), p.fst ⟶ p.snd)) (R.symm.trans L),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Type v) → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type v}, prod.{v v} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.right.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) c category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.right.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.left.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) c category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.left.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v}))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J j j&#x27;)
                   f)))))
    ((λ
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.π.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.right.{v})))
    ((λ
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.π.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.left.{v})))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J j j&#x27;)
                   f)))))
    ((λ
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.π.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.right.{v})))
    ((λ
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.π.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.left.{v})))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.π.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) … f)))
                        …))
                …)
             category_theory.limits.walking_parallel_pair.zero.{v})
          …
          …
          …)
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.π.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) … f)))
                        …))
                …)
             category_theory.limits.walking_parallel_pair.zero.{v})
          …
          …
          …)
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         𝒞))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.π.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) … f)))
                        …))
                …)
             category_theory.limits.walking_parallel_pair.zero.{v})
          …
          …
          …)
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77        simpa only [limit.lift_π, fan.mk_π_app, category.assoc, category.id_comp] using t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.fan.mk_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {f : β → C} {P : C} (p : Π (b : β), @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) P (f b)) (b : β), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p))) b) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) b)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p))) (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.cone.π.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p)) b) (p b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@opposite.unop.{u+1} C X) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) (@category_theory.limits.pi.π.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@sigma.mk.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) (@prod.mk.{v v} J J j j&#x27;) f))) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@opposite.unop.{u+1} C X) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) … f))) …)) …) category_theory.limits.walking_parallel_pair.zero.{v}) … … …) …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.π.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) … f)))
                        …))
                …)
             category_theory.limits.walking_parallel_pair.zero.{v})
          …
          …
          …)
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C 𝒞
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.π.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (λ (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (λ (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   𝒞
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   H₂
                   (@category_theory.limits.pi_obj.{v u} J C 𝒞
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                      H₁)
                   (λ
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      end }, }.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  /-- The morphism from cones over the original diagram `F` to cones over the walking pair diagram</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  `diagram F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  @[simp] def cones_inv : F.cones ⟶ (diagram F).cones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u (v+1))} [c : category_theory.has_hom.{(max u v) (max v u (v+1))} obj], obj → obj → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Corresponding to any functor `F : J ⥤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
∏_j F j ===&gt; Π_{f : j ⟶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `∏_j F j ⟶ F j` followed by `f`.
* The `t_f` component is the projection `∏_j F j ⟶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  { app := λ X c,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
    (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      refine (fork.of_ι _ _).π,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.fork.of_ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} {f g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y} {P : C} (ι : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P X), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P Y) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) P X Y ι f) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) P X Y ι g) → @category_theory.limits.fork.{v u} C 𝒞 X Y f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
    (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
    X
    (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)

C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
               H₁
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      { exact pi.lift c.app },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type v} {C : Type u} [𝒞 : category_theory.category.{v u} C] {f : β → C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} β) (category_theory.discrete_category.{v} β) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 β f)] {P : C}, (Π (b : β), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (f b)) → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) P (@category_theory.limits.pi_obj.{v u} β C 𝒞 f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
    X
    (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)

C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
               H₁
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
    X
    (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
               H₁
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      { ext f,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                   (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
               H₁
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
f :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88        rcases f with ⟨⟨A,B⟩,f⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
f :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                      (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90        simp only [limit.lift_π, limit.lift_π_assoc, fan.mk_π_app, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.lift_π_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.fan.mk_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C 𝒞 F) (j : J) {X&#x27; : C} (f&#x27; : @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) X&#x27;), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) X&#x27;) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) X&#x27; (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) X&#x27; (@category_theory.limits.limit.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F _inst_3 j) f&#x27;)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F j) X&#x27; (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{?l_1 ?l_2} J _inst_1 C 𝒞 F c) j) f&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {f : β → C} {P : C} (p : Π (b : β), @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) P (f b)) (b : β), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C 𝒞)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p))) b) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) b)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p))) (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.cone.π.{?l_1 ?l_2} (category_theory.discrete.{?l_1} β) (category_theory.discrete_category.{?l_1} β) C 𝒞 (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C 𝒞 β (λ (b : β), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} β C 𝒞 (λ (b : β), f b) P p)) b) (p b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          (@sigma.mk.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞
                (@category_theory.functor.of_function.{v v u} C 𝒞 J
                   (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b))
                (@category_theory.limits.fan.mk.{v u} J C 𝒞
                   (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b)
                   X
                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                         (@opposite.unop.{u+1} C X))
                      F
                      c))))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@opposite.unop.{u+1} C X))
          F
          c
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91        rw ←(c.naturality f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)) (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                𝒞
                (@category_theory.functor.of_function.{v v u} C 𝒞 J
                   (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b))
                (@category_theory.limits.fan.mk.{v u} J C 𝒞
                   (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b)
                   X
                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                         (@opposite.unop.{u+1} C X))
                      F
                      c))))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (λ (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F b))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@opposite.unop.{u+1} C X))
          F
          c
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
          f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          F
          c
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
          f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                X))
          F
          c
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@opposite.unop.{u+1} C X))
          F
          c
          B))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93        simp only [category.id_comp], }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F B)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@opposite.unop.{u+1} C X))
          F
          c
          B))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@opposite.unop.{u+1} C X))
       F
       c
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    naturality&#x27; := λ X Y f, by { ext c j, cases j; tidy, } }.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X Y : opposite.{u+1} C,
f :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    X
    Y
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v v+1} (Type v)
       (@category_theory.category_struct.to_has_hom.{v v+1} (Type v)
          (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v}))
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
          X)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          Y))
    (@category_theory.category_struct.comp.{v v+1} (Type v)
       (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v})
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
          X)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
          Y)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          Y)
       (@category_theory.functor.map.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
          X
          Y
          f)
       (λ
        (c :
          @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
            (Type v)
            category_theory.types.{v}
            (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
            Y),
          @category_theory.limits.cone.π.{v u} category_theory.limits.walking_parallel_pair.{v}
            category_theory.limits.walking_parallel_pair_hom_category.{v}
            C
            𝒞
            (@category_theory.limits.parallel_pair.{v u} C 𝒞
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.limits.pi_obj.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂)
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.category_struct.comp.{v u} C
                       (@category_theory.category.to_category_struct.{v u} C 𝒞)
                       (@category_theory.limits.pi_obj.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.limits.pi.π.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@sigma.snd.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.limits.pi.π.{v u} J C 𝒞
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                       H₁
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))))
            (@category_theory.limits.fork.of_ι.{v u} C 𝒞
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.limits.pi_obj.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂)
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.category_struct.comp.{v u} C
                       (@category_theory.category.to_category_struct.{v u} C 𝒞)
                       (@category_theory.limits.pi_obj.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.limits.pi.π.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@sigma.snd.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  𝒞
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  H₂
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (λ
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.limits.pi.π.{v u} J C 𝒞
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                       H₁
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               Y
               (@category_theory.limits.pi.lift.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  Y
                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                     (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                           (@category_theory.category.opposite.{v u} C 𝒞)
                           (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                           (@category_theory.category.opposite.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                           Y))
                     F
                     c))
               (@category_theory.limits.limit.hom_ext.{v u}
                  (category_theory.discrete.{v}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))))
                  (category_theory.discrete_category.{v}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))))
                  C
                  𝒞
                  (@category_theory.functor.of_function.{v v u} C 𝒞
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  H₂
                  Y
                  (@category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     Y
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.limits.pi_obj.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        𝒞
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        H₂)
                     (@category_theory.limits.pi.lift.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        Y
                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                           (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                 (@category_theory.category.opposite.{v u} C 𝒞)
                                 (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                                 (@category_theory.category.opposite.{v (max v u)}
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                 (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                                 Y))
                           F
                           c))
                     (@category_theory.limits.pi.lift.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        𝒞
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        H₂
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.category_struct.comp.{v u} C
                             (@category_theory.category.to_category_struct.{v u} C 𝒞)
                             (@category_theory.limits.pi_obj.{v u} J C 𝒞
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                                H₁)
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.limits.pi.π.{v u} J C 𝒞
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                                H₁
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f))
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f))
                                (@sigma.snd.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))))
                  (@category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     Y
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.limits.pi_obj.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        𝒞
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        H₂)
                     (@category_theory.limits.pi.lift.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        Y
                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                           (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                 (@category_theory.category.opposite.{v u} C 𝒞)
                                 (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                                 (@category_theory.category.opposite.{v (max v u)}
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                 (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                                 Y))
                           F
                           c))
                     (@category_theory.limits.pi.lift.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        𝒞
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        H₂
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.limits.pi.π.{v u} J C 𝒞
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                             H₁
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))))
                  (λ
                   (f :
                     category_theory.discrete.{v}
                       (@sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p)))),
                     @sigma.cases_on.{0 v v} (prod.{v v} J J)
                       (λ (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))
                       (λ
                        (f :
                          category_theory.discrete.{v}
                            (@sigma.{v v} (prod.{v v} J J)
                               (λ (p : prod.{v v} J J),
                                  @category_theory.has_hom.hom.{v v} J
                                    (@category_theory.category_struct.to_has_hom.{v v} J
                                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                    (@prod.fst.{v v} J J p)
                                    (@prod.snd.{v v} J J p)))),
                          @eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞))
                               Y
                               (@category_theory.functor.obj.{v v v u}
                                  (category_theory.discrete.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (λ (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  (category_theory.discrete_category.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (λ (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  C
                                  𝒞
                                  (@category_theory.functor.of_function.{v v u} C 𝒞
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (λ (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p)))
                                     (λ
                                      (f :
                                        @sigma.{v v} (prod.{v v} J J)
                                          (λ (p : prod.{v v} J J),
                                             @category_theory.has_hom.hom.{v v} J
                                               (@category_theory.category_struct.to_has_hom.{v v} J
                                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                               (@prod.fst.{v v} J J p)
                                               (@prod.snd.{v v} J J p))),
                                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                          (@prod.snd.{v v} J J
                                             (@sigma.fst.{v v} (prod.{v v} J J)
                                                (λ (p : prod.{v v} J J),
                                                   @category_theory.has_hom.hom.{v v} J
                                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                     (@prod.fst.{v v} J J p)
                                                     (@prod.snd.{v v} J J p))
                                                f))))
                                  f))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               Y
                               (@category_theory.limits.limit.{v u}
                                  (category_theory.discrete.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (λ (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  (category_theory.discrete_category.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (λ (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  C
                                  𝒞
                                  …
                                  H₂)
                               …
                               …
                               …)
                            …)
                       f
                       …)))))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X Y : opposite.{u+1} C,
f :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    X
    Y,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    X,
j : category_theory.limits.walking_parallel_pair.{v}
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                Y))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             Y))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.category_struct.comp.{v v+1} (Type v)
          (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v})
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             X)
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             Y)
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             Y)
          (@category_theory.functor.map.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             X
             Y
             f)
          (λ
           (c :
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               Y),
             @category_theory.limits.cone.π.{v u} category_theory.limits.walking_parallel_pair.{v}
               category_theory.limits.walking_parallel_pair_hom_category.{v}
               C
               𝒞
               (@category_theory.limits.parallel_pair.{v u} C 𝒞
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.limits.pi_obj.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂)
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.category_struct.comp.{v u} C
                          (@category_theory.category.to_category_struct.{v u} C 𝒞)
                          (@category_theory.limits.pi_obj.{v u} J C 𝒞
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                             H₁)
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.limits.pi.π.{v u} J C 𝒞
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                             H₁
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@sigma.snd.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.limits.pi.π.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))))
               (@category_theory.limits.fork.of_ι.{v u} C 𝒞
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.limits.pi_obj.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂)
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.category_struct.comp.{v u} C
                          (@category_theory.category.to_category_struct.{v u} C 𝒞)
                          (@category_theory.limits.pi_obj.{v u} J C 𝒞
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                             H₁)
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.limits.pi.π.{v u} J C 𝒞
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                             H₁
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@sigma.snd.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     𝒞
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     H₂
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (λ
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.limits.pi.π.{v u} J C 𝒞
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                          H₁
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  Y
                  (@category_theory.limits.pi.lift.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     Y
                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                        (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                              (@category_theory.category.opposite.{v u} C 𝒞)
                              (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                              (@category_theory.category.opposite.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                              (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                              Y))
                        F
                        c))
                  (@category_theory.limits.limit.hom_ext.{v u}
                     (category_theory.discrete.{v}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))))
                     (category_theory.discrete_category.{v}
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))))
                     C
                     𝒞
                     (@category_theory.functor.of_function.{v v u} C 𝒞
                        (@sigma.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        (λ
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (λ (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))))
                     H₂
                     Y
                     (@category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        Y
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.limits.pi_obj.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           𝒞
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           H₂)
                        (@category_theory.limits.pi.lift.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           Y
                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                              (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                    (@category_theory.category.opposite.{v u} C 𝒞)
                                    (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                                    (@category_theory.category.opposite.{v (max v u)}
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                    (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                                    Y))
                              F
                              c))
                        (@category_theory.limits.pi.lift.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           𝒞
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           H₂
                           (@category_theory.limits.pi_obj.{v u} J C 𝒞
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                              H₁)
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                                   H₁)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (λ (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                   (@prod.snd.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (λ (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.limits.pi.π.{v u} J C 𝒞
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                                   H₁
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (λ (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (λ (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f))
                                   (@prod.snd.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (λ (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f))
                                   (@sigma.snd.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))))
                     (@category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                        Y
                        (@category_theory.limits.pi_obj.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁)
                        (@category_theory.limits.pi_obj.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           𝒞
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           H₂)
                        (@category_theory.limits.pi.lift.{v u} J C 𝒞
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                           H₁
                           Y
                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                              (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                    (@category_theory.category.opposite.{v u} C 𝒞)
                                    (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
                                    (@category_theory.category.opposite.{v (max v u)}
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                    (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
                                    Y))
                              F
                              c))
                        (@category_theory.limits.pi.lift.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           𝒞
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           H₂
                           (@category_theory.limits.pi_obj.{v u} J C 𝒞
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                              H₁)
                           (λ
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (λ (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.limits.pi.π.{v u} J C 𝒞
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                                H₁
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (λ (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))))
                     (λ
                      (f :
                        category_theory.discrete.{v}
                          (@sigma.{v v} (prod.{v v} J J)
                             (λ (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p)))),
                        @sigma.cases_on.{0 v v} (prod.{v v} J J)
                          (λ (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))
                          (λ
                           (f :
                             category_theory.discrete.{v}
                               (@sigma.{v v} (prod.{v v} J J)
                                  (λ (p : prod.{v v} J J),
                                     @category_theory.has_hom.hom.{v v} J
                                       (@category_theory.category_struct.to_has_hom.{v v} J
                                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                       (@prod.fst.{v v} J J p)
                                       (@prod.snd.{v v} J J p)))),
                             @eq.{v+1}
                               (@category_theory.has_hom.hom.{v u} C
                                  (@category_theory.category_struct.to_has_hom.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                  Y
                                  (@category_theory.functor.obj.{v v v u}
                                     (category_theory.discrete.{v}
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (λ (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p))))
                                     (category_theory.discrete_category.{v}
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (λ (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p))))
                                     C
                                     𝒞
                                     (@category_theory.functor.of_function.{v v u} C 𝒞
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (λ (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p)))
                                        (λ
                                         (f :
                                           @sigma.{v v} (prod.{v v} J J)
                                             (λ (p : prod.{v v} J J),
                                                @category_theory.has_hom.hom.{v v} J
                                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                  (@prod.fst.{v v} J J p)
                                                  …)), …))
                                     f))
                               …
                               …)
                          f
                          …))))
          c)
       j)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  /-- The natural isomorphism between cones over the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  walking pair diagram `diagram F` and cones over the original diagram `F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  def cones_iso : (diagram F).cones ≅ F.cones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max v u (v+1))} [_inst_1 : category_theory.category.{(max u v) (max v u (v+1))} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Corresponding to any functor `F : J ⥤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
∏_j F j ===&gt; Π_{f : j ⟶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `∏_j F j ⟶ F j` followed by `f`.
* The `t_f` component is the projection `∏_j F j ⟶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  { hom := cones_hom F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}))) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' The morphism from cones over the walking pair diagram `diagram F` to cones over
the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    inv := cones_inv F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}))) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' The morphism from cones over the original diagram `F` to cones over the walking pair diagram
`diagram F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f))))
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)))
    (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F H₁
          H₂)
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F H₁
          H₂))
    (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104      ext X c j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f))))
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)))
    (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F H₁
          H₂)
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F H₁
          H₂))
    (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j : category_theory.limits.walking_parallel_pair.{v}
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       j)
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      cases j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j : category_theory.limits.walking_parallel_pair.{v}
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       j)
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case category_theory.limits.walking_parallel_pair.zero
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})

case category_theory.limits.walking_parallel_pair.one
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      { ext, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case category_theory.limits.walking_parallel_pair.zero
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})

case category_theory.limits.walking_parallel_pair.one
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.zero
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j : category_theory.discrete.{v} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          H₁)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.π.{v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          H₁
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          H₁)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.π.{v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞 J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))
          H₁
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.one
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107      { ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.one
C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                H₁
                H₂))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
                H₂))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        have t := c.naturality walking_parallel_pair_hom.left,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.walking_parallel_pair_hom.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair_hom.{v} category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109        conv at t { dsimp, to_lhs, simp only [category.id_comp] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ (f : @sigma.{v v} (prod.{v v} J J) …), …))
             …)
          category_theory.limits.walking_parallel_pair.one.{v})
       …
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
    (@opposite.unop.{u+1} C X)
    (@opposite.unop.{u+1} C X)
    (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.parallel_pair.{v u} C 𝒞
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C 𝒞
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
    category_theory.limits.walking_parallel_pair_hom_category.{v}
    C
    𝒞
    (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
       (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞)
       (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞)
       (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞)
       (@opposite.unop.{u+1} C X))
    (@category_theory.limits.parallel_pair.{v u} C 𝒞
       (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂)
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
               (@category_theory.limits.pi_obj.{v u} J C 𝒞
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f))))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (λ (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          𝒞
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          H₂
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (λ
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (λ (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
               H₁
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    c
    category_theory.limits.walking_parallel_pair.one.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C 𝒞
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ (f : @sigma.{v v} (… J) …), …))
             …)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110        simp [t], }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) c category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C 𝒞 (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C 𝒞 (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) H₂ (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F) H₁) (λ (f : @sigma.{v v} (… J) …), …)) …) c category_theory.limits.walking_parallel_pair.zero.{v}) …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
H₁ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)),
H₂ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    𝒞
    (@category_theory.functor.of_function.{v v u} C 𝒞
       (@sigma.{v v} (prod.{v v} J J)
          (λ (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (λ
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (λ (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (λ (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             𝒞)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C 𝒞
          (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
             H₁)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                  (@category_theory.limits.pi_obj.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             𝒞
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             H₂
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.π.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                  H₁
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                     (@category_theory.limits.pi_obj.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.π.{v u} J C 𝒞
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                        H₁
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (λ (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.π.{v u} J C 𝒞
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                     H₁
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C 𝒞
             (@category_theory.limits.pi_obj.{v u} J C 𝒞 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                H₁)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (λ (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                𝒞
                (λ
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (λ (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (λ (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                H₂
                (@category_theory.limits.pi_obj.{v u} J C 𝒞
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F)
                   H₁)
                (λ (f : @sigma.{v v} (… J) …), …))
             …)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       …)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          𝒞
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                (@category_theory.functor.op.{v v u (max v u)} C 𝒞
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      𝒞))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁
             H₂)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                𝒞
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                   H₁
                   H₂))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   𝒞
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F
                      H₁
                      H₂)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.π.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          𝒞
          (@category_theory.functor.of_function.{v v u} C 𝒞
             (@sigma.{v v} (prod.{v v} J J)
                (λ (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (λ
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (λ (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (λ (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          H₂
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  open has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  /-- Any category with products and equalizers has all limits. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  -- This is not an instance, as it is not always how one wants to construct limits!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  def limits_from_equalizers_and_products</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    [has_products.{v} C] [has_equalizers.{v} C] : has_limits.{v} C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_products'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_equalizers'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  { has_limits_of_shape := λ J 𝒥, by exactI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_products.{v u} C 𝒞,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C 𝒞,
J : Type v,
𝒥 : category_theory.small_category.{v} J
⊢ @category_theory.limits.has_limits_of_shape.{v u} J 𝒥 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    { has_limit := λ F, has_limit.of_cones_iso (diagram F) F (cones_iso F) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.has_limit.of_cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J K : Type v} [_inst_3 : category_theory.small_category.{v} J] [_inst_4 : category_theory.small_category.{v} K] (F : @category_theory.functor.{v v v u} J _inst_3 C 𝒞) (G : @category_theory.functor.{v v v u} K _inst_4 C 𝒞), @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} J _inst_3 C 𝒞 F) (@category_theory.functor.cones.{v u} K _inst_4 C 𝒞 G) → Π [_inst_5 : @category_theory.limits.has_limit.{v u} J _inst_3 C 𝒞 F], @category_theory.limits.has_limit.{v u} K _inst_4 C 𝒞 G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Corresponding to any functor `F : J ⥤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
∏_j F j ===&gt; Π_{f : j ⟶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `∏_j F j ⟶ F j` followed by `f`.
* The `t_f` component is the projection `∏_j F j ⟶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The natural isomorphism between cones over the
walking pair diagram `diagram F` and cones over the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_products.{v u} C 𝒞,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C 𝒞,
J : Type v,
𝒥 : category_theory.small_category.{v} J
⊢ @category_theory.limits.has_limits_of_shape.{v u} J 𝒥 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  /-- Any category with finite products and equalizers has all finite limits. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  -- This is not an instance, as it is not always how one wants to construct finite limits!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  def finite_limits_from_equalizers_and_finite_products</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    [has_finite_products.{v} C] [has_equalizers.{v} C] : has_finite_limits.{v} C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_finite_products'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_equalizers'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_finite_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_products.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_limits.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  { has_limits_of_shape := λ J _ _, by exactI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.fin_category.{v} J _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_finite_products.{v u} C 𝒞,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C 𝒞,
J : Type v,
_x : category_theory.small_category.{v} J,
_x : @category_theory.limits.fin_category.{v} J _x
⊢ @category_theory.limits.has_limits_of_shape.{v u} J _x C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    { has_limit := λ F, has_limit.of_cones_iso (diagram F) F (cones_iso F) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.has_limit.of_cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J K : Type v} [_inst_3 : category_theory.small_category.{v} J] [_inst_4 : category_theory.small_category.{v} K] (F : @category_theory.functor.{v v v u} J _inst_3 C 𝒞) (G : @category_theory.functor.{v v v u} K _inst_4 C 𝒞), @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} J _inst_3 C 𝒞 F) (@category_theory.functor.cones.{v u} K _inst_4 C 𝒞 G) → Π [_inst_5 : @category_theory.limits.has_limit.{v u} J _inst_3 C 𝒞 F], @category_theory.limits.has_limit.{v u} K _inst_4 C 𝒞 G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [H₁ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 J (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F))] [H₂ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C 𝒞 (@category_theory.functor.of_function.{v v u} C 𝒞 (@sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (λ (f : @sigma.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (λ (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C 𝒞 (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C 𝒞 J _inst_1 F H₁ H₂)) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Corresponding to any functor `F : J ⥤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
∏_j F j ===&gt; Π_{f : j ⟶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `∏_j F j ⟶ F j` followed by `f`.
* The `t_f` component is the projection `∏_j F j ⟶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The natural isomorphism between cones over the
walking pair diagram `diagram F` and cones over the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_finite_products.{v u} C 𝒞,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C 𝒞,
J : Type v,
_x : category_theory.small_category.{v} J,
_x : @category_theory.limits.fin_category.{v} J _x
⊢ @category_theory.limits.has_limits_of_shape.{v u} J _x C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  end category_theory.limits</code></pre>
</body>