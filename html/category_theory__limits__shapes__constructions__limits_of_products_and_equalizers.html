<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  -- Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  -- Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  -- Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.limits.shapes.products</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.limits.shapes.equalizers</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import category_theory.limits.shapes.finite_limits</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import category_theory.limits.shapes.finite_products</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_products.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  # Constructing limits from products and equalizers.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  If a category has all products, and all equalizers, then it has all limits.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  Similarly, if it has all finite products, and all equalizers, then it has all finite limits.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  TODO: provide the dual result.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  namespace category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  universes v u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  variables {C : Type u} [ğ’ : category.{v} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  include ğ’</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  variables {J : Type v} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v â†’ Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  -- We hide the &quot;implementation details&quot; inside a namespace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  namespace has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  -- We assume here only that we have exactly the products we need, so that we can prove</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  -- variations of the construction (all products gives all limits, finite products gives finite limits...)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  variables (F : J â¥¤ C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38            [Hâ‚ : has_limit.{v} (functor.of_function F.obj)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {I : Type uâ‚}, (I â†’ C) â†’ @category_theory.functor.{uâ‚ vâ‚‚ uâ‚ uâ‚‚} (category_theory.discrete.{uâ‚} I) (category_theory.discrete_category.{uâ‚} I) C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39            [Hâ‚‚ : has_limit.{v} (functor.of_function (Î» f : (Î£ p : J Ã— J, p.1 âŸ¶ p.2), F.obj f.1.2))]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {I : Type uâ‚}, (I â†’ C) â†’ @category_theory.functor.{uâ‚ vâ‚‚ uâ‚ uâ‚‚} (category_theory.discrete.{uâ‚} I) (category_theory.discrete_category.{uâ‚} I) C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v â†’ Type v â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v} {Î² : Î± â†’ Type v}, @sigma.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  include Hâ‚ Hâ‚‚</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  Corresponding to any functor `F : J â¥¤ C`, we construct a new functor from the walking parallel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  pair of morphisms to `C`, given by the diagram</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46           s</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  âˆ_j F j ===&gt; Î _{f : j âŸ¶ j&#x27;} F j&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48           t</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  where the two morphisms `s` and `t` are defined componentwise:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  * The `s_f` component is the projection `âˆ_j F j âŸ¶ F j` followed by `f`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  * The `t_f` component is the projection `âˆ_j F j âŸ¶ F j&#x27;`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simp] def diagram : walking_parallel_pair â¥¤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.walking_parallel_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 33}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The type of objects for the diagram indexing a (co)equalizer.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  let pi_obj := limits.pi_obj F.obj in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] (f : Î² â†’ C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`pi_obj f` computes the product of a family of elements `f`. (It is defined as an abbreviation
  for `limit (functor.of_function f)`, so for most facts about `pi_obj f`, you will just use general facts
  about limits.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  let pi_hom := limits.pi_obj (Î» f : (Î£ p : J Ã— J, p.1 âŸ¶ p.2), F.obj f.1.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] (f : Î² â†’ C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v â†’ Type v â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v} {Î² : Î± â†’ Type v}, @sigma.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`pi_obj f` computes the product of a family of elements `f`. (It is defined as an abbreviation
  for `limit (functor.of_function f)`, so for most facts about `pi_obj f`, you will just use general facts
  about limits.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  let s : pi_obj âŸ¶ pi_hom :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    pi.lift (Î» f : (Î£ p : J Ã— J, p.1 âŸ¶ p.2), pi.Ï€ F.obj f.1.1 â‰« F.map f.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi.Ï€'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] {f : Î² â†’ C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)] {P : C}, (Î  (b : Î²), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (f b)) â†’ @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (@category_theory.limits.pi_obj.{v u} Î² C ğ’ f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v â†’ Type v â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] (f : Î² â†’ C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)] (b : Î²), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@category_theory.limits.pi_obj.{v u} Î² C ğ’ f _inst_1) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v} {Î² : Î± â†’ Type v}, @sigma.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y â†’ @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z â†’ @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D] (c : @category_theory.functor.{v v v u} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v v} C (@category_theory.category_struct.to_has_hom.{v v} C (@category_theory.category.to_category_struct.{v v} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D _inst_2)) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v} {Î² : Î± â†’ Type v} (c : @sigma.{v v} Î± Î²), Î² (@sigma.fst.{v v} Î± Î² c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  let t : pi_obj âŸ¶ pi_hom :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pi_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    pi.lift (Î» f : (Î£ p : J Ã— J, p.1 âŸ¶ p.2), pi.Ï€ F.obj f.1.2) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.pi.Ï€'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] {f : Î² â†’ C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)] {P : C}, (Î  (b : Î²), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (f b)) â†’ @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (@category_theory.limits.pi_obj.{v u} Î² C ğ’ f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v â†’ Type v â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v} J J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] (f : Î² â†’ C) [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)] (b : Î²), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@category_theory.limits.pi_obj.{v u} Î² C ğ’ f _inst_1) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v} {Î² : Î± â†’ Type v}, @sigma.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  parallel_pair s t</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.parallel_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) X Y â†’ @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) X Y â†’ @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) pi_obj pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) pi_obj pi_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  /-- The morphism from cones over the walking pair diagram `diagram F` to cones over</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  the original diagram `F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] def cones_hom : (diagram F).cones âŸ¶ F.cones :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { app := Î» X c,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    { app := Î» j, c.app walking_parallel_pair.zero â‰« pi.Ï€ _ j,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      naturality&#x27; := Î» j j&#x27; f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72        have L := c.naturality walking_parallel_pair_hom.left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73        have R := c.naturality walking_parallel_pair_hom.right,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        have t := congr_arg (Î» g, g â‰« pi.Ï€ _ (âŸ¨(j, j&#x27;), fâŸ© : Î£ (p : J Ã— J), p.fst âŸ¶ p.snd)) (R.symm.trans L),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type v}, (Î± â†’ Type v) â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj â†’ obj â†’ Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± Î² : Type v}, prod.{v v} Î± Î² â†’ Î²'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.right.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) c category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.right.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.left.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) c category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) (@category_theory.functor.op.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’)) X)) (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚) category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v} category_theory.limits.walking_parallel_pair_hom.left.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v}))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J j j&#x27;)
                   f)))))
    ((Î»
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C ğ’))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.Ï€.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.right.{v})))
    ((Î»
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C ğ’))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.Ï€.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.left.{v})))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J j j&#x27;)
                   f)))))
    ((Î»
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C ğ’))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.Ï€.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.right.{v})))
    ((Î»
      (g :
        @category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C ğ’))
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)),
        @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
             (@prod.snd.{v v} J J
                (@sigma.fst.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@sigma.mk.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p))
                      (@prod.mk.{v v} J J j j&#x27;)
                      f))))
          g
          (@category_theory.limits.pi.Ï€.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J j j&#x27;)
                f)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v}
             category_theory.limits.walking_parallel_pair.one.{v}
             category_theory.limits.walking_parallel_pair_hom.left.{v})))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.Ï€.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) â€¦ f)))
                        â€¦))
                â€¦)
             category_theory.limits.walking_parallel_pair.zero.{v})
          â€¦
          â€¦
          â€¦)
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.Ï€.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) â€¦ f)))
                        â€¦))
                â€¦)
             category_theory.limits.walking_parallel_pair.zero.{v})
          â€¦
          â€¦
          â€¦)
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j
          j&#x27;
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j&#x27;)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             j)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@opposite.unop.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’)
                      (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                         category_theory.limits.walking_parallel_pair_hom_category.{v}
                         C
                         ğ’))
                   X))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚)
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.Ï€.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) â€¦ f)))
                        â€¦))
                â€¦)
             category_theory.limits.walking_parallel_pair.zero.{v})
          â€¦
          â€¦
          â€¦)
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77        simpa only [limit.lift_Ï€, fan.mk_Ï€_app, category.assoc, category.id_comp] using t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.limits.limit.lift_Ï€'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.fan.mk_Ï€_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [ğ’ : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C ğ’ F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C ğ’ F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 c) (@category_theory.limits.limit.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c)) F (@category_theory.limits.cone.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î² : Type ?l_1} {C : Type ?l_2} [ğ’ : category_theory.category.{?l_1 ?l_2} C] {f : Î² â†’ C} {P : C} (p : Î  (b : Î²), @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) P (f b)) (b : Î²), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p))) b) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) b)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p))) (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.cone.Ï€.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p)) b) (p b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@opposite.unop.{u+1} C X) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) c category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) (@category_theory.limits.pi.Ï€.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@sigma.mk.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) (@prod.mk.{v v} J J j j&#x27;) f))) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@opposite.unop.{u+1} C X) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) â€¦ f))) â€¦)) â€¦) category_theory.limits.walking_parallel_pair.zero.{v}) â€¦ â€¦ â€¦) â€¦)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;,
L :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})),
R :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.right.{v})),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.one.{v})
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.pi.Ï€.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J j j&#x27;)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) â€¦ f)))
                        â€¦))
                â€¦)
             category_theory.limits.walking_parallel_pair.zero.{v})
          â€¦
          â€¦
          â€¦)
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j&#x27;)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j&#x27;)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X)
          (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F j)
          (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@opposite.unop.{u+1} C X))
             (@category_theory.limits.parallel_pair.{v u} C ğ’
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (@category_theory.limits.pi_obj.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚)
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f)))
                        (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                           (@prod.fst.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@prod.snd.{v v} J J
                              (@sigma.fst.{v v} (prod.{v v} J J)
                                 (Î» (p : prod.{v v} J J),
                                    @category_theory.has_hom.hom.{v v} J
                                      (@category_theory.category_struct.to_has_hom.{v v} J
                                         (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                      (@prod.fst.{v v} J J p)
                                      (@prod.snd.{v v} J J p))
                                 f))
                           (@sigma.snd.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))))
                (@category_theory.limits.pi.lift.{v u}
                   (@sigma.{v v} (prod.{v v} J J)
                      (Î» (p : prod.{v v} J J),
                         @category_theory.has_hom.hom.{v v} J
                           (@category_theory.category_struct.to_has_hom.{v v} J
                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                           (@prod.fst.{v v} J J p)
                           (@prod.snd.{v v} J J p)))
                   C
                   ğ’
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                   Hâ‚‚
                   (@category_theory.limits.pi_obj.{v u} J C ğ’
                      (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                      Hâ‚)
                   (Î»
                    (f :
                      @sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))),
                      @category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))))
             c
             category_theory.limits.walking_parallel_pair.zero.{v})
          (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
             j))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F j j&#x27; f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      end }, }.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  /-- The morphism from cones over the original diagram `F` to cones over the walking pair diagram</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  `diagram F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  @[simp] def cones_inv : F.cones âŸ¶ (diagram F).cones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max v u (v+1))} [c : category_theory.has_hom.{(max u v) (max v u (v+1))} obj], obj â†’ obj â†’ Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Corresponding to any functor `F : J â¥¤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
âˆ_j F j ===&gt; Î _{f : j âŸ¶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `âˆ_j F j âŸ¶ F j` followed by `f`.
* The `t_f` component is the projection `âˆ_j F j âŸ¶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  { app := Î» X c,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
    (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      refine (fork.of_Î¹ _ _).Ï€,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.fork.of_Î¹'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {X Y : C} {f g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) X Y} {P : C} (Î¹ : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P X), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P Y) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) P X Y Î¹ f) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) P X Y Î¹ g) â†’ @category_theory.limits.fork.{v u} C ğ’ X Y f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat â†’ Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat â†’ Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
    (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
    X
    (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)

C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
               Hâ‚
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      { exact pi.lift c.app },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.pi.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î² : Type v} {C : Type u} [ğ’ : category_theory.category.{v u} C] {f : Î² â†’ C} [_inst_1 : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} Î²) (category_theory.discrete_category.{v} Î²) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ Î² f)] {P : C}, (Î  (b : Î²), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (f b)) â†’ @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) P (@category_theory.limits.pi_obj.{v u} Î² C ğ’ f _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
    X
    (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)

C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       ?m_1
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
               Hâ‚
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @category_theory.has_hom.hom.{v u} C
    (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
    X
    (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
               Hâ‚
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      { ext f,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚
          X
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
             (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.category.opposite.{v (max v u)}
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                   (@category_theory.functor.op.{v v u (max v u)} C ğ’
                      (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                      (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                   X))
             F
             c))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
               Hâ‚
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
f :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88        rcases f with âŸ¨âŸ¨A,BâŸ©,fâŸ©,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (Î» (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (Î» (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (Î» (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (Î» (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (Î» (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (Î» (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (Î» (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (Î» (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (Î» (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (Î» (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (Î» (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (Î» (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;âŸ¨&quot; (patt &quot;,&quot;)* patt &quot;âŸ©&quot;
```

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;âŸ¨&quot; (patt &quot;,&quot;)* patt &quot;âŸ©&quot;
```

A pattern like `âŸ¨a, b, câŸ© | âŸ¨d, eâŸ©` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `âŸ¨âŸ¨aâŸ©, b | câŸ© | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `âŸ¨a, b, câŸ©` for splitting on
`âˆƒ x, âˆƒ y, p x`, then it will be treated as `âŸ¨a, âŸ¨b, câŸ©âŸ©`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
f :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          f))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.category.opposite.{v (max v u)}
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                      (@category_theory.functor.op.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                      X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90        simp only [limit.lift_Ï€, limit.lift_Ï€_assoc, fan.mk_Ï€_app, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.limit.lift_Ï€'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.lift_Ï€_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.fan.mk_Ï€_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [ğ’ : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C ğ’ F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C ğ’ F) (j : J), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j) (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 c) (@category_theory.limits.limit.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 j)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c)) F (@category_theory.limits.cone.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [ğ’ : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’} [_inst_3 : @category_theory.limits.has_limit.{?l_1 ?l_2} J _inst_1 C ğ’ F] (c : @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 C ğ’ F) (j : J) {X&#x27; : C} (f&#x27; : @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j) X&#x27;), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) X&#x27;) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3) X&#x27; (@category_theory.limits.limit.lift.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 c) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’) (@category_theory.limits.limit.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j) X&#x27; (@category_theory.limits.limit.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F _inst_3 j) f&#x27;)) (@category_theory.category_struct.comp.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c)) j) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ F j) X&#x27; (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} J _inst_1 C ğ’ F c)) F (@category_theory.limits.cone.Ï€.{?l_1 ?l_2} J _inst_1 C ğ’ F c) j) f&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î² : Type ?l_1} {C : Type ?l_2} [ğ’ : category_theory.category.{?l_1 ?l_2} C] {f : Î² â†’ C} {P : C} (p : Î  (b : Î²), @category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) P (f b)) (b : Î²), @eq.{?l_1+1} (@category_theory.has_hom.hom.{?l_1 ?l_2} C (@category_theory.category_struct.to_has_hom.{?l_1 ?l_2} C (@category_theory.category.to_category_struct.{?l_1 ?l_2} C ğ’)) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p))) b) (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) b)) (@category_theory.nat_trans.app.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.obj.{?l_1 ?l_1 ?l_2 (max ?l_1 ?l_2)} C ğ’ (@category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.category.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.functor.const.{?l_1 ?l_1 ?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’) (@category_theory.limits.cone.X.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p))) (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.cone.Ï€.{?l_1 ?l_2} (category_theory.discrete.{?l_1} Î²) (category_theory.discrete_category.{?l_1} Î²) C ğ’ (@category_theory.functor.of_function.{?l_1 ?l_1 ?l_2} C ğ’ Î² (Î» (b : Î²), f b)) (@category_theory.limits.fan.mk.{?l_1 ?l_2} Î² C ğ’ (Î» (b : Î²), f b) P p)) b) (p b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) X
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚
             X
             (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                   (@opposite.unop.{u+1} C X))
                F
                c))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          (@sigma.mk.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@prod.mk.{v v} J J A B)
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’
             (@category_theory.functor.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.functor.category.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.functor.const.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.limits.cone.X.{v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’
                (@category_theory.functor.of_function.{v v u} C ğ’ J
                   (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b))
                (@category_theory.limits.fan.mk.{v u} J C ğ’
                   (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b)
                   X
                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                      (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                         (@opposite.unop.{u+1} C X))
                      F
                      c))))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
             (@opposite.unop.{u+1} C X))
          F
          c
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91        rw â†(c.naturality f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)) (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’
             (@category_theory.functor.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.functor.category.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.functor.const.{v v v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’)
             (@category_theory.limits.cone.X.{v u} (category_theory.discrete.{v} J)
                (category_theory.discrete_category.{v} J)
                C
                ğ’
                (@category_theory.functor.of_function.{v v u} C ğ’ J
                   (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b))
                (@category_theory.limits.fan.mk.{v u} J C ğ’
                   (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b)
                   X
                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                      (@category_theory.functor.obj.{v v u (max v u)} C ğ’
                         (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                         (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
                         (@opposite.unop.{u+1} C X))
                      F
                      c))))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (Î» (b : J), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F b))
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
             (@opposite.unop.{u+1} C X))
          F
          c
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f))))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
          (@prod.fst.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          (@prod.snd.{v v} J J
             (@sigma.fst.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@sigma.mk.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p))
                   (@prod.mk.{v v} J J A B)
                   f)))
          f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
          f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          F
          c
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B)))
       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
          f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                   (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                X))
          F
          c
          (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       (@prod.snd.{v v} J J
          (@sigma.fst.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p))
             (@sigma.mk.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))
                (@prod.mk.{v v} J J A B)
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
             (@opposite.unop.{u+1} C X))
          F
          c
          B))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93        simp only [category.id_comp], }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
A B : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    (@prod.fst.{v v} J J (@prod.mk.{v v} J J A B))
    (@prod.snd.{v v} J J (@prod.mk.{v v} J J A B))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       X
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F B)
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
             (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
             (@opposite.unop.{u+1} C X))
          F
          c
          B))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
          (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’)
          (@opposite.unop.{u+1} C X))
       F
       c
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    naturality&#x27; := Î» X Y f, by { ext c j, cases j; tidy, } }.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (Î» (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with yâ‚ ... yâ‚™`, where `e` is a variable or an expression, specifies that the sequence of names `yâ‚ ... yâ‚™` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X Y : opposite.{u+1} C,
f :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C ğ’)))
    X
    Y
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v v+1} (Type v)
       (@category_theory.category_struct.to_has_hom.{v v+1} (Type v)
          (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v}))
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
          X)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          Y))
    (@category_theory.category_struct.comp.{v v+1} (Type v)
       (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v})
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
          X)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
          Y)
       (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          Y)
       (@category_theory.functor.map.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
          X
          Y
          f)
       (Î»
        (c :
          @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
            (Type v)
            category_theory.types.{v}
            (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
            Y),
          @category_theory.limits.cone.Ï€.{v u} category_theory.limits.walking_parallel_pair.{v}
            category_theory.limits.walking_parallel_pair_hom_category.{v}
            C
            ğ’
            (@category_theory.limits.parallel_pair.{v u} C ğ’
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.limits.pi_obj.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚)
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.category_struct.comp.{v u} C
                       (@category_theory.category.to_category_struct.{v u} C ğ’)
                       (@category_theory.limits.pi_obj.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@sigma.snd.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.limits.pi.Ï€.{v u} J C ğ’
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                       Hâ‚
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))))
            (@category_theory.limits.fork.of_Î¹.{v u} C ğ’
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.limits.pi_obj.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚)
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.category_struct.comp.{v u} C
                       (@category_theory.category.to_category_struct.{v u} C ğ’)
                       (@category_theory.limits.pi_obj.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                       (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                          (@prod.fst.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))
                          (@sigma.snd.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               (@category_theory.limits.pi.lift.{v u}
                  (@sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p)))
                  C
                  ğ’
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f)))
                  Hâ‚‚
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (Î»
                   (f :
                     @sigma.{v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))),
                     @category_theory.limits.pi.Ï€.{v u} J C ğ’
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                       Hâ‚
                       (@prod.snd.{v v} J J
                          (@sigma.fst.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))
                             f))))
               Y
               (@category_theory.limits.pi.lift.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  Y
                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                     (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                        (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                           (@category_theory.category.opposite.{v u} C ğ’)
                           (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                           (@category_theory.category.opposite.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                           (@category_theory.functor.op.{v v u (max v u)} C ğ’
                              (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                              (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                           Y))
                     F
                     c))
               (@category_theory.limits.limit.hom_ext.{v u}
                  (category_theory.discrete.{v}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))))
                  (category_theory.discrete_category.{v}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))))
                  C
                  ğ’
                  (@category_theory.functor.of_function.{v v u} C ğ’
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  Hâ‚‚
                  Y
                  (@category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     Y
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.limits.pi_obj.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        ğ’
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        Hâ‚‚)
                     (@category_theory.limits.pi.lift.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        Y
                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                           (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                              (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                 (@category_theory.category.opposite.{v u} C ğ’)
                                 (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                                 (@category_theory.category.opposite.{v (max v u)}
                                    (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                                 (@category_theory.functor.op.{v v u (max v u)} C ğ’
                                    (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                                 Y))
                           F
                           c))
                     (@category_theory.limits.pi.lift.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        ğ’
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        Hâ‚‚
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.category_struct.comp.{v u} C
                             (@category_theory.category.to_category_struct.{v u} C ğ’)
                             (@category_theory.limits.pi_obj.{v u} J C ğ’
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                                Hâ‚)
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                                Hâ‚
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                             (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                                (@prod.fst.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f))
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f))
                                (@sigma.snd.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))))
                  (@category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     Y
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.limits.pi_obj.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        ğ’
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        Hâ‚‚)
                     (@category_theory.limits.pi.lift.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        Y
                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                           (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                              (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                 (@category_theory.category.opposite.{v u} C ğ’)
                                 (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                                 (@category_theory.category.opposite.{v (max v u)}
                                    (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                                 (@category_theory.functor.op.{v v u (max v u)} C ğ’
                                    (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                                 Y))
                           F
                           c))
                     (@category_theory.limits.pi.lift.{v u}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        C
                        ğ’
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                        Hâ‚‚
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.limits.pi.Ï€.{v u} J C ğ’
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                             Hâ‚
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))))
                  (Î»
                   (f :
                     category_theory.discrete.{v}
                       (@sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p)))),
                     @sigma.cases_on.{0 v v} (prod.{v v} J J)
                       (Î» (p : prod.{v v} J J),
                          @category_theory.has_hom.hom.{v v} J
                            (@category_theory.category_struct.to_has_hom.{v v} J
                               (@category_theory.category.to_category_struct.{v v} J _inst_1))
                            (@prod.fst.{v v} J J p)
                            (@prod.snd.{v v} J J p))
                       (Î»
                        (f :
                          category_theory.discrete.{v}
                            (@sigma.{v v} (prod.{v v} J J)
                               (Î» (p : prod.{v v} J J),
                                  @category_theory.has_hom.hom.{v v} J
                                    (@category_theory.category_struct.to_has_hom.{v v} J
                                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                    (@prod.fst.{v v} J J p)
                                    (@prod.snd.{v v} J J p)))),
                          @eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C ğ’))
                               Y
                               (@category_theory.functor.obj.{v v v u}
                                  (category_theory.discrete.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (Î» (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  (category_theory.discrete_category.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (Î» (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  C
                                  ğ’
                                  (@category_theory.functor.of_function.{v v u} C ğ’
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (Î» (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p)))
                                     (Î»
                                      (f :
                                        @sigma.{v v} (prod.{v v} J J)
                                          (Î» (p : prod.{v v} J J),
                                             @category_theory.has_hom.hom.{v v} J
                                               (@category_theory.category_struct.to_has_hom.{v v} J
                                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                               (@prod.fst.{v v} J J p)
                                               (@prod.snd.{v v} J J p))),
                                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                          (@prod.snd.{v v} J J
                                             (@sigma.fst.{v v} (prod.{v v} J J)
                                                (Î» (p : prod.{v v} J J),
                                                   @category_theory.has_hom.hom.{v v} J
                                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                     (@prod.fst.{v v} J J p)
                                                     (@prod.snd.{v v} J J p))
                                                f))))
                                  f))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C ğ’)
                               Y
                               (@category_theory.limits.limit.{v u}
                                  (category_theory.discrete.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (Î» (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  (category_theory.discrete_category.{v}
                                     (@sigma.{v v} (prod.{v v} J J)
                                        (Î» (p : prod.{v v} J J),
                                           @category_theory.has_hom.hom.{v v} J
                                             (@category_theory.category_struct.to_has_hom.{v v} J
                                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                             (@prod.fst.{v v} J J p)
                                             (@prod.snd.{v v} J J p))))
                                  C
                                  ğ’
                                  â€¦
                                  Hâ‚‚)
                               â€¦
                               â€¦
                               â€¦)
                            â€¦)
                       f
                       â€¦)))))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X Y : opposite.{u+1} C,
f :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C ğ’)))
    X
    Y,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
    X,
j : category_theory.limits.walking_parallel_pair.{v}
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                Y))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             Y))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.category_struct.comp.{v v+1} (Type v)
          (@category_theory.category.to_category_struct.{v v+1} (Type v) category_theory.types.{v})
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             X)
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             Y)
          (@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             Y)
          (@category_theory.functor.map.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             X
             Y
             f)
          (Î»
           (c :
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C ğ’)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
               Y),
             @category_theory.limits.cone.Ï€.{v u} category_theory.limits.walking_parallel_pair.{v}
               category_theory.limits.walking_parallel_pair_hom_category.{v}
               C
               ğ’
               (@category_theory.limits.parallel_pair.{v u} C ğ’
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.limits.pi_obj.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚)
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.category_struct.comp.{v u} C
                          (@category_theory.category.to_category_struct.{v u} C ğ’)
                          (@category_theory.limits.pi_obj.{v u} J C ğ’
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                             Hâ‚)
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                             Hâ‚
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@sigma.snd.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.limits.pi.Ï€.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))))
               (@category_theory.limits.fork.of_Î¹.{v u} C ğ’
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.limits.pi_obj.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚)
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.category_struct.comp.{v u} C
                          (@category_theory.category.to_category_struct.{v u} C ğ’)
                          (@category_theory.limits.pi_obj.{v u} J C ğ’
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                             Hâ‚)
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                             Hâ‚
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f)))
                          (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                             (@prod.fst.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))
                             (@sigma.snd.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  (@category_theory.limits.pi.lift.{v u}
                     (@sigma.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p)))
                     C
                     ğ’
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f)))
                     Hâ‚‚
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (Î»
                      (f :
                        @sigma.{v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))),
                        @category_theory.limits.pi.Ï€.{v u} J C ğ’
                          (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                          Hâ‚
                          (@prod.snd.{v v} J J
                             (@sigma.fst.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))
                                f))))
                  Y
                  (@category_theory.limits.pi.lift.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     Y
                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                        (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                           (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                              (@category_theory.category.opposite.{v u} C ğ’)
                              (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                              (@category_theory.category.opposite.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                              (@category_theory.functor.op.{v v u (max v u)} C ğ’
                                 (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                                 (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                              Y))
                        F
                        c))
                  (@category_theory.limits.limit.hom_ext.{v u}
                     (category_theory.discrete.{v}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))))
                     (category_theory.discrete_category.{v}
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))))
                     C
                     ğ’
                     (@category_theory.functor.of_function.{v v u} C ğ’
                        (@sigma.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p)))
                        (Î»
                         (f :
                           @sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p))),
                           @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                             (@prod.snd.{v v} J J
                                (@sigma.fst.{v v} (prod.{v v} J J)
                                   (Î» (p : prod.{v v} J J),
                                      @category_theory.has_hom.hom.{v v} J
                                        (@category_theory.category_struct.to_has_hom.{v v} J
                                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                        (@prod.fst.{v v} J J p)
                                        (@prod.snd.{v v} J J p))
                                   f))))
                     Hâ‚‚
                     Y
                     (@category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        Y
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.limits.pi_obj.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           ğ’
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           Hâ‚‚)
                        (@category_theory.limits.pi.lift.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           Y
                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                              (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                 (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                    (@category_theory.category.opposite.{v u} C ğ’)
                                    (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                                    (@category_theory.category.opposite.{v (max v u)}
                                       (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                                    (@category_theory.functor.op.{v v u (max v u)} C ğ’
                                       (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                                    Y))
                              F
                              c))
                        (@category_theory.limits.pi.lift.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           ğ’
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           Hâ‚‚
                           (@category_theory.limits.pi_obj.{v u} J C ğ’
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                              Hâ‚)
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C ğ’)
                                (@category_theory.limits.pi_obj.{v u} J C ğ’
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                                   Hâ‚)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (Î» (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                   (@prod.snd.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (Î» (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                                   Hâ‚
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (Î» (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f)))
                                (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                                   (@prod.fst.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (Î» (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f))
                                   (@prod.snd.{v v} J J
                                      (@sigma.fst.{v v} (prod.{v v} J J)
                                         (Î» (p : prod.{v v} J J),
                                            @category_theory.has_hom.hom.{v v} J
                                              (@category_theory.category_struct.to_has_hom.{v v} J
                                                 (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                              (@prod.fst.{v v} J J p)
                                              (@prod.snd.{v v} J J p))
                                         f))
                                   (@sigma.snd.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))))
                     (@category_theory.category_struct.comp.{v u} C
                        (@category_theory.category.to_category_struct.{v u} C ğ’)
                        Y
                        (@category_theory.limits.pi_obj.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚)
                        (@category_theory.limits.pi_obj.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           ğ’
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           Hâ‚‚)
                        (@category_theory.limits.pi.lift.{v u} J C ğ’
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                           Hâ‚
                           Y
                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C ğ’
                              (@opposite.unop.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                 (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                                    (@category_theory.category.opposite.{v u} C ğ’)
                                    (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C ğ’))
                                    (@category_theory.category.opposite.{v (max v u)}
                                       (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’))
                                    (@category_theory.functor.op.{v v u (max v u)} C ğ’
                                       (@category_theory.functor.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C ğ’)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C ğ’))
                                    Y))
                              F
                              c))
                        (@category_theory.limits.pi.lift.{v u}
                           (@sigma.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p)))
                           C
                           ğ’
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))
                           Hâ‚‚
                           (@category_theory.limits.pi_obj.{v u} J C ğ’
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                              Hâ‚)
                           (Î»
                            (f :
                              @sigma.{v v} (prod.{v v} J J)
                                (Î» (p : prod.{v v} J J),
                                   @category_theory.has_hom.hom.{v v} J
                                     (@category_theory.category_struct.to_has_hom.{v v} J
                                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                     (@prod.fst.{v v} J J p)
                                     (@prod.snd.{v v} J J p))),
                              @category_theory.limits.pi.Ï€.{v u} J C ğ’
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                                Hâ‚
                                (@prod.snd.{v v} J J
                                   (@sigma.fst.{v v} (prod.{v v} J J)
                                      (Î» (p : prod.{v v} J J),
                                         @category_theory.has_hom.hom.{v v} J
                                           (@category_theory.category_struct.to_has_hom.{v v} J
                                              (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                           (@prod.fst.{v v} J J p)
                                           (@prod.snd.{v v} J J p))
                                      f)))))
                     (Î»
                      (f :
                        category_theory.discrete.{v}
                          (@sigma.{v v} (prod.{v v} J J)
                             (Î» (p : prod.{v v} J J),
                                @category_theory.has_hom.hom.{v v} J
                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                  (@prod.fst.{v v} J J p)
                                  (@prod.snd.{v v} J J p)))),
                        @sigma.cases_on.{0 v v} (prod.{v v} J J)
                          (Î» (p : prod.{v v} J J),
                             @category_theory.has_hom.hom.{v v} J
                               (@category_theory.category_struct.to_has_hom.{v v} J
                                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
                               (@prod.fst.{v v} J J p)
                               (@prod.snd.{v v} J J p))
                          (Î»
                           (f :
                             category_theory.discrete.{v}
                               (@sigma.{v v} (prod.{v v} J J)
                                  (Î» (p : prod.{v v} J J),
                                     @category_theory.has_hom.hom.{v v} J
                                       (@category_theory.category_struct.to_has_hom.{v v} J
                                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                       (@prod.fst.{v v} J J p)
                                       (@prod.snd.{v v} J J p)))),
                             @eq.{v+1}
                               (@category_theory.has_hom.hom.{v u} C
                                  (@category_theory.category_struct.to_has_hom.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C ğ’))
                                  Y
                                  (@category_theory.functor.obj.{v v v u}
                                     (category_theory.discrete.{v}
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (Î» (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p))))
                                     (category_theory.discrete_category.{v}
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (Î» (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p))))
                                     C
                                     ğ’
                                     (@category_theory.functor.of_function.{v v u} C ğ’
                                        (@sigma.{v v} (prod.{v v} J J)
                                           (Î» (p : prod.{v v} J J),
                                              @category_theory.has_hom.hom.{v v} J
                                                (@category_theory.category_struct.to_has_hom.{v v} J
                                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                (@prod.fst.{v v} J J p)
                                                (@prod.snd.{v v} J J p)))
                                        (Î»
                                         (f :
                                           @sigma.{v v} (prod.{v v} J J)
                                             (Î» (p : prod.{v v} J J),
                                                @category_theory.has_hom.hom.{v v} J
                                                  (@category_theory.category_struct.to_has_hom.{v v} J
                                                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                                  (@prod.fst.{v v} J J p)
                                                  â€¦)), â€¦))
                                     f))
                               â€¦
                               â€¦)
                          f
                          â€¦))))
          c)
       j)
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  /-- The natural isomorphism between cones over the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  walking pair diagram `diagram F` and cones over the original diagram `F`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  def cones_iso : (diagram F).cones â‰… F.cones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type (max v u (v+1))} [_inst_1 : category_theory.category.{(max u v) (max v u (v+1))} C], C â†’ C â†’ Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [ğ’ : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C ğ’ â†’ @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Corresponding to any functor `F : J â¥¤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
âˆ_j F j ===&gt; Î _{f : j âŸ¶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `âˆ_j F j âŸ¶ F j` followed by `f`.
* The `t_f` component is the projection `âˆ_j F j âŸ¶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  { hom := cones_hom F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}))) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)) (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' The morphism from cones over the walking pair diagram `diagram F` to cones over
the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    inv := cones_inv F,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}))) (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' The morphism from cones over the original diagram `F` to cones over the walking pair diagram
`diagram F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f))))
âŠ¢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)))
    (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F Hâ‚
          Hâ‚‚)
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F Hâ‚
          Hâ‚‚))
    (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104      ext X c j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f))))
âŠ¢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)))
    (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F Hâ‚
          Hâ‚‚)
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F Hâ‚
          Hâ‚‚))
    (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j : category_theory.limits.walking_parallel_pair.{v}
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       j)
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      cases j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (Î» (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with yâ‚ ... yâ‚™`, where `e` is a variable or an expression, specifies that the sequence of names `yâ‚ ... yâ‚™` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j : category_theory.limits.walking_parallel_pair.{v}
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          j)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          j))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       j)
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case category_theory.limits.walking_parallel_pair.zero
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})

case category_theory.limits.walking_parallel_pair.one
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      { ext, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case category_theory.limits.walking_parallel_pair.zero
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})

case category_theory.limits.walking_parallel_pair.one
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.zero
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j : category_theory.discrete.{v} J
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          Hâ‚)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.Ï€.{v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          Hâ‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          Hâ‚)
       (@category_theory.functor.obj.{v v v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.limits.limit.Ï€.{v u} (category_theory.discrete.{v} J)
          (category_theory.discrete_category.{v} J)
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’ J
             (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))
          Hâ‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.one
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107      { ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case category_theory.limits.walking_parallel_pair.one
C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚)
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                Hâ‚
                Hâ‚‚))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@opposite.unop.{(max v u)+1}
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (opposite.{(max v u)+1}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.category.opposite.{v (max v u)}
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             (@category_theory.functor.op.{v v u (max v u)} C ğ’
                (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’)
                (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’))
             X))
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)
       (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
          (Type v)
          category_theory.types.{v}
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’
             (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
                Hâ‚‚))
          (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’)
                (Type v)
                category_theory.types.{v})
             (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v}))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)))
          X
          c)
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        have t := c.naturality walking_parallel_pair_hom.left,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.walking_parallel_pair_hom.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.limits.walking_parallel_pair_hom.{v} category_theory.limits.walking_parallel_pair.zero.{v} category_theory.limits.walking_parallel_pair.one.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p)))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109        conv at t { dsimp, to_lhs, simp only [category.id_comp] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î» (f : @sigma.{v v} (prod.{v v} J J) â€¦), â€¦))
             â€¦)
          category_theory.limits.walking_parallel_pair.one.{v})
       â€¦
       â€¦)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
    (@opposite.unop.{u+1} C X)
    (@opposite.unop.{u+1} C X)
    (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.parallel_pair.{v u} C ğ’
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C ğ’
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.map.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          category_theory.limits.walking_parallel_pair.zero.{v}
          category_theory.limits.walking_parallel_pair.one.{v}
          category_theory.limits.walking_parallel_pair_hom.left.{v}))
| @category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
    category_theory.limits.walking_parallel_pair_hom_category.{v}
    C
    ğ’
    (@category_theory.functor.obj.{v v u (max v u)} C ğ’
       (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’)
       (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’)
       (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’)
       (@opposite.unop.{u+1} C X))
    (@category_theory.limits.parallel_pair.{v u} C ğ’
       (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚)
       (@category_theory.limits.pi_obj.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚)
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
               (@category_theory.limits.pi_obj.{v u} J C ğ’
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚)
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
               (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                  (@prod.fst.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))
                  (@sigma.snd.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f))))
       (@category_theory.limits.pi.lift.{v u}
          (@sigma.{v v} (prod.{v v} J J)
             (Î» (p : prod.{v v} J J),
                @category_theory.has_hom.hom.{v v} J
                  (@category_theory.category_struct.to_has_hom.{v v} J
                     (@category_theory.category.to_category_struct.{v v} J _inst_1))
                  (@prod.fst.{v v} J J p)
                  (@prod.snd.{v v} J J p)))
          C
          ğ’
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))
          Hâ‚‚
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (Î»
           (f :
             @sigma.{v v} (prod.{v v} J J)
               (Î» (p : prod.{v v} J J),
                  @category_theory.has_hom.hom.{v v} J
                    (@category_theory.category_struct.to_has_hom.{v v} J
                       (@category_theory.category.to_category_struct.{v v} J _inst_1))
                    (@prod.fst.{v v} J J p)
                    (@prod.snd.{v v} J J p))),
             @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
               Hâ‚
               (@prod.snd.{v v} J J
                  (@sigma.fst.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))
                     f)))))
    c
    category_theory.limits.walking_parallel_pair.one.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C ğ’
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î» (f : @sigma.{v v} (â€¦ J) â€¦), â€¦))
             â€¦)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110        simp [t], }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v})) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) c category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@opposite.unop.{u+1} C X) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.zero.{v}) (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’) (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F (@prod.fst.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)) (@sigma.snd.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f)))) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚ (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))) category_theory.limits.walking_parallel_pair.one.{v}) (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.functor.obj.{v v u (max v u)} C ğ’ (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’) (@opposite.unop.{u+1} C X)) (@category_theory.limits.parallel_pair.{v u} C ğ’ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (@category_theory.limits.pi_obj.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚) (@category_theory.limits.pi.lift.{v u} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) C ğ’ (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))) Hâ‚‚ (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F) Hâ‚) (Î» (f : @sigma.{v v} (â€¦ J) â€¦), â€¦)) â€¦) c category_theory.limits.walking_parallel_pair.zero.{v}) â€¦)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 C ğ’,
Hâ‚ :
  @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)),
Hâ‚‚ :
  @category_theory.limits.has_limit.{v u}
    (category_theory.discrete.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    (category_theory.discrete_category.{v}
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p))))
    C
    ğ’
    (@category_theory.functor.of_function.{v v u} C ğ’
       (@sigma.{v v} (prod.{v v} J J)
          (Î» (p : prod.{v v} J J),
             @category_theory.has_hom.hom.{v v} J
               (@category_theory.category_struct.to_has_hom.{v v} J
                  (@category_theory.category.to_category_struct.{v v} J _inst_1))
               (@prod.fst.{v v} J J p)
               (@prod.snd.{v v} J J p)))
       (Î»
        (f :
          @sigma.{v v} (prod.{v v} J J)
            (Î» (p : prod.{v v} J J),
               @category_theory.has_hom.hom.{v v} J
                 (@category_theory.category_struct.to_has_hom.{v v} J
                    (@category_theory.category.to_category_struct.{v v} J _inst_1))
                 (@prod.fst.{v v} J J p)
                 (@prod.snd.{v v} J J p))),
          @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
            (@prod.snd.{v v} J J
               (@sigma.fst.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))
                  f)))),
X : opposite.{u+1} C,
c :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚))
    X,
j :
  category_theory.discrete.{v}
    (@sigma.{v v} (prod.{v v} J J)
       (Î» (p : prod.{v v} J J),
          @category_theory.has_hom.hom.{v v} J
            (@category_theory.category_struct.to_has_hom.{v v} J
               (@category_theory.category.to_category_struct.{v v} J _inst_1))
            (@prod.fst.{v v} J J p)
            (@prod.snd.{v v} J J p))),
t :
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v}))
    (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
       category_theory.limits.walking_parallel_pair_hom_category.{v}
       C
       ğ’
       (@category_theory.functor.obj.{v v u (max v u)} C ğ’
          (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
             category_theory.limits.walking_parallel_pair_hom_category.{v}
             C
             ğ’)
          (@opposite.unop.{u+1} C X))
       (@category_theory.limits.parallel_pair.{v u} C ğ’
          (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
             Hâ‚)
          (@category_theory.limits.pi_obj.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚)
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.category_struct.comp.{v u} C
                  (@category_theory.category.to_category_struct.{v u} C ğ’)
                  (@category_theory.limits.pi_obj.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚)
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                  (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                     (@prod.fst.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))
                     (@sigma.snd.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          (@category_theory.limits.pi.lift.{v u}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             C
             ğ’
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))
             Hâ‚‚
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.limits.pi.Ï€.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                  Hâ‚
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f)))))
       c
       category_theory.limits.walking_parallel_pair.one.{v})
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@opposite.unop.{u+1} C X)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.zero.{v})
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.category_struct.comp.{v u} C
                     (@category_theory.category.to_category_struct.{v u} C ğ’)
                     (@category_theory.limits.pi_obj.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.limits.pi.Ï€.{v u} J C ğ’
                        (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                        Hâ‚
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f)))
                     (@category_theory.functor.map.{v v v u} J _inst_1 C ğ’ F
                        (@prod.fst.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@prod.snd.{v v} J J
                           (@sigma.fst.{v v} (prod.{v v} J J)
                              (Î» (p : prod.{v v} J J),
                                 @category_theory.has_hom.hom.{v v} J
                                   (@category_theory.category_struct.to_has_hom.{v v} J
                                      (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                   (@prod.fst.{v v} J J p)
                                   (@prod.snd.{v v} J J p))
                              f))
                        (@sigma.snd.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f))))
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.limits.pi.Ï€.{v u} J C ğ’
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                     Hâ‚
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@category_theory.functor.obj.{v v u (max v u)} C ğ’
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@opposite.unop.{u+1} C X))
          (@category_theory.limits.parallel_pair.{v u} C ğ’
             (@category_theory.limits.pi_obj.{v u} J C ğ’ (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                Hâ‚)
             (@category_theory.limits.pi_obj.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚)
             (@category_theory.limits.pi.lift.{v u}
                (@sigma.{v v} (prod.{v v} J J)
                   (Î» (p : prod.{v v} J J),
                      @category_theory.has_hom.hom.{v v} J
                        (@category_theory.category_struct.to_has_hom.{v v} J
                           (@category_theory.category.to_category_struct.{v v} J _inst_1))
                        (@prod.fst.{v v} J J p)
                        (@prod.snd.{v v} J J p)))
                C
                ğ’
                (Î»
                 (f :
                   @sigma.{v v} (prod.{v v} J J)
                     (Î» (p : prod.{v v} J J),
                        @category_theory.has_hom.hom.{v v} J
                          (@category_theory.category_struct.to_has_hom.{v v} J
                             (@category_theory.category.to_category_struct.{v v} J _inst_1))
                          (@prod.fst.{v v} J J p)
                          (@prod.snd.{v v} J J p))),
                   @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                     (@prod.snd.{v v} J J
                        (@sigma.fst.{v v} (prod.{v v} J J)
                           (Î» (p : prod.{v v} J J),
                              @category_theory.has_hom.hom.{v v} J
                                (@category_theory.category_struct.to_has_hom.{v v} J
                                   (@category_theory.category.to_category_struct.{v v} J _inst_1))
                                (@prod.fst.{v v} J J p)
                                (@prod.snd.{v v} J J p))
                           f)))
                Hâ‚‚
                (@category_theory.limits.pi_obj.{v u} J C ğ’
                   (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F)
                   Hâ‚)
                (Î» (f : @sigma.{v v} (â€¦ J) â€¦), â€¦))
             â€¦)
          c
          category_theory.limits.walking_parallel_pair.zero.{v})
       â€¦)
âŠ¢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’))
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.comp.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚))
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_hom.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚)
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_inv.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C ğ’)
       (@category_theory.functor.obj.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚)
       (@category_theory.functor.obj.{v v v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          j)
       (@category_theory.nat_trans.app.{v v v u} category_theory.limits.walking_parallel_pair.{v}
          category_theory.limits.walking_parallel_pair_hom_category.{v}
          C
          ğ’
          (@opposite.unop.{(max v u)+1}
             (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C ğ’)
                (opposite.{(max v u)+1}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.category.opposite.{v (max v u)}
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                (@category_theory.functor.op.{v v u (max v u)} C ğ’
                   (@category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.category.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’)
                   (@category_theory.functor.const.{v v v u} category_theory.limits.walking_parallel_pair.{v}
                      category_theory.limits.walking_parallel_pair_hom_category.{v}
                      C
                      ğ’))
                X))
          (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚
             Hâ‚‚)
          (@category_theory.nat_trans.app.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C ğ’)
             (Type v)
             category_theory.types.{v}
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                category_theory.limits.walking_parallel_pair_hom_category.{v}
                C
                ğ’
                (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                   Hâ‚
                   Hâ‚‚))
             (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
                (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C ğ’)
                   (Type v)
                   category_theory.types.{v})
                (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
                   (@category_theory.functor.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v})
                   (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C ğ’)
                      (Type v)
                      category_theory.types.{v}))
                (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v}
                   category_theory.limits.walking_parallel_pair_hom_category.{v}
                   C
                   ğ’
                   (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F
                      Hâ‚
                      Hâ‚‚)))
             X
             c)
          category_theory.limits.walking_parallel_pair.one.{v})
       (@category_theory.limits.limit.Ï€.{v u}
          (category_theory.discrete.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          (category_theory.discrete_category.{v}
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p))))
          C
          ğ’
          (@category_theory.functor.of_function.{v v u} C ğ’
             (@sigma.{v v} (prod.{v v} J J)
                (Î» (p : prod.{v v} J J),
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     (@prod.fst.{v v} J J p)
                     (@prod.snd.{v v} J J p)))
             (Î»
              (f :
                @sigma.{v v} (prod.{v v} J J)
                  (Î» (p : prod.{v v} J J),
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       (@prod.fst.{v v} J J p)
                       (@prod.snd.{v v} J J p))),
                @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F
                  (@prod.snd.{v v} J J
                     (@sigma.fst.{v v} (prod.{v v} J J)
                        (Î» (p : prod.{v v} J J),
                           @category_theory.has_hom.hom.{v v} J
                             (@category_theory.category_struct.to_has_hom.{v v} J
                                (@category_theory.category.to_category_struct.{v v} J _inst_1))
                             (@prod.fst.{v v} J J p)
                             (@prod.snd.{v v} J J p))
                        f))))
          Hâ‚‚
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  open has_limit_of_has_products_of_has_equalizers</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  /-- Any category with products and equalizers has all limits. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  -- This is not an instance, as it is not always how one wants to construct limits!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  def limits_from_equalizers_and_products</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    [has_products.{v} C] [has_equalizers.{v} C] : has_limits.{v} C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_products'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_equalizers'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/products.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  { has_limits_of_shape := Î» J ğ’¥, by exactI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ğ’¥'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_products.{v u} C ğ’,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C ğ’,
J : Type v,
ğ’¥ : category_theory.small_category.{v} J
âŠ¢ @category_theory.limits.has_limits_of_shape.{v u} J ğ’¥ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    { has_limit := Î» F, has_limit.of_cones_iso (diagram F) F (cones_iso F) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.has_limit.of_cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J K : Type v} [_inst_3 : category_theory.small_category.{v} J] [_inst_4 : category_theory.small_category.{v} K] (F : @category_theory.functor.{v v v u} J _inst_3 C ğ’) (G : @category_theory.functor.{v v v u} K _inst_4 C ğ’), @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} J _inst_3 C ğ’ F) (@category_theory.functor.cones.{v u} K _inst_4 C ğ’ G) â†’ Î  [_inst_5 : @category_theory.limits.has_limit.{v u} J _inst_3 C ğ’ F], @category_theory.limits.has_limit.{v u} K _inst_4 C ğ’ G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)) (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Corresponding to any functor `F : J â¥¤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
âˆ_j F j ===&gt; Î _{f : j âŸ¶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `âˆ_j F j âŸ¶ F j` followed by `f`.
* The `t_f` component is the projection `âˆ_j F j âŸ¶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The natural isomorphism between cones over the
walking pair diagram `diagram F` and cones over the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_products.{v u} C ğ’,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C ğ’,
J : Type v,
ğ’¥ : category_theory.small_category.{v} J
âŠ¢ @category_theory.limits.has_limits_of_shape.{v u} J ğ’¥ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  /-- Any category with finite products and equalizers has all finite limits. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  -- This is not an instance, as it is not always how one wants to construct finite limits!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  def finite_limits_from_equalizers_and_finite_products</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    [has_finite_products.{v} C] [has_equalizers.{v} C] : has_finite_limits.{v} C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_finite_products'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.has_equalizers'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_finite_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_products.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/shapes/finite_limits.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (C : Type u) [ğ’ : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  { has_limits_of_shape := Î» J _ _, by exactI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.fin_category.{v} J _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_finite_products.{v u} C ğ’,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C ğ’,
J : Type v,
_x : category_theory.small_category.{v} J,
_x : @category_theory.limits.fin_category.{v} J _x
âŠ¢ @category_theory.limits.has_limits_of_shape.{v u} J _x C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    { has_limit := Î» F, has_limit.of_cones_iso (diagram F) F (cones_iso F) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.has_limit.of_cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.has_limit_of_has_products_of_has_equalizers.cones_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J K : Type v} [_inst_3 : category_theory.small_category.{v} J] [_inst_4 : category_theory.small_category.{v} K] (F : @category_theory.functor.{v v v u} J _inst_3 C ğ’) (G : @category_theory.functor.{v v v u} K _inst_4 C ğ’), @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} J _inst_3 C ğ’ F) (@category_theory.functor.cones.{v u} K _inst_4 C ğ’ G) â†’ Î  [_inst_5 : @category_theory.limits.has_limit.{v u} J _inst_3 C ğ’ F], @category_theory.limits.has_limit.{v u} K _inst_4 C ğ’ G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.functor.{v v v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type u} [ğ’ : category_theory.category.{v u} C] {J : Type v} [_inst_1 : category_theory.small_category.{v} J] (F : @category_theory.functor.{v v v u} J _inst_1 C ğ’) [Hâ‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} J) (category_theory.discrete_category.{v} J) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ J (@category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F))] [Hâ‚‚ : @category_theory.limits.has_limit.{v u} (category_theory.discrete.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) (category_theory.discrete_category.{v} (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)))) C ğ’ (@category_theory.functor.of_function.{v v u} C ğ’ (@sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))) (Î» (f : @sigma.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p))), @category_theory.functor.obj.{v v v u} J _inst_1 C ğ’ F (@prod.snd.{v v} J J (@sigma.fst.{v v} (prod.{v v} J J) (Î» (p : prod.{v v} J J), @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) (@prod.fst.{v v} J J p) (@prod.snd.{v v} J J p)) f))))], @category_theory.iso.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C ğ’) (Type v) category_theory.types.{v}) (@category_theory.functor.cones.{v u} category_theory.limits.walking_parallel_pair.{v} category_theory.limits.walking_parallel_pair_hom_category.{v} C ğ’ (@category_theory.limits.has_limit_of_has_products_of_has_equalizers.diagram.{v u} C ğ’ J _inst_1 F Hâ‚ Hâ‚‚)) (@category_theory.functor.cones.{v u} J _inst_1 C ğ’ F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Corresponding to any functor `F : J â¥¤ C`, we construct a new functor from the walking parallel
pair of morphisms to `C`, given by the diagram
```lean
         s
âˆ_j F j ===&gt; Î _{f : j âŸ¶ j&#x27;} F j&#x27;
         t
```
where the two morphisms `s` and `t` are defined componentwise:
* The `s_f` component is the projection `âˆ_j F j âŸ¶ F j` followed by `f`.
* The `t_f` component is the projection `âˆ_j F j âŸ¶ F j&#x27;`.

In a moment we prove that cones over `F` are isomorphic to cones over this new diagram.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The natural isomorphism between cones over the
walking pair diagram `diagram F` and cones over the original diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
ğ’ : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_finite_products.{v u} C ğ’,
_inst_3 : @category_theory.limits.has_equalizers.{v u} C ğ’,
J : Type v,
_x : category_theory.small_category.{v} J,
_x : @category_theory.limits.fin_category.{v} J _x
âŠ¢ @category_theory.limits.has_limits_of_shape.{v u} J _x C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  end category_theory.limits</code></pre>
</body>