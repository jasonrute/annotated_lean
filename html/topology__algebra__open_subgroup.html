<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  import order.filter.lift</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  import linear_algebra.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  import topology.opens topology.algebra.ring</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/opens.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ring.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  open topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  variables (G : Type*) [group G] [topological_space G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-- The type of open subgroups of a topological group. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  @[to_additive open_add_subgroup]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  def open_subgroup := { U : set G // is_open U ∧ is_subgroup U }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  instance open_subgroup.has_coe :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15    has_coe (open_subgroup G) (opens G) := ⟨λ U, ⟨U.1, U.2.1⟩⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  -- Tell Lean that `open_add_subgroup` is a namespace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  namespace open_add_subgroup</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  end open_add_subgroup</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  namespace open_subgroup</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  open function lattice topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  open_locale topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  variables {G : Type*} [group G] [topological_space G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  variables {U V : open_subgroup G}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  instance : has_mem G (open_subgroup G) := ⟨λ g U, g ∈ (U : set G)⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  lemma ext : (U = V) ↔ ((U : set G) = V) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  by cases U; cases V; split; intro h; try {congr}; assumption</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  @[ext, to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  lemma ext&#x27; (h : (U : set G) = V) : (U = V) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  ext.mpr h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  lemma coe_injective : injective (λ U : open_subgroup G, (U : set G)) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  λ U V h, ext&#x27; h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='open_subgroup.ext&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} G) ((λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) U) ((λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] {U V : @open_subgroup.{u_1} G _inst_1 _inst_2}, @eq.{(max (u_1+1) 1)} (set.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) V) → @eq.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) U V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max (u_1+1) 1)} (set.{u_1} G) ((λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) U) ((λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) V)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  @[to_additive is_add_subgroup]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance : is_subgroup (U : set G) := U.2.2</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  variable (U)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  protected lemma is_open : is_open (U : set G) := U.2.1</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  protected lemma one_mem : (1 : G) ∈ U := is_submonoid.one_mem (U : set G)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  protected lemma inv_mem {g : G} (h : g ∈ U) : g⁻¹ ∈ U :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    @is_subgroup.inv_mem G _ U _ g h</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  protected lemma mul_mem {g₁ g₂ : G} (h₁ : g₁ ∈ U) (h₂ : g₂ ∈ U) : g₁ * g₂ ∈ U :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    @is_submonoid.mul_mem G _ U _ g₁ g₂ h₁ h₂</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  lemma mem_nhds_one : (U : set G) ∈ 𝓝 (1 : G) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  mem_nhds_sets U.is_open U.one_mem</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  variable {U}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  instance : inhabited (open_subgroup G) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { default := ⟨set.univ, ⟨is_open_univ, by apply_instance⟩⟩ }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  lemma is_open_of_nonempty_open_subset [topological_monoid G] {s : set G} [is_subgroup s]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (h : ∃ U : opens G, nonempty U ∧ (U : set G) ⊆ s) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    is_open s :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    rw is_open_iff_forall_mem_open,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    intros x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    rcases h with ⟨U, ⟨g, hg⟩, hU⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    use (λ y, y * (x⁻¹ * g)) ⁻¹&#x27; U,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    { intros u hu,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      erw set.mem_preimage at hu,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      replace hu := hU hu,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      replace hg := hU hg,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      have : (x⁻¹ * g)⁻¹ ∈ s,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      { simp [*, is_subgroup.inv_mem, is_submonoid.mul_mem], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] {s : set.{?l_1} α} [c : @is_submonoid.{?l_1} α _inst_1 s] {a b : α}, @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) b s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g u : G,
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s,
hg : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g s
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g u : G,
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s,
hg : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g s,
this :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      convert is_submonoid.mul_mem hu this, simp [mul_assoc] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} [c : @is_submonoid.{u_1} α _inst_1 s] {a b : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) (@has_mul.mul.{u_1} G (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1))) u (@has_mul.mul.{u_1} G (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1))) (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x) g)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) (@has_mul.mul.{u_1} G (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1))) (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x) g)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a b) c) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g u : G,
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s,
hg : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g s,
this :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g u : G,
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s,
hg : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g s,
this :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    s
⊢ @eq.{u_1+1} G u
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          u
          (@has_mul.mul.{u_1} G
             (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
             (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
             g))
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
          (@has_mul.mul.{u_1} G
             (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
             (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
                  g))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2)))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
                  g))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2)))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
                  g))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2)))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
                  g))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2)))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    { exact continuous_id.mul continuous_const _ U.property },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 654, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @continuous.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_1} β] {b : β}, @continuous.{u_1 u_1} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} G _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    { change  x * (x⁻¹ * g) ∈ U,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@topological_space.opens.{u_1} G _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
               g))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2)))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (@topological_space.opens.{u_1} G _inst_2)
    (@topological_space.opens.has_mem.{u_1} G _inst_2)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       x
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90      convert hg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (@topological_space.opens.{u_1} G _inst_2)
    (@topological_space.opens.has_mem.{u_1} G _inst_2)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       x
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    U'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @eq.{u_1+1} G
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       x
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      rw [← mul_assoc, mul_right_inv, one_mul] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_right_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semigroup.{u_1} α] (a b c : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a b) c) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α (@group.to_monoid.{u_1} α _inst_1))) a (@has_inv.inv.{u_1} α (@group.to_has_inv.{u_1} α _inst_1) a)) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@group.to_monoid.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @eq.{u_1+1} G
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       x
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @eq.{u_1+1} G
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          x
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       g)
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @eq.{u_1+1} G
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       (@has_one.one.{u_1} G (@monoid.to_has_one.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       g)
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
s : set.{u_1} G,
_inst_4 : @is_subgroup.{u_1} G _inst_1 s,
x : G,
hx : @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x s,
U : @topological_space.opens.{u_1} G _inst_2,
hU :
  @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
             (@topological_space.opens.has_coe.{u_1} G _inst_2)))
       U)
    s,
g : G,
hg :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) g
    (@has_coe_t_aux.coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
       (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
          (@topological_space.opens.has_coe.{u_1} G _inst_2))
       U)
⊢ @eq.{u_1+1} G
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       x
       (@has_mul.mul.{u_1} G
          (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
          (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  @[to_additive is_open_of_open_add_subgroup]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  lemma is_open_of_open_subgroup [topological_monoid G] {s : set G} [is_subgroup s]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='topological_monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α] [_inst_2 : monoid.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : group.{u_1} α], set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title=' A topological monoid is a monoid in which the multiplication is continuous as a function
`α × α → α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`s` is a subgroup: a set containing 1 and closed under multiplication and inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    (h : ∃ U : open_subgroup G, (U : set G) ⊆ s) : is_open s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [t : topological_space.{u_1} α], set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  is_open_of_nonempty_open_subset $ let ⟨U, hU⟩ := h in ⟨U, ⟨⟨1, U.one_mem⟩⟩, hU⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='open_subgroup.is_open_of_nonempty_open_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='open_subgroup.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] [_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1)] {s : set.{u_1} G} [_inst_4 : @is_subgroup.{u_1} G _inst_1 s], @Exists.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (λ (U : @topological_space.opens.{u_1} G _inst_2), and (nonempty.{(max 1 (u_1+1))} (@coe_sort.{(max (u_1+1) 1) (max 1 (u_1+1))+1} (@topological_space.opens.{u_1} G _inst_2) (@coe_sort_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max 1 (u_1+1))+1} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)) (@set.has_coe_to_sort.{u_1} G)) U)) (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2))) U) s)) → @is_open.{u_1} G _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@Exists.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) s) → @Exists.{(max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (λ (U : @topological_space.opens.{u_1} G _inst_2), and (nonempty.{(max 1 (u_1+1))} (@coe_sort.{(max (u_1+1) 1) (max 1 (u_1+1))+1} (@topological_space.opens.{u_1} G _inst_2) (@coe_sort_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max 1 (u_1+1))+1} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_base_aux.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)) (@set.has_coe_to_sort.{u_1} G)) U)) (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2))) U) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@Exists.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @has_mem.mem.{u_1 u_1} G (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.has_mem.{u_1} G _inst_1 _inst_2) (@has_one.one.{u_1} G (@monoid.to_has_one.{u_1} G (@group.to_monoid.{u_1} G _inst_1))) U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  lemma is_closed [topological_monoid G] (U : open_subgroup G) : is_closed (U : set G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='topological_monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α] [_inst_2 : monoid.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' A topological monoid is a monoid in which the multiplication is continuous as a function
`α × α → α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_closed.{u_1} G _inst_2
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    show is_open (-(U : set G)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [t : topological_space.{u_1} α], set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_neg.{u_1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_closed.{u_1} G _inst_2
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_open.{u_1} G _inst_2
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    rw is_open_iff_forall_mem_open,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_open_iff_forall_mem_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α} [_inst_1 : topological_space.{u_1} α], iff (@is_open.{u_1} α _inst_1 s) (∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → @Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t s) (λ (H : @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) t s), and (@is_open.{u_1} α _inst_1 t) (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_open.{u_1} G _inst_2
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ ∀ (x : G),
    @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
      (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
         (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
            (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
               (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                  (@topological_space.opens.{u_1} G _inst_2)
                  (set.{u_1} G)
                  (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                  (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                     (@topological_space.opens.has_coe.{u_1} G _inst_2))))
            U)) →
    @Exists.{u_1+1} (set.{u_1} G)
      (λ (t : set.{u_1} G),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
              (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                    (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                       (set.{u_1} G)
                       (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                          (@open_subgroup.{u_1} G _inst_1 _inst_2)
                          (@topological_space.opens.{u_1} G _inst_2)
                          (set.{u_1} G)
                          (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                             (set.{u_1} G)
                             (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                    U)))
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
                (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                   (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                      (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                         (set.{u_1} G)
                         (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                            (@open_subgroup.{u_1} G _inst_1 _inst_2)
                            (@topological_space.opens.{u_1} G _inst_2)
                            (set.{u_1} G)
                            (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                            (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                               (set.{u_1} G)
                               (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                      U))),
              and (@is_open.{u_1} G _inst_2 t) (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    intros x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ ∀ (x : G),
    @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
      (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
         (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
            (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
               (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                  (@topological_space.opens.{u_1} G _inst_2)
                  (set.{u_1} G)
                  (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                  (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                     (@topological_space.opens.has_coe.{u_1} G _inst_2))))
            U)) →
    @Exists.{u_1+1} (set.{u_1} G)
      (λ (t : set.{u_1} G),
         @Exists.{0}
           (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
              (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                    (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                       (set.{u_1} G)
                       (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                          (@open_subgroup.{u_1} G _inst_1 _inst_2)
                          (@topological_space.opens.{u_1} G _inst_2)
                          (set.{u_1} G)
                          (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                             (set.{u_1} G)
                             (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                    U)))
           (λ
            (H :
              @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
                (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                   (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                      (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                         (set.{u_1} G)
                         (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                            (@open_subgroup.{u_1} G _inst_1 _inst_2)
                            (@topological_space.opens.{u_1} G _inst_2)
                            (set.{u_1} G)
                            (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                            (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                               (set.{u_1} G)
                               (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                      U))),
              and (@is_open.{u_1} G _inst_2 t) (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @Exists.{u_1+1} (set.{u_1} G)
    (λ (t : set.{u_1} G),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
            (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  U)))
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
              (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                    (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                       (set.{u_1} G)
                       (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                          (@open_subgroup.{u_1} G _inst_1 _inst_2)
                          (@topological_space.opens.{u_1} G _inst_2)
                          (set.{u_1} G)
                          (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                             (set.{u_1} G)
                             (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                    U))),
            and (@is_open.{u_1} G _inst_2 t) (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    use (λ y, y * x⁻¹) ⁻¹&#x27; U,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_inv.{u_1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @Exists.{u_1+1} (set.{u_1} G)
    (λ (t : set.{u_1} G),
       @Exists.{0}
         (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
            (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  U)))
         (λ
          (H :
            @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) t
              (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
                 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                    (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                       (set.{u_1} G)
                       (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                          (@open_subgroup.{u_1} G _inst_1 _inst_2)
                          (@topological_space.opens.{u_1} G _inst_2)
                          (set.{u_1} G)
                          (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                          (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                             (set.{u_1} G)
                             (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                    U))),
            and (@is_open.{u_1} G _inst_2 t) (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U))
       (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (and
       (@is_open.{u_1} G _inst_2
          (@set.preimage.{u_1 u_1} G G
             (λ (y : G),
                @has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  y
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)))
       (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
          (@set.preimage.{u_1 u_1} G G
             (λ (y : G),
                @has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  y
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U))
       (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (and
       (@is_open.{u_1} G _inst_2
          (@set.preimage.{u_1 u_1} G G
             (λ (y : G),
                @has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  y
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)))
       (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
          (@set.preimage.{u_1 u_1} G G
             (λ (y : G),
                @has_mul.mul.{u_1} G
                  (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
                  y
                  (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    { intros u hux,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108      erw set.mem_preimage at hux,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} {f : α → β} {s : set.{u_1} β} {a : α}, iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 u_1} α β f s)) (@has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109      rw set.mem_compl_iff at hx ⊢,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.mem_compl_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 598, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (s : set.{u_1} α) (x : α), iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α) s)) (not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      intro hu, apply hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111      convert is_submonoid.mul_mem (is_subgroup.inv_mem hux) hu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_subgroup.inv_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {s : set.{u_1} α} [c : @is_submonoid.{u_1} α _inst_1 s] {a b : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) b s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] {s : set.{u_1} α} [c : @is_subgroup.{u_1} α _inst_1 s] {a : α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_inv.inv.{u_1} α (@group.to_has_inv.{u_1} α _inst_1) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) (@has_mul.mul.{u_1} G (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1))) u (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @eq.{u_1+1} G x
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
          (@has_mul.mul.{u_1} G
             (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
             u
             (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)))
       u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112      simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x u : G,
hux :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G)
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       u
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U),
hx :
  not
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)),
hu :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) u
    (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
       (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
             (@topological_space.opens.{u_1} G _inst_2)
             (set.{u_1} G)
             (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
             (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                (@topological_space.opens.has_coe.{u_1} G _inst_2))))
       U)
⊢ @eq.{u_1+1} G x
    (@has_mul.mul.{u_1} G
       (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
       (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1)
          (@has_mul.mul.{u_1} G
             (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
             u
             (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x)))
       u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ and
    (@is_open.{u_1} G _inst_2
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))
    (@has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
       (@set.preimage.{u_1 u_1} G G
          (λ (y : G),
             @has_mul.mul.{u_1} G
               (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
               y
               (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    { exact (continuous_mul_right _) _ U.is_open },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='continuous_mul_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : monoid.{u_1} α] [_inst_3 : @topological_monoid.{u_1} α _inst_1 _inst_2] (a : α), @continuous.{u_1 u_1} α α _inst_1 _inst_1 (λ (b : α), @has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_2)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @is_open.{u_1} G _inst_2
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    { simpa using is_submonoid.one_mem (U : set G) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='is_submonoid.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (s : set.{u_1} α) [c : @is_submonoid.{u_1} α _inst_1 s], @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
x : G,
hx :
  @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@has_neg.neg.{u_1} (set.{u_1} G) (@set.has_neg.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))
⊢ @has_mem.mem.{u_1 u_1} G (set.{u_1} G) (@set.has_mem.{u_1} G) x
    (@set.preimage.{u_1 u_1} G G
       (λ (y : G),
          @has_mul.mul.{u_1} G
            (@semigroup.to_has_mul.{u_1} G (@monoid.to_semigroup.{u_1} G (@group.to_monoid.{u_1} G _inst_1)))
            y
            (@has_inv.inv.{u_1} G (@group.to_has_inv.{u_1} G _inst_1) x))
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  variables {H : Type*} [group H] [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  def prod (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G × H) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  ⟨(U : set G).prod (V : set H), is_open_prod U.is_open V.is_open, by apply_instance⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='open_subgroup.is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='open_subgroup.is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@open_subgroup.{u_2} H _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β] {s : set.{u} α} {t : set.{v} β}, @is_open.{u} α _inst_1 s → @is_open.{v} β _inst_2 t → @is_open.{(max u v)} (prod.{u v} α β) (@prod.topological_space.{u v} α β _inst_1 _inst_2) (@set.prod.{u v} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @is_open.{u_1} G _inst_2 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_2} H _inst_3 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_2} [_inst_1 : group.{u_2} G] [_inst_2 : topological_space.{u_2} G] (U : @open_subgroup.{u_2} G _inst_1 _inst_2), @is_open.{u_2} G _inst_2 (@coe.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} G _inst_1 _inst_2) (set.{u_2} G) (@coe_to_lift.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} G _inst_1 _inst_2) (set.{u_2} G) (@coe_trans.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} G _inst_1 _inst_2) (@topological_space.opens.{u_2} G _inst_2) (set.{u_2} G) (@open_subgroup.has_coe.{u_2} G _inst_1 _inst_2) (@coe_base.{(max (u_2+1) 1) (max (u_2+1) 1)} (@topological_space.opens.{u_2} G _inst_2) (set.{u_2} G) (@topological_space.opens.has_coe.{u_2} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
H : Type u_2,
_inst_3 : group.{u_2} H,
_inst_4 : topological_space.{u_2} H,
U : @open_subgroup.{u_1} G _inst_1 _inst_2,
V : @open_subgroup.{u_2} H _inst_3 _inst_4
⊢ @is_subgroup.{(max u_1 u_2)} (prod.{u_1 u_2} G H) (@prod.group.{u_1 u_2} G H _inst_1 _inst_3)
    (@set.prod.{u_1 u_2} G H
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)
       (@coe.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} H _inst_3 _inst_4) (set.{u_2} H)
          (@coe_to_lift.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} H _inst_3 _inst_4) (set.{u_2} H)
             (@coe_trans.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_2+1) 1)} (@open_subgroup.{u_2} H _inst_3 _inst_4)
                (@topological_space.opens.{u_2} H _inst_4)
                (set.{u_2} H)
                (@open_subgroup.has_coe.{u_2} H _inst_3 _inst_4)
                (@coe_base.{(max (u_2+1) 1) (max (u_2+1) 1)} (@topological_space.opens.{u_2} H _inst_4) (set.{u_2} H)
                   (@topological_space.opens.has_coe.{u_2} H _inst_4))))
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  instance : partial_order (open_subgroup G) := partial_order.lift _ coe_injective (by apply_instance)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='partial_order.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='open_subgroup.coe_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} (f : α → β), @function.injective.{u_1+1 u_2+1} α β f → partial_order.{u_2} β → partial_order.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], @function.injective.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                     </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                    </code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G
⊢ partial_order.{u_1} (set.{u_1} G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  instance : semilattice_inf_top (open_subgroup G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.semilattice_inf_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `semilattice_inf_top` is a semilattice with top and meet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  { inf := λ U V, ⟨(U : set G) ∩ V, is_open_inter U.is_open V.is_open, by apply_instance⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='open_subgroup.is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='open_subgroup.is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 48, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {s₁ s₂ : set.{u_1} α} [t : topological_space.{u_1} α], @is_open.{u_1} α t s₁ → @is_open.{u_1} α t s₂ → @is_open.{u_1} α t (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @is_open.{u_1} G _inst_2 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @is_open.{u_1} G _inst_2 (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                        </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                        </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_subgroup.{u_1} G _inst_1
    (@has_inter.inter.{u_1} (set.{u_1} G) (@set.has_inter.{u_1} G)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          U)
       (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
          (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                (@topological_space.opens.{u_1} G _inst_2)
                (set.{u_1} G)
                (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                   (@topological_space.opens.has_coe.{u_1} G _inst_2))))
          V))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    inf_le_left := λ U V, set.inter_subset_left _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    inf_le_right := λ U V, set.inter_subset_right _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_subset_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    le_inf := λ U V W hV hW, set.subset_inter hV hW,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='W'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hW'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hW'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 389, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2))))) U V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2))))) U W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {s t r : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) r s → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) r t → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) r (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2))))) U V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2)) (@partial_order.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.partial_order.{u_1} G _inst_1 _inst_2))))) U W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    top := default _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='default'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 771, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (α : Sort u) [_inst_1 : inhabited.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    le_top := λ U, set.subset_univ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 240, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    ..open_subgroup.partial_order }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='open_subgroup.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 128, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], partial_order.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  @[to_additive]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  instance [topological_monoid G] : semilattice_sup_top (open_subgroup G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='topological_monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.semilattice_sup_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α] [_inst_2 : monoid.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (G : Type u_1) [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' A topological monoid is a monoid in which the multiplication is continuous as a function
`α × α → α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `semilattice_sup_top` is a semilattice with top and join.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of open subgroups of a topological group.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  { sup := λ U V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    { val := group.closure ((U : set G) ∪ V),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='group.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : group.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_union.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`group.closure s` is the subgroup closed over `s`, i.e. the smallest subgroup containg s.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      property :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ and
    (@is_open.{u_1} G _inst_2
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))
    (@is_subgroup.{u_1} G _inst_1
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146        haveI subgrp := _, refine ⟨_, subgrp⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='subgrp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_subgroup.{u_1} G _inst_1 (@group.closure.{u_1} G _inst_1 (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ and
    (@is_open.{u_1} G _inst_2
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))
    (@is_subgroup.{u_1} G _inst_1
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp : ?m_1
⊢ and
    (@is_open.{u_1} G _inst_2
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))
    (@is_subgroup.{u_1} G _inst_1
       (@group.closure.{u_1} G _inst_1
          (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                U)
             (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                   (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                      (@open_subgroup.{u_1} G _inst_1 _inst_2)
                      (@topological_space.opens.{u_1} G _inst_2)
                      (set.{u_1} G)
                      (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                      (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                         (set.{u_1} G)
                         (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                V))))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp :
  @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))
⊢ @is_open.{u_1} G _inst_2
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147        { refine is_open_of_open_subgroup _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='open_subgroup.is_open_of_open_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G] [_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1)] {s : set.{u_1} G} [_inst_4 : @is_subgroup.{u_1} G _inst_1 s], @Exists.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (λ (U : @open_subgroup.{u_1} G _inst_1 _inst_2), @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G) (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G) (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2) (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G) (@topological_space.opens.has_coe.{u_1} G _inst_2)))) U) s) → @is_open.{u_1} G _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp :
  @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))
⊢ @is_open.{u_1} G _inst_2
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))

G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp :
  @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))
⊢ @is_open.{u_1} G _inst_2
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp :
  @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))
⊢ @Exists.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
    (λ (U_1 : @open_subgroup.{u_1} G _inst_1 _inst_2),
       @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
         (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
            (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
               (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                  (@topological_space.opens.{u_1} G _inst_2)
                  (set.{u_1} G)
                  (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                  (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                     (@topological_space.opens.has_coe.{u_1} G _inst_2))))
            U_1)
         (@group.closure.{u_1} G _inst_1
            (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  U)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148          exact ⟨U, set.subset.trans (set.subset_union_left _ _) group.subset_closure⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_union_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='group.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 456, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b c : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) a b → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) b c → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} (s t : set.{u_1} α), @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@has_union.union.{u_1} (set.{u_1} α) (@set.has_union.{u_1} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2,
subgrp :
  @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))
⊢ @Exists.{(max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
    (λ (U_1 : @open_subgroup.{u_1} G _inst_1 _inst_2),
       @has_subset.subset.{u_1} (set.{u_1} G) (@set.has_subset.{u_1} G)
         (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
            (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
               (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                  (@topological_space.opens.{u_1} G _inst_2)
                  (set.{u_1} G)
                  (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                  (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                     (@topological_space.opens.has_coe.{u_1} G _inst_2))))
            U_1)
         (@group.closure.{u_1} G _inst_1
            (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  U)
               (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                  (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                     (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)}
                        (@open_subgroup.{u_1} G _inst_1 _inst_2)
                        (@topological_space.opens.{u_1} G _inst_2)
                        (set.{u_1} G)
                        (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                        (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2)
                           (set.{u_1} G)
                           (@topological_space.opens.has_coe.{u_1} G _inst_2))))
                  V))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149        { apply_instance }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='G : Type u_1,
_inst_1 : group.{u_1} G,
_inst_2 : topological_space.{u_1} G,
_inst_3 : @topological_monoid.{u_1} G _inst_2 (@group.to_monoid.{u_1} G _inst_1),
U V : @open_subgroup.{u_1} G _inst_1 _inst_2
⊢ @is_subgroup.{u_1} G _inst_1
    (@group.closure.{u_1} G _inst_1
       (@has_union.union.{u_1} (set.{u_1} G) (@set.has_union.{u_1} G)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             U)
          (@coe.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
             (@coe_to_lift.{(max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2) (set.{u_1} G)
                (@coe_trans.{(max (u_1+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (@open_subgroup.{u_1} G _inst_1 _inst_2)
                   (@topological_space.opens.{u_1} G _inst_2)
                   (set.{u_1} G)
                   (@open_subgroup.has_coe.{u_1} G _inst_1 _inst_2)
                   (@coe_base.{(max (u_1+1) 1) (max (u_1+1) 1)} (@topological_space.opens.{u_1} G _inst_2) (set.{u_1} G)
                      (@topological_space.opens.has_coe.{u_1} G _inst_2))))
             V)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    le_sup_left := λ U V, set.subset.trans (set.subset_union_left _ _) group.subset_closure,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_union_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='group.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 456, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    le_sup_right := λ U V, set.subset.trans (set.subset_union_right _ _) group.subset_closure,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_union_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='group.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 456, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a b c : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a b → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) b c → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@group.closure.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    sup_le := λ U V W hU hV, group.closure_subset $ set.union_subset hU hV,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='W'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='group.closure_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.union_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hU'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hV'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 459, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@lattice.semilattice_inf_top.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2))))) U W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@lattice.semilattice_inf_top.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2))))) V W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : group.{u_1} α] {s t : set.{u_1} α} [_inst_2 : @is_subgroup.{u_1} α _inst_1 t], @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s t → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@group.closure.{u_1} α _inst_1 s) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {s t r : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s r → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t r → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@lattice.semilattice_inf_top.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2))))) U W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@preorder.to_has_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.to_preorder.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@partial_order.mk.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@lattice.semilattice_inf_top.le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_refl.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_trans.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.lt_iff_le_not_le.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2)) (@lattice.semilattice_inf_top.le_antisymm.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2) (@open_subgroup.lattice.semilattice_inf_top.{u_1} G _inst_1 _inst_2))))) V W'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    ..open_subgroup.lattice.semilattice_inf_top }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='open_subgroup.lattice.semilattice_inf_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {G : Type u_1} [_inst_1 : group.{u_1} G] [_inst_2 : topological_space.{u_1} G], lattice.semilattice_inf_top.{u_1} (@open_subgroup.{u_1} G _inst_1 _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  @[simp, to_additive] lemma coe_inf : (↑(U ⊓ V) : set G) = (U : set G) ∩ V := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {a : Type u_1} {b : Type u_1} [_inst_1 : has_lift_t.{u_1+1 (max (u_1+1) 1)} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max (u_1+1) 1)} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[to_additive] lemma le_iff : U ≤ V ↔ (U : set G) ⊆ V := iff.rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='iff.rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@open_subgroup.{u_1} G _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {a : Prop}, iff a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Transport multiplicative to additive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  end open_subgroup</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  namespace submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  open open_add_subgroup</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  variables {R : Type*} {M : Type*} [comm_ring R]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  variables [add_comm_group M] [topological_space M] [topological_add_group M] [module R M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_add_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/group.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_2) [_inst_1 : topological_space.{u_2} α] [_inst_2 : add_group.{u_2} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A topological (additive) group is a group in which the addition and negation operations are
continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  lemma is_open_of_open_submodule {P : submodule R M}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    (h : ∃ U : submodule R M, is_open (U : set M) ∧ U ≤ P) : is_open (P : set M) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  let ⟨U, h₁, h₂⟩ := h in is_open_of_open_add_subgroup ⟨⟨U, h₁, by apply_instance⟩, h₂⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='open_add_subgroup.is_open_of_open_add_subgroup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_2+1} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (λ (U : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5), and (@is_open.{u_2} M _inst_3 (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U)) (@has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@partial_order.to_preorder.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U P)) → @is_open.{u_2} M _inst_3 (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) P)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_open.{u_2} M _inst_3 (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@partial_order.to_preorder.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U P'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@Exists.{u_2+1} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (λ (U : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5), and (@is_open.{u_2} M _inst_3 (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_to_lift.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@coe_base.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_2} M) (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U)) (@has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@partial_order.to_preorder.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U P))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {G : Type u_2} [_inst_1 : add_group.{u_2} G] [_inst_2 : topological_space.{u_2} G] [_inst_3 : @topological_add_monoid.{u_2} G _inst_2 (@add_group.to_add_monoid.{u_2} G _inst_1)] {s : set.{u_2} G} [_inst_4 : @is_add_subgroup.{u_2} G _inst_1 s], @Exists.{(max (u_2+1) 1)} (@open_add_subgroup.{u_2} G _inst_1 _inst_2) (λ (U : @open_add_subgroup.{u_2} G _inst_1 _inst_2), @has_subset.subset.{u_2} (set.{u_2} G) (@set.has_subset.{u_2} G) (@coe.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_add_subgroup.{u_2} G _inst_1 _inst_2) (set.{u_2} G) (@coe_to_lift.{(max (u_2+1) 1) (max (u_2+1) 1)} (@open_add_subgroup.{u_2} G _inst_1 _inst_2) (set.{u_2} G) (@coe_trans.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_2+1) 1)} (@open_add_subgroup.{u_2} G _inst_1 _inst_2) (@topological_space.opens.{u_2} G _inst_2) (set.{u_2} G) (@open_add_subgroup.has_coe.{u_2} G _inst_1 _inst_2) (@coe_base.{(max (u_2+1) 1) (max (u_2+1) 1)} (@topological_space.opens.{u_2} G _inst_2) (set.{u_2} G) (@topological_space.opens.has_coe.{u_2} G _inst_2)))) U) s) → @is_open.{u_2} G _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
_inst_1 : comm_ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : topological_space.{u_2} M,
_inst_4 : @topological_add_group.{u_2} M _inst_3 (@add_comm_group.to_add_group.{u_2} M _inst_2),
_inst_5 : @module.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2,
P : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5,
h :
  @Exists.{u_2+1} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
    (λ (U : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5),
       and
         (@is_open.{u_2} M _inst_3
            (@coe.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
               (set.{u_2} M)
               (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                  (set.{u_2} M)
                  (@coe_base.{u_2+1 (max (u_2+1) 1)}
                     (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                     (set.{u_2} M)
                     (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
               U))
         (@has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
            (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
               (@partial_order.to_preorder.{u_2}
                  (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                  (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
            U
            P)),
_let_match :
  @Exists.{u_2+1} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
    (λ (U : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5),
       and
         (@is_open.{u_2} M _inst_3
            (@coe.{u_2+1 (max (u_2+1) 1)}
               (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
               (set.{u_2} M)
               (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
                  (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                  (set.{u_2} M)
                  (@coe_base.{u_2+1 (max (u_2+1) 1)}
                     (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                     (set.{u_2} M)
                     (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
               U))
         (@has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
            (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
               (@partial_order.to_preorder.{u_2}
                  (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
                  (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
            U
            P)) →
  @is_open.{u_2} M _inst_3
    (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
       (set.{u_2} M)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
          (set.{u_2} M)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
             (set.{u_2} M)
             (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
       P),
U : @submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5,
h₁ :
  @is_open.{u_2} M _inst_3
    (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
       (set.{u_2} M)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
          (set.{u_2} M)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
             (set.{u_2} M)
             (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
       U),
h₂ :
  @has_le.le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
    (@preorder.to_has_le.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
       (@partial_order.to_preorder.{u_2} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
          (@submodule.partial_order.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
    U
    P
⊢ @is_add_subgroup.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)
    (@coe.{u_2+1 (max (u_2+1) 1)} (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
       (set.{u_2} M)
       (@coe_to_lift.{u_2+1 (max (u_2+1) 1)}
          (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
          (set.{u_2} M)
          (@coe_base.{u_2+1 (max (u_2+1) 1)}
             (@submodule.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)
             (set.{u_2} M)
             (@submodule.has_coe.{u_1 u_2} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5)))
       U)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  end submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  namespace ideal</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  variables {R : Type*} [comm_ring R]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  variables [topological_space R] [topological_ring R]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ring.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : topological_space.{u_1} α] [_inst_2 : ring.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topological ring is a ring where the ring operations are continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  lemma is_open_of_open_subideal {I : ideal R}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 351, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π (α : Type u) [_inst_1 : comm_ring.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    (h : ∃ U : ideal R, is_open (U : set R) ∧ U ≤ I) : is_open (I : set R) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ideal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='U'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 351, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : comm_ring.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ideal.{u_1} R _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ideal.{u_1} R _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ideal.{u_1} R _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ideal.{u_1} R _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  submodule.is_open_of_open_submodule h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='submodule.is_open_of_open_submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R M : Type u_1} [_inst_1 : comm_ring.{u_1} R] [_inst_2 : add_comm_group.{u_1} M] [_inst_3 : topological_space.{u_1} M] [_inst_4 : @topological_add_group.{u_1} M _inst_3 (@add_comm_group.to_add_group.{u_1} M _inst_2)] [_inst_5 : @module.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2] {P : @submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5}, @Exists.{u_1+1} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (λ (U : @submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5), and (@is_open.{u_1} M _inst_3 (@coe.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@coe_to_lift.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@coe_base.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@submodule.has_coe.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U)) (@has_le.le.{u_1} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@preorder.to_has_le.{u_1} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@partial_order.to_preorder.{u_1} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (@submodule.partial_order.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) U P)) → @is_open.{u_1} M _inst_3 (@coe.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@coe_to_lift.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@coe_base.{u_1+1 (max (u_1+1) 1)} (@submodule.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5) (set.{u_1} M) (@submodule.has_coe.{u_1 u_1} R M (@comm_ring.to_ring.{u_1} R _inst_1) _inst_2 _inst_5))) P)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u_1+1} (@ideal.{u_1} R _inst_1) (λ (U : @ideal.{u_1} R _inst_1), and (@is_open.{u_1} R _inst_2 (@coe.{u_1+1 (max (u_1+1) 1)} (@ideal.{u_1} R _inst_1) (set.{u_1} R) (@coe_to_lift.{u_1+1 (max (u_1+1) 1)} (@ideal.{u_1} R _inst_1) (set.{u_1} R) (@coe_base.{u_1+1 (max (u_1+1) 1)} (@ideal.{u_1} R _inst_1) (set.{u_1} R) (@submodule.has_coe.{u_1 u_1} R R (@comm_ring.to_ring.{u_1} R _inst_1) (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)) (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))))) U)) (@has_le.le.{u_1} (@ideal.{u_1} R _inst_1) (@preorder.to_has_le.{u_1} (@ideal.{u_1} R _inst_1) (@partial_order.to_preorder.{u_1} (@ideal.{u_1} R _inst_1) (@submodule.partial_order.{u_1 u_1} R R (@comm_ring.to_ring.{u_1} R _inst_1) (@ring.to_add_comm_group.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1)) (@ring.to_module.{u_1} R (@comm_ring.to_ring.{u_1} R _inst_1))))) U I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  end ideal</code></pre>
</body>