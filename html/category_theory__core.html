<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  The core of a category C is the groupoid whose morphisms are all the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  isomorphisms of C.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import category_theory.groupoid</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/groupoid.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  import category_theory.whiskering</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  universes vâ‚ vâ‚‚ uâ‚ uâ‚‚ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  def core (C : Type uâ‚) := C</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variables {C : Type uâ‚} [ğ’ : category.{vâ‚} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  include ğ’</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  instance core_category : groupoid.{vâ‚} (core C) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  { hom  := Î» X Y : C, X â‰… Y,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    inv  := Î» X Y f, iso.symm f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    id   := Î» X, iso.refl X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    comp := Î» X Y Z f g, iso.trans f g }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  namespace core</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  @[simp] lemma id_hom (X : core C) : iso.hom (ğŸ™ X) = ğŸ™ X := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  @[simp] lemma comp_hom {X Y Z : core C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g).hom = f.hom â‰« g.hom :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  def inclusion : core C â¥¤ C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  { obj := id,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    map := Î» X Y f, f.hom }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  variables {G : Type uâ‚‚} [ğ’¢ : groupoid.{vâ‚‚} G]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  include ğ’¢</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  /-- A functor from a groupoid to a category C factors through the core of C. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  -- Note that this function is not functorial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  -- (consider the two functors from [0] to [1], and the natural transformation between them).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  def functor_to_core (F : G â¥¤ C) : G â¥¤ core C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  { obj := Î» X, F.obj X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    map := Î» X Y f, âŸ¨F.map f, F.map (inv f)âŸ© }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  def forget_functor_to_core : (G â¥¤ core C) â¥¤ (G â¥¤ C) := (whiskering_right _ _ _).obj inclusion</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  end core</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  end category_theory</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
X Y : category_theory.core.{uâ‚} C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
       (@category_theory.category_struct.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
          (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
             (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
          (Î» (X : category_theory.core.{uâ‚} C), @category_theory.iso.refl.{vâ‚ uâ‚} C ğ’ X)
          (Î» (X Y Z : category_theory.core.{uâ‚} C)
           (f :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
               (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
               (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
               Y
               Z), @category_theory.iso.trans.{vâ‚ uâ‚} C ğ’ X Y Z f g)))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
          (@category_theory.category_struct.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
             (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
             (Î» (X : category_theory.core.{uâ‚} C), @category_theory.iso.refl.{vâ‚ uâ‚} C ğ’ X)
             (Î» (X Y Z : category_theory.core.{uâ‚} C)
              (f :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                     (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
                  X
                  Y)
              (g :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                     (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
                  Y
                  Z), @category_theory.iso.trans.{vâ‚ uâ‚} C ğ’ X Y Z f g)))
       X
       Y)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
       (@category_theory.category_struct.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
          (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
             (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
          (Î» (X : category_theory.core.{uâ‚} C), @category_theory.iso.refl.{vâ‚ uâ‚} C ğ’ X)
          (Î» (X Y Z : category_theory.core.{uâ‚} C)
           (f :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
               (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
               X
               Y)
           (g :
             @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
               (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
               Y
               Z), @category_theory.iso.trans.{vâ‚ uâ‚} C ğ’ X Y Z f g))
       X
       X
       Y
       (@category_theory.category_struct.id.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
          (@category_theory.category_struct.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
             (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
             (Î» (X : category_theory.core.{uâ‚} C), @category_theory.iso.refl.{vâ‚ uâ‚} C ğ’ X)
             (Î» (X Y Z : category_theory.core.{uâ‚} C)
              (f :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                     (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
                  X
                  Y)
              (g :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                  (@category_theory.has_hom.mk.{vâ‚ uâ‚} (category_theory.core.{uâ‚} C)
                     (Î» (X Y : C), @category_theory.iso.{vâ‚ uâ‚} C ğ’ X Y))
                  Y
                  Z), @category_theory.iso.trans.{vâ‚ uâ‚} C ğ’ X Y Z f g))
          X)
       f)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
G : Type uâ‚‚,
ğ’¢ : category_theory.groupoid.{vâ‚‚ uâ‚‚} G,
F : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢) C ğ’,
X Y : G,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} G
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} G
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} G
          (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X
          Y
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          Y
          X
          (@category_theory.is_iso.inv.{vâ‚‚ uâ‚‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢) X Y f
             (@category_theory.is_iso.of_groupoid.{vâ‚‚ uâ‚‚} G ğ’¢ X Y f))))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} G (@category_theory.groupoid.to_category.{vâ‚‚ uâ‚‚} G ğ’¢)
          C
          ğ’
          F
          X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font></pre>
</body>