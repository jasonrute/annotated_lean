<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Johannes Hölzl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Linear structures on function with finite support `ι →₀ β`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import data.finsupp data.mv_polynomial linear_algebra.dimension</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  local attribute [instance, priority 100] classical.prop_decidable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='classical.prop_decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π (a : Prop), decidable a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open lattice set linear_map submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  namespace finsupp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  section module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  variables {R : Type*} {M : Type*} {ι : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables [ring R] [add_comm_group M] [module R M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='A module is a generalization of vector spaces to a scalar ring.
 It consists of a scalar ring `α` and an additive group of &quot;vectors&quot; `β`,
 connected by a &quot;scalar multiplication&quot; operation `r • x : β`
 (where `r : α` and `x : β`) with some natural associativity and
 distributivity axioms similar to those on a ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  lemma linear_independent_single {φ : ι → Type*}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21    {f : Π ι, φ ι → M} (hf : ∀i, linear_independent R (f i)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_independent'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (ι : ι), φ ι → M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='φ i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Linearly independent family of vectors'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    linear_independent R (λ ix : Σ i, φ i, single ix.1 (f ix.1 ix.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_independent'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 78, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_3}, (α → Type u_4) → Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, (α → Type u_4) → Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : has_zero.{u_2} β], α → β → @finsupp.{u_1 u_2} α β _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4}, @sigma.{u_3 u_4} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (ι : ι), φ ι → M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4}, @sigma.{u_3 u_4} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4} (c : @sigma.{u_3 u_4} α β), β (@sigma.fst.{u_3 u_4} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Linearly independent family of vectors'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`single a b` is the finitely supported function which has
 value `b` at `a` and zero otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι M
         (@add_monoid.to_has_zero.{u_2} M
            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    apply @linear_independent_Union_finite R _ _ _ _ ι φ (λ i x, single i (f i x)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='linear_independent_Union_finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finsupp.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 406, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {R : Type u_1} {M : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_3 u_2)} M] [_inst_4 : @module.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2] {η : Type u_3} {ιs : η → Type u_4} {f : Π (j : η), ιs j → M}, (∀ (j : η), @linear_independent.{u_4 u_1 (max u_3 u_2)} (ιs j) R M (f j) _inst_1 _inst_2 _inst_4) → (∀ (i : η) (t : set.{u_3} η), @set.finite.{u_3} η t → not (@has_mem.mem.{u_3 u_3} η (set.{u_3} η) (@set.has_mem.{u_3} η) i t) → @disjoint.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4))) (@submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4 (@set.range.{(max u_3 u_2) u_4+1} M (ιs i) (f i))) (@lattice.supr.{(max u_3 u_2) u_3+1} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) η (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4)) (λ (i : η), @lattice.supr.{(max u_3 u_2) 0} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@has_mem.mem.{u_3 u_3} η (set.{u_3} η) (@set.has_mem.{u_3} η) i t) (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4)) (λ (H : @has_mem.mem.{u_3 u_3} η (set.{u_3} η) (@set.has_mem.{u_3} η) i t), @submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_4 (@set.range.{(max u_3 u_2) u_4+1} M (ιs i) (f i)))))) → @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} η (λ (j : η), ιs j)) R M (λ (ji : @sigma.{u_3 u_4} η (λ (j : η), ιs j)), f (@sigma.fst.{u_3 u_4} η (λ (j : η), ιs j) ji) (@sigma.snd.{u_3 u_4} η (λ (j : η), ιs j) ji)) _inst_1 _inst_2 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2} [_inst_1 : has_zero.{u_2} β], α → β → @finsupp.{u_3 u_2} α β _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (ι : ι), φ ι → M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`single a b` is the finitely supported function which has
 value `b` at `a` and zero otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι M
         (@add_monoid.to_has_zero.{u_2} M
            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (j : ι),
    @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ j) R
      (@finsupp.{u_3 u_2} ι M
         (@add_monoid.to_has_zero.{u_2} M
            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
      ((λ (i : ι) (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x))
         j)
      _inst_1
      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (i : ι) (t : set.{u_3} ι),
    @set.finite.{u_3} ι t →
    not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t) →
    @disjoint.{(max u_3 u_2)}
      (@submodule.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
      (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
      (@submodule.span.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
         (@set.range.{(max u_3 u_2) u_4+1}
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            (φ i)
            ((λ (i : ι) (x : φ i),
                @finsupp.single.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                  i
                  (f i x))
               i)))
      (@lattice.supr.{(max u_3 u_2) u_3+1}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         ι
         (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
         (λ (i : ι),
            @lattice.supr.{(max u_3 u_2) 0}
              (@submodule.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
              (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
              (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                 (@submodule.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                 (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
              (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
                 @submodule.span.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                   (@set.range.{(max u_3 u_2) u_4+1}
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      (φ i)
                      ((λ (i : ι) (x : φ i),
                          @finsupp.single.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                            i
                            (f i x))
                         i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    { assume i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (j : ι),
    @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ j) R
      (@finsupp.{u_3 u_2} ι M
         (@add_monoid.to_has_zero.{u_2} M
            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
      ((λ (i : ι) (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x))
         j)
      _inst_1
      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (i : ι) (t : set.{u_3} ι),
    @set.finite.{u_3} ι t →
    not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t) →
    @disjoint.{(max u_3 u_2)}
      (@submodule.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
      (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
      (@submodule.span.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
         (@set.range.{(max u_3 u_2) u_4+1}
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            (φ i)
            ((λ (i : ι) (x : φ i),
                @finsupp.single.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                  i
                  (f i x))
               i)))
      (@lattice.supr.{(max u_3 u_2) u_3+1}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         ι
         (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
         (λ (i : ι),
            @lattice.supr.{(max u_3 u_2) 0}
              (@submodule.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
              (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
              (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                 (@submodule.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                 (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
              (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
                 @submodule.span.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                   (@set.range.{(max u_3 u_2) u_4+1}
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      (φ i)
                      ((λ (i : ι) (x : φ i),
                          @finsupp.single.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                            i
                            (f i x))
                         i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (j : ι),
    @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ j) R
      (@finsupp.{u_3 u_2} ι M
         (@add_monoid.to_has_zero.{u_2} M
            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
      ((λ (i : ι) (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x))
         j)
      _inst_1
      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      have h_disjoint : disjoint (span R (range (f i))) (ker (lsingle i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='submodule.span'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.lsingle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : lattice.semilattice_inf_bot.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u_1) {M : Type u_2} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_5 : @module.{u_1 u_2} R M _inst_1 _inst_2], set.{u_2} M → @submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_4}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (ι : ι), φ ι → M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u_1} {M : Type u_2} {M₂ : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : add_comm_group.{(max u_3 u_2)} M₂] [_inst_5 : @module.{u_1 u_2} R M _inst_1 _inst_2] [_inst_6 : @module.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3], @linear_map.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {M : Type u_2} {R : Type u_1} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2], α → @linear_map.{u_1 u_2 (max u_3 u_2)} R M (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) _inst_3 (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The span of a set `s ⊆ M` is the smallest submodule of M that contains `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
h_disjoint :
  @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27      { rw ker_lsingle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finsupp.ker_lsingle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} {M : Type u_2} {R : Type u_1} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2] (a : α), @eq.{u_2+1} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) _inst_3 (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3 a)) (@lattice.has_bot.bot.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@submodule.lattice.has_bot.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
h_disjoint :
  @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@lattice.has_bot.bot.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@submodule.lattice.has_bot.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28        exact disjoint_bot_right },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='disjoint_bot_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 773, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : lattice.semilattice_inf_bot.{u_2} α] {a : α}, @disjoint.{u_2} α _inst_1 a (@lattice.has_bot.bot.{u_2} α (@lattice.order_bot.to_has_bot.{u_2} α (@lattice.semilattice_inf_bot.to_order_bot.{u_2} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι
⊢ @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@lattice.has_bot.bot.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@submodule.lattice.has_bot.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
h_disjoint :
  @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29      apply linear_independent.image (hf i) h_disjoint },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='linear_independent.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 562, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_4} {R : Type u_1} {M : Type u_2} {M&#x27; : Type (max u_3 u_2)} {v : ι → M} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : add_comm_group.{(max u_3 u_2)} M&#x27;] [_inst_4 : @module.{u_1 u_2} R M _inst_1 _inst_2] [_inst_5 : @module.{u_1 (max u_3 u_2)} R M&#x27; _inst_1 _inst_3], @linear_independent.{u_4 u_1 u_2} ι R M v _inst_1 _inst_2 _inst_4 → ∀ {f : @linear_map.{u_1 u_2 (max u_3 u_2)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5}, @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_4) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_4) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_4) (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_4))) (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_4 (@set.range.{u_2 u_4+1} M ι v)) (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 f) → @linear_independent.{u_4 u_1 (max u_3 u_2)} ι R M&#x27; (@function.comp.{u_4+1 u_2+1 (max u_3 u_2)+1} ι M M&#x27; (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))} (@linear_map.{u_1 u_2 (max u_3 u_2)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M M&#x27; _inst_1 _inst_2 _inst_3 _inst_4 _inst_5) f) v) _inst_1 _inst_3 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3) (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3))) (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i))) (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M (@finsupp.{u_3 u_2} ι M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2) _inst_3 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
h_disjoint :
  @disjoint.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
       (@lattice.complete_lattice.to_bounded_lattice.{u_2} (@submodule.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)
          (@submodule.lattice.complete_lattice.{u_1 u_2} R M _inst_1 _inst_2 _inst_3)))
    (@submodule.span.{u_1 u_2} R M _inst_1 _inst_2 _inst_3 (@set.range.{u_2 u_4+1} M (φ i) (f i)))
    (@linear_map.ker.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))
⊢ @linear_independent.{u_4 u_1 (max u_3 u_2)} (φ i) R
    (@finsupp.{u_3 u_2} ι M
       (@add_monoid.to_has_zero.{u_2} M
          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
    ((λ (i : ι) (x : φ i),
        @finsupp.single.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
          i
          (f i x))
       i)
    _inst_1
    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (i : ι) (t : set.{u_3} ι),
    @set.finite.{u_3} ι t →
    not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t) →
    @disjoint.{(max u_3 u_2)}
      (@submodule.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
      (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
      (@submodule.span.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
         (@set.range.{(max u_3 u_2) u_4+1}
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            (φ i)
            ((λ (i : ι) (x : φ i),
                @finsupp.single.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                  i
                  (f i x))
               i)))
      (@lattice.supr.{(max u_3 u_2) u_3+1}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         ι
         (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
         (λ (i : ι),
            @lattice.supr.{(max u_3 u_2) 0}
              (@submodule.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
              (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
              (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                 (@submodule.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                 (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
              (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
                 @submodule.span.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                   (@set.range.{(max u_3 u_2) u_4+1}
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      (φ i)
                      ((λ (i : ι) (x : φ i),
                          @finsupp.single.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                            i
                            (f i x))
                         i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    { intros i t ht hit,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3
⊢ ∀ (i : ι) (t : set.{u_3} ι),
    @set.finite.{u_3} ι t →
    not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t) →
    @disjoint.{(max u_3 u_2)}
      (@submodule.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
      (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
      (@submodule.span.{u_1 (max u_3 u_2)} R
         (@finsupp.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
         _inst_1
         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
         (@set.range.{(max u_3 u_2) u_4+1}
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            (φ i)
            ((λ (i : ι) (x : φ i),
                @finsupp.single.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                  i
                  (f i x))
               i)))
      (@lattice.supr.{(max u_3 u_2) u_3+1}
         (@submodule.{u_1 (max u_3 u_2)} R
            (@finsupp.{u_3 u_2} ι M
               (@add_monoid.to_has_zero.{u_2} M
                  (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
            _inst_1
            (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
            (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
         ι
         (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
         (λ (i : ι),
            @lattice.supr.{(max u_3 u_2) 0}
              (@submodule.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
              (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
              (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                 (@submodule.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                 (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
              (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
                 @submodule.span.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                   (@set.range.{(max u_3 u_2) u_4+1}
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      (φ i)
                      ((λ (i : ι) (x : φ i),
                          @finsupp.single.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                            i
                            (f i x))
                         i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @disjoint.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      apply disjoint_mono _ _ (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='disjoint_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finsupp.disjoint_lsingle_lsingle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.disjoint_singleton_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 775, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 810, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_3 u_2)} [_inst_1 : lattice.semilattice_inf_bot.{(max u_3 u_2)} α] {a b c d : α}, @has_le.le.{(max u_3 u_2)} α (@preorder.to_has_le.{(max u_3 u_2)} α (@partial_order.to_preorder.{(max u_3 u_2)} α (@lattice.order_bot.to_partial_order.{(max u_3 u_2)} α (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)} α _inst_1)))) a b → @has_le.le.{(max u_3 u_2)} α (@preorder.to_has_le.{(max u_3 u_2)} α (@partial_order.to_preorder.{(max u_3 u_2)} α (@lattice.order_bot.to_partial_order.{(max u_3 u_2)} α (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)} α _inst_1)))) c d → @disjoint.{(max u_3 u_2)} α _inst_1 b d → @disjoint.{(max u_3 u_2)} α _inst_1 a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} {M : Type u_2} {R : Type u_1} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2] (s t : set.{u_3} α), @disjoint.{u_3} (set.{u_3} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_3} (set.{u_3} α) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} α) (@set.lattice_set.{u_3} α))) s t → @disjoint.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)))) (@lattice.supr.{(max u_3 u_2) u_3+1} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) α (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3))) (λ (a : α), @lattice.supr.{(max u_3 u_2) 0} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a s) (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3))) (λ (H : @has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a s), @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) _inst_3 (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3 a)))) (@lattice.supr.{(max u_3 u_2) u_3+1} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) α (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3))) (λ (a : α), @lattice.supr.{(max u_3 u_2) 0} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a t) (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3))) (λ (H : @has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a t), @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M (@finsupp.{u_3 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{u_3 u_2} α M _inst_2) _inst_3 (@finsupp.module.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{u_3 u_2 u_1} α M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_3} [_inst_1 : has_emptyc.{u_3} γ] [_inst_2 : has_insert.{u_3 u_3} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} {a : α} {s : set.{u_3} α}, iff (@disjoint.{u_3} (set.{u_3} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u_3} (set.{u_3} α) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} α) (@set.lattice_set.{u_3} α))) (@singleton.{u_3 u_3} α (set.{u_3} α) (@set.has_emptyc.{u_3} α) (@set.has_insert.{u_3} α) a) s) (not (@has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @disjoint.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
               (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i))
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ
             (H :
               @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                 (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i)),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      { rw span_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='submodule.span_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 568, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_3 u_2)} M] [_inst_5 : @module.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2] {s : set.{(max u_3 u_2)} M} {p : @submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5}, iff (@has_le.le.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@preorder.to_has_le.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@partial_order.to_preorder.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@submodule.partial_order.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5))) (@submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5 s) p) (@has_subset.subset.{(max u_3 u_2)} (set.{(max u_3 u_2)} M) (@set.has_subset.{(max u_3 u_2)} M) s (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@submodule.has_coe.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
               (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i))
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ
             (H :
               @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                 (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i)),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))

R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
               (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i))
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ
             (H :
               @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                 (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i)),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@lattice.supr.{(max u_3 u_2) u_3+1}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          ι
          (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
          (λ (a : ι),
             @lattice.supr.{(max u_3 u_2) 0}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                  (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i))
               (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                  (@submodule.{u_1 (max u_3 u_2)} R
                     (@finsupp.{u_3 u_2} ι M
                        (@add_monoid.to_has_zero.{u_2} M
                           (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                     _inst_1
                     (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                     (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                  (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                     (@finsupp.{u_3 u_2} ι M
                        (@add_monoid.to_has_zero.{u_2} M
                           (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                     _inst_1
                     (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                     (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
               (λ
                (H :
                  @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                    (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i)),
                  @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    _inst_2
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    _inst_3
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                    (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33        simp only [supr_singleton],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='lattice.supr_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 610, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : lattice.complete_lattice.{?l_1} α] {f : β → α} {b : β}, @eq.{?l_1+1} α (@lattice.supr.{?l_1 ?l_2+1} α β (@lattice.complete_lattice.to_has_Sup.{?l_1} α _inst_1) (λ (x : β), @lattice.supr.{?l_1 0} α (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) x (@singleton.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_emptyc.{?l_2} β) (@set.has_insert.{?l_2} β) b)) (@lattice.complete_lattice.to_has_Sup.{?l_1} α _inst_1) (λ (H : @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) x (@singleton.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_emptyc.{?l_2} β) (@set.has_insert.{?l_2} β) b)), f x))) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@lattice.supr.{(max u_3 u_2) u_3+1}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          ι
          (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
          (λ (a : ι),
             @lattice.supr.{(max u_3 u_2) 0}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                  (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i))
               (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
                  (@submodule.{u_1 (max u_3 u_2)} R
                     (@finsupp.{u_3 u_2} ι M
                        (@add_monoid.to_has_zero.{u_2} M
                           (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                     _inst_1
                     (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                     (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                  (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                     (@finsupp.{u_3 u_2} ι M
                        (@add_monoid.to_has_zero.{u_2} M
                           (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                     _inst_1
                     (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                     (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
               (λ
                (H :
                  @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a
                    (@singleton.{u_3 u_3} ι (set.{u_3} ι) (@set.has_emptyc.{u_3} ι) (@set.has_insert.{u_3} ι) i)),
                  @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    _inst_1
                    _inst_2
                    (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                    _inst_3
                    (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                    (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       (λ (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x)))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          _inst_2
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          _inst_3
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34        rw range_coe,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='linear_map.range_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 887, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type u_2} {M₂ : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : add_comm_group.{(max u_3 u_2)} M₂] [_inst_5 : @module.{u_1 u_2} R M _inst_1 _inst_2] [_inst_6 : @module.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3] (f : @linear_map.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6), @eq.{(max ((max u_3 u_2)+1) 1)} (set.{(max u_3 u_2)} M₂) (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@submodule.has_coe.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6))) (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f)) (@set.range.{(max u_3 u_2) u_2+1} M₂ M (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))} (@linear_map.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       (λ (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x)))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          _inst_2
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          _inst_3
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       (λ (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x)))
    (@set.range.{(max u_3 u_2) u_2+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       M
       (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))}
          (@linear_map.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35        apply range_comp_subset_range },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.range_comp_subset_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1227, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {γ : Type (max u_3 u_2)} (f : α → β) (g : β → γ), @has_subset.subset.{(max u_3 u_2)} (set.{(max u_3 u_2)} γ) (@set.has_subset.{(max u_3 u_2)} γ) (@set.range.{(max u_3 u_2) u_4+1} γ α (@function.comp.{u_4+1 u_2+1 (max u_3 u_2)+1} α β γ g f)) (@set.range.{(max u_3 u_2) u_2+1} γ β g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       (λ (x : φ i),
          @finsupp.single.{u_3 u_2} ι M
            (@add_monoid.to_has_zero.{u_2} M
               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
            i
            (f i x)))
    (@set.range.{(max u_3 u_2) u_2+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       M
       (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))}
          (@linear_map.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      { refine supr_le_supr (λ i, supr_le_supr _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='lattice.supr_le_supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 257, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_3 u_2)} {ι : Type u_3} [_inst_1 : lattice.complete_lattice.{(max u_3 u_2)} α] {s t : ι → α}, (∀ (i : ι), @has_le.le.{(max u_3 u_2)} α (@preorder.to_has_le.{(max u_3 u_2)} α (@partial_order.to_preorder.{(max u_3 u_2)} α (@lattice.order_bot.to_partial_order.{(max u_3 u_2)} α (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)} α (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)} α _inst_1))))) (s i) (t i)) → @has_le.le.{(max u_3 u_2)} α (@preorder.to_has_le.{(max u_3 u_2)} α (@partial_order.to_preorder.{(max u_3 u_2)} α (@lattice.order_bot.to_partial_order.{(max u_3 u_2)} α (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)} α (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)} α _inst_1))))) (@lattice.supr.{(max u_3 u_2) u_3+1} α ι (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} α _inst_1) s) (@lattice.supr.{(max u_3 u_2) u_3+1} α ι (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} α _inst_1) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.semilattice_inf_bot.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.semilattice_inf_bot_of_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                      (@submodule.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                      (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                         (@finsupp.{u_3 u_2} ι M
                            (@add_monoid.to_has_zero.{u_2} M
                               (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                         _inst_1
                         (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                         (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
               @submodule.span.{u_1 (max u_3 u_2)} R
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@set.range.{(max u_3 u_2) u_4+1}
                    (@finsupp.{u_3 u_2} ι M
                       (@add_monoid.to_has_zero.{u_2} M
                          (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                    (φ i)
                    ((λ (i : ι) (x : φ i),
                        @finsupp.single.{u_3 u_2} ι M
                          (@add_monoid.to_has_zero.{u_2} M
                             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                          i
                          (f i x))
                       i)))))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
       (λ (a : ι),
          @lattice.supr.{(max u_3 u_2) 0}
            (@submodule.{u_1 (max u_3 u_2)} R
               (@finsupp.{u_3 u_2} ι M
                  (@add_monoid.to_has_zero.{u_2} M
                     (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
               _inst_1
               (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
               (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
            (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t)
            (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
               (@submodule.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
               (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                  (@finsupp.{u_3 u_2} ι M
                     (@add_monoid.to_has_zero.{u_2} M
                        (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                  _inst_1
                  (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                  (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))
            (λ (H : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) a t),
               @linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
                 (@finsupp.{u_3 u_2} ι M
                    (@add_monoid.to_has_zero.{u_2} M
                       (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                 _inst_1
                 _inst_2
                 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                 _inst_3
                 (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
                 (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι
⊢ @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t →
  @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37        intros hi,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι
⊢ @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t →
  @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38        rw span_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='submodule.span_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 568, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_3 u_2)} M] [_inst_5 : @module.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2] {s : set.{(max u_3 u_2)} M} {p : @submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5}, iff (@has_le.le.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@preorder.to_has_le.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@partial_order.to_preorder.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@submodule.partial_order.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5))) (@submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5 s) p) (@has_subset.subset.{(max u_3 u_2)} (set.{(max u_3 u_2)} M) (@set.has_subset.{(max u_3 u_2)} M) s (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (set.{(max u_3 u_2)} M) (@submodule.has_coe.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5))) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_le.le.{(max u_3 u_2)}
    (@submodule.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
    (@preorder.to_has_le.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (@partial_order.to_preorder.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@lattice.order_bot.to_partial_order.{(max u_3 u_2)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (@lattice.bounded_lattice.to_order_bot.{(max u_3 u_2)}
                (@submodule.{u_1 (max u_3 u_2)} R
                   (@finsupp.{u_3 u_2} ι M
                      (@add_monoid.to_has_zero.{u_2} M
                         (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                   _inst_1
                   (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                   (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                (@lattice.complete_lattice.to_bounded_lattice.{(max u_3 u_2)}
                   (@submodule.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
                   (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R
                      (@finsupp.{u_3 u_2} ι M
                         (@add_monoid.to_has_zero.{u_2} M
                            (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                      _inst_1
                      (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                      (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)))))))
    (@submodule.span.{u_1 (max u_3 u_2)} R
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) u_4+1}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          (φ i)
          ((λ (i : ι) (x : φ i),
              @finsupp.single.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
                i
                (f i x))
             i)))
    (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       _inst_1
       _inst_2
       (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
       _inst_3
       (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
       (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          _inst_2
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          _inst_3
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39        rw range_coe,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='linear_map.range_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 887, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type u_2} {M₂ : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : add_comm_group.{(max u_3 u_2)} M₂] [_inst_5 : @module.{u_1 u_2} R M _inst_1 _inst_2] [_inst_6 : @module.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3] (f : @linear_map.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6), @eq.{(max ((max u_3 u_2)+1) 1)} (set.{(max u_3 u_2)} M₂) (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)} (@submodule.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6) (set.{(max u_3 u_2)} M₂) (@submodule.has_coe.{u_1 (max u_3 u_2)} R M₂ _inst_1 _inst_3 _inst_6))) (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f)) (@set.range.{(max u_3 u_2) u_2+1} M₂ M (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))} (@linear_map.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@coe.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
       (@submodule.{u_1 (max u_3 u_2)} R
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
       (set.{(max u_3 u_2)}
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
       (@coe_to_lift.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
          (@submodule.{u_1 (max u_3 u_2)} R
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (set.{(max u_3 u_2)}
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
          (@coe_base.{(max u_3 u_2)+1 (max ((max u_3 u_2)+1) 1)}
             (@submodule.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
             (set.{(max u_3 u_2)}
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
             (@submodule.has_coe.{u_1 (max u_3 u_2)} R
                (@finsupp.{u_3 u_2} ι M
                   (@add_monoid.to_has_zero.{u_2} M
                      (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
                _inst_1
                (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
                (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))))
       (@linear_map.range.{u_1 u_2 (max u_3 u_2)} R M
          (@finsupp.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
          _inst_1
          _inst_2
          (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
          _inst_3
          (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@set.range.{(max u_3 u_2) u_2+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       M
       (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))}
          (@linear_map.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40        apply range_comp_subset_range } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.range_comp_subset_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1227, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {γ : Type (max u_3 u_2)} (f : α → β) (g : β → γ), @has_subset.subset.{(max u_3 u_2)} (set.{(max u_3 u_2)} γ) (@set.has_subset.{(max u_3 u_2)} γ) (@set.range.{(max u_3 u_2) u_4+1} γ α (@function.comp.{u_4+1 u_2+1 (max u_3 u_2)+1} α β γ g f)) (@set.range.{(max u_3 u_2) u_2+1} γ β g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='R : Type u_1,
M : Type u_2,
ι : Type u_3,
_inst_1 : ring.{u_1} R,
_inst_2 : add_comm_group.{u_2} M,
_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → M,
hf : ∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3,
i : ι,
t : set.{u_3} ι,
ht : @set.finite.{u_3} ι t,
hit : not (@has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t),
i : ι,
hi : @has_mem.mem.{u_3 u_3} ι (set.{u_3} ι) (@set.has_mem.{u_3} ι) i t
⊢ @has_subset.subset.{(max u_3 u_2)}
    (set.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.has_subset.{(max u_3 u_2)}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))))
    (@set.range.{(max u_3 u_2) u_4+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       (φ i)
       ((λ (i : ι) (x : φ i),
           @finsupp.single.{u_3 u_2} ι M
             (@add_monoid.to_has_zero.{u_2} M
                (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))
             i
             (f i x))
          i))
    (@set.range.{(max u_3 u_2) u_2+1}
       (@finsupp.{u_3 u_2} ι M
          (@add_monoid.to_has_zero.{u_2} M
             (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
       M
       (@coe_fn.{(max (u_2+1) ((max u_3 u_2)+1)) (max (u_2+1) ((max u_3 u_2)+1))}
          (@linear_map.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@linear_map.has_coe_to_fun.{u_1 u_2 (max u_3 u_2)} R M
             (@finsupp.{u_3 u_2} ι M
                (@add_monoid.to_has_zero.{u_2} M
                   (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))))
             _inst_1
             _inst_2
             (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2)
             _inst_3
             (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3))
          (@finsupp.lsingle.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  end module</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  section vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  variables {K : Type*} {V : Type*} {ι : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : discrete_field.{u_1} α] [_inst_2 : add_comm_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  open linear_map submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  lemma is_basis_single {φ : ι → Type*} (f : Π ι, φ ι → V)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='ι → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    (hf : ∀i, is_basis K (f i)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (ι : ι), φ ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    is_basis K (λ ix : Σ i, φ i, single ix.1 (f ix.1 ix.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_3}, (α → Type u_4) → Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, (α → Type u_4) → Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : has_zero.{u_2} β], α → β → @finsupp.{u_1 u_2} α β _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4}, @sigma.{u_3 u_4} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (ι : ι), φ ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4}, @sigma.{u_3 u_4} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@sigma.{u_3 u_4} ι (λ (i : ι), φ i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : α → Type u_4} (c : @sigma.{u_3 u_4} α β), β (@sigma.fst.{u_3 u_4} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`single a b` is the finitely supported function which has
 value `b` at `a` and zero otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @is_basis.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) K
    (@finsupp.{u_3 u_2} ι V
       (@add_monoid.to_has_zero.{u_2} V
          (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι V
         (@add_monoid.to_has_zero.{u_2} V
            (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    (@domain.to_ring.{u_1} K
       (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
    (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
    (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @is_basis.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) K
    (@finsupp.{u_3 u_2} ι V
       (@add_monoid.to_has_zero.{u_2} V
          (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι V
         (@add_monoid.to_has_zero.{u_2} V
            (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    (@domain.to_ring.{u_1} K
       (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
    (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
    (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) K
    (@finsupp.{u_3 u_2} ι V
       (@add_monoid.to_has_zero.{u_2} V
          (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι V
         (@add_monoid.to_has_zero.{u_2} V
            (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    (@domain.to_ring.{u_1} K
       (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
    (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
    (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)

K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@submodule.span.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) (max u_3 u_4)+1}
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@sigma.{u_3 u_4} ι (λ (i : ι), φ i))
          (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
             @finsupp.single.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
               (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
               (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    { apply linear_independent_single,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finsupp.linear_independent_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type u_2} {ι : Type u_3} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_1 u_2} R M _inst_1 _inst_2] {φ : ι → Type u_4} {f : Π (ι : ι), φ ι → M}, (∀ (i : ι), @linear_independent.{u_4 u_1 u_2} (φ i) R M (f i) _inst_1 _inst_2 _inst_3) → @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) R (@finsupp.{u_3 u_2} ι M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)), @finsupp.single.{u_3 u_2} ι M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2))) (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix))) _inst_1 (@finsupp.add_comm_group.{u_3 u_2} ι M _inst_2) (@finsupp.module.{u_3 u_2 u_1} ι M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) K
    (@finsupp.{u_3 u_2} ι V
       (@add_monoid.to_has_zero.{u_2} V
          (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι V
         (@add_monoid.to_has_zero.{u_2} V
            (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    (@domain.to_ring.{u_1} K
       (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
    (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
    (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)

K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@submodule.span.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) (max u_3 u_4)+1}
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@sigma.{u_3 u_4} ι (λ (i : ι), φ i))
          (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
             @finsupp.single.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
               (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
               (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @linear_independent.{(max u_3 u_4) u_1 (max u_3 u_2)} (@sigma.{u_3 u_4} ι (λ (i : ι), φ i)) K
    (@finsupp.{u_3 u_2} ι V
       (@add_monoid.to_has_zero.{u_2} V
          (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
    (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
       @finsupp.single.{u_3 u_2} ι V
         (@add_monoid.to_has_zero.{u_2} V
            (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
         (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
         (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))
    (@domain.to_ring.{u_1} K
       (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
    (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
    (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ ∀ (i : ι),
    @linear_independent.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      exact λ i, (hf i).1 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @is_basis.{u_4 u_1 u_2} (φ i) K V (f i) (@domain.to_ring.{u_1} K (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ ∀ (i : ι),
    @linear_independent.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@submodule.span.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) (max u_3 u_4)+1}
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@sigma.{u_3 u_4} ι (λ (i : ι), φ i))
          (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
             @finsupp.single.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
               (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
               (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    { rw [range_sigma_eq_Union_range, span_Union],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.range_sigma_eq_Union_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='submodule.span_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 435, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 610, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} {β : Type (max u_3 u_2)} {γ : α → Type u_4} (f : @sigma.{u_3 u_4} α γ → β), @eq.{(max ((max u_3 u_2)+1) 1)} (set.{(max u_3 u_2)} β) (@set.range.{(max u_3 u_2) (max (u_3+1) (u_4+1))} β (@sigma.{u_3 u_4} α γ) f) (@set.Union.{(max u_3 u_2) u_3+1} β α (λ (a : α), @set.range.{(max u_3 u_2) u_4+1} β (γ a) (λ (b : γ a), f (@sigma.mk.{u_3 u_4} α γ a b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M : Type (max u_3 u_2)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_3 u_2)} M] [_inst_5 : @module.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2] {ι : Type u_3} (s : ι → set.{(max u_3 u_2)} M), @eq.{(max u_3 u_2)+1} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5 (@set.Union.{(max u_3 u_2) u_3+1} M ι (λ (i : ι), s i))) (@lattice.supr.{(max u_3 u_2) u_3+1} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) ι (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)} (@submodule.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5)) (λ (i : ι), @submodule.span.{u_1 (max u_3 u_2)} R M _inst_1 _inst_2 _inst_5 (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@submodule.span.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
       (@set.range.{(max u_3 u_2) (max u_3 u_4)+1}
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@sigma.{u_3 u_4} ι (λ (i : ι), φ i))
          (λ (ix : @sigma.{u_3 u_4} ι (λ (i : ι), φ i)),
             @finsupp.single.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
               (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix)
               (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i) ix)))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@submodule.span.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
       (@set.Union.{(max u_3 u_2) u_3+1}
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          ι
          (λ (a : ι),
             @set.range.{(max u_3 u_2) u_4+1}
               (@finsupp.{u_3 u_2} ι V
                  (@add_monoid.to_has_zero.{u_2} V
                     (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
               (φ a)
               (λ (b : φ a),
                  @finsupp.single.{u_3 u_2} ι V
                    (@add_monoid.to_has_zero.{u_2} V
                       (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
                    (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) a b))
                    (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) a b))
                       (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i)
                          (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) a b)))))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @submodule.span.{u_1 (max u_3 u_2)} K
            (@finsupp.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
            (@domain.to_ring.{u_1} K
               (@division_ring.to_domain.{u_1} K
                  (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
            (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
            (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
            (@set.range.{(max u_3 u_2) u_4+1}
               (@finsupp.{u_3 u_2} ι V
                  (@add_monoid.to_has_zero.{u_2} V
                     (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
               (φ i)
               (λ (b : φ i),
                  @finsupp.single.{u_3 u_2} ι V
                    (@add_monoid.to_has_zero.{u_2} V
                       (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
                    (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b))
                    (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b))
                       (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i)
                          (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b)))))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      simp only [image_univ.symm, λ i, image_comp (single i) (f i), span_single_image],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='set.image_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finsupp.span_single_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (?l_1+1) 1)} (set.{?l_1} ?m_2) (@set.range.{?l_1 ?l_3+1} ?m_2 ?m_4 ?m_5) (@set.image.{?l_3 ?l_1} ?m_4 ?m_2 ?m_5 (@set.univ.{?l_3} ?m_4))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} {γ : Type (max u_3 u_2)} (f : β → γ) (g : α → β) (a : set.{u_4} α), @eq.{(max ((max u_3 u_2)+1) 1)} (set.{(max u_3 u_2)} γ) (@set.image.{u_4 (max u_3 u_2)} α γ (@function.comp.{u_4+1 u_2+1 (max u_3 u_2)+1} α β γ f g) a) (@set.image.{u_2 (max u_3 u_2)} β γ f (@set.image.{u_4 u_2} α β g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2} [_inst_1 : has_zero.{u_2} β], α → β → @finsupp.{u_3 u_2} α β _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (ι : ι), φ ι → V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {M : Type ?l_2} {R : Type ?l_3} [_inst_1 : ring.{?l_3} R] [_inst_2 : add_comm_group.{?l_2} M] [_inst_3 : @module.{?l_3 ?l_2} R M _inst_1 _inst_2] (s : set.{?l_2} M) (a : α), @eq.{(max ?l_1 ?l_2)+1} (@submodule.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)) (@submodule.span.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3) (@set.image.{?l_2 (max ?l_1 ?l_2)} M (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) (@finsupp.single.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2))) a) s)) (@submodule.map.{?l_3 ?l_2 (max ?l_1 ?l_2)} R M (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) _inst_3 (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3 a) (@submodule.span.{?l_3 ?l_2} R M _inst_1 _inst_2 _inst_3 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`single a b` is the finitely supported function which has
 value `b` at `a` and zero otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @submodule.span.{u_1 (max u_3 u_2)} K
            (@finsupp.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
            (@domain.to_ring.{u_1} K
               (@division_ring.to_domain.{u_1} K
                  (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
            (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
            (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
            (@set.range.{(max u_3 u_2) u_4+1}
               (@finsupp.{u_3 u_2} ι V
                  (@add_monoid.to_has_zero.{u_2} V
                     (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
               (φ i)
               (λ (b : φ i),
                  @finsupp.single.{u_3 u_2} ι V
                    (@add_monoid.to_has_zero.{u_2} V
                       (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2)))
                    (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b))
                    (f (@sigma.fst.{u_3 u_4} ι (λ (i : ι), φ i) (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b))
                       (@sigma.snd.{u_3 u_4} ι (λ (i : ι), φ i)
                          (@sigma.mk.{u_3 u_4} ι (λ (i : ι), φ i) i b)))))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @submodule.map.{u_1 u_2 (max u_3 u_2)} K V
            (@finsupp.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
            (@domain.to_ring.{u_1} K
               (@division_ring.to_domain.{u_1} K
                  (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
            _inst_2
            (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
            _inst_3
            (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
            (@finsupp.lsingle.{u_3 u_2 u_1} ι V K
               (@domain.to_ring.{u_1} K
                  (@division_ring.to_domain.{u_1} K
                     (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
               _inst_2
               _inst_3
               i)
            (@submodule.span.{u_1 u_2} K V
               (@domain.to_ring.{u_1} K
                  (@division_ring.to_domain.{u_1} K
                     (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
               _inst_2
               _inst_3
               (@set.image.{u_4 u_2} (φ i) V (f i) (@set.univ.{u_4} (φ i))))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60      simp only [image_univ, (hf _).2, map_top, supr_lsingle_range] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.image_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='submodule.map_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.supr_lsingle_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1213, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type ?l_1} {ι : Type ?l_2} {f : ι → β}, @eq.{(max (?l_1+1) 1)} (set.{?l_1} β) (@set.image.{?l_2 ?l_1} ι β f (@set.univ.{?l_2} ι)) (@set.range.{?l_1 ?l_2+1} β ι f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : ι), @is_basis.{u_4 u_1 u_2} (φ i) K V (f i) (@domain.to_ring.{u_1} K (@division_ring.to_domain.{u_1} K (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type ?l_1} {M : Type ?l_2} {M₂ : Type ?l_3} {T : ring.{?l_1} R} [_inst_1 : add_comm_group.{?l_2} M] [_inst_2 : add_comm_group.{?l_3} M₂] [_inst_3 : @module.{?l_1 ?l_2} R M T _inst_1] [_inst_4 : @module.{?l_1 ?l_3} R M₂ T _inst_2] (f : @linear_map.{?l_1 ?l_2 ?l_3} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4), @eq.{?l_3+1} (@submodule.{?l_1 ?l_3} R M₂ T _inst_2 _inst_4) (@submodule.map.{?l_1 ?l_2 ?l_3} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4 f (@lattice.has_top.top.{?l_2} (@submodule.{?l_1 ?l_2} R M T _inst_1 _inst_3) (@submodule.lattice.has_top.{?l_1 ?l_2} R M T _inst_1 _inst_3))) (@linear_map.range.{?l_1 ?l_2 ?l_3} R M M₂ T _inst_1 _inst_2 _inst_3 _inst_4 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {M : Type ?l_2} {R : Type ?l_3} [_inst_1 : ring.{?l_3} R] [_inst_2 : add_comm_group.{?l_2} M] [_inst_3 : @module.{?l_3 ?l_2} R M _inst_1 _inst_2], @eq.{(max ?l_1 ?l_2)+1} (@submodule.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)) (@lattice.supr.{(max ?l_1 ?l_2) ?l_1+1} (@submodule.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)) α (@lattice.complete_lattice.to_has_Sup.{(max ?l_1 ?l_2)} (@submodule.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.complete_lattice.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3))) (λ (a : α), @linear_map.range.{?l_3 ?l_2 (max ?l_1 ?l_2)} R M (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) _inst_3 (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3) (@finsupp.lsingle.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3 a))) (@lattice.has_top.top.{(max ?l_1 ?l_2)} (@submodule.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)) (@submodule.lattice.has_top.{?l_3 (max ?l_1 ?l_2)} R (@finsupp.{?l_1 ?l_2} α M (@add_monoid.to_has_zero.{?l_2} M (@add_group.to_add_monoid.{?l_2} M (@add_comm_group.to_add_group.{?l_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{?l_1 ?l_2} α M _inst_2) (@finsupp.module.{?l_1 ?l_2 ?l_3} α M R _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u_1,
V : Type u_2,
ι : Type u_3,
_inst_1 : discrete_field.{u_1} K,
_inst_2 : add_comm_group.{u_2} V,
_inst_3 : @vector_space.{u_1 u_2} K V _inst_1 _inst_2,
φ : ι → Type u_4,
f : Π (ι : ι), φ ι → V,
hf :
  ∀ (i : ι),
    @is_basis.{u_4 u_1 u_2} (φ i) K V (f i)
      (@domain.to_ring.{u_1} K
         (@division_ring.to_domain.{u_1} K
            (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
      _inst_2
      _inst_3
⊢ @eq.{(max u_3 u_2)+1}
    (@submodule.{u_1 (max u_3 u_2)} K
       (@finsupp.{u_3 u_2} ι V
          (@add_monoid.to_has_zero.{u_2} V
             (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
       (@domain.to_ring.{u_1} K
          (@division_ring.to_domain.{u_1} K
             (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
       (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
       (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
    (@lattice.supr.{(max u_3 u_2) u_3+1}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       ι
       (@lattice.complete_lattice.to_has_Sup.{(max u_3 u_2)}
          (@submodule.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
          (@submodule.lattice.complete_lattice.{u_1 (max u_3 u_2)} K
             (@finsupp.{u_3 u_2} ι V
                (@add_monoid.to_has_zero.{u_2} V
                   (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
             (@domain.to_ring.{u_1} K
                (@division_ring.to_domain.{u_1} K
                   (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
             (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
             (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))
       (λ (i : ι),
          @submodule.map.{u_1 u_2 (max u_3 u_2)} K V
            (@finsupp.{u_3 u_2} ι V
               (@add_monoid.to_has_zero.{u_2} V
                  (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
            (@domain.to_ring.{u_1} K
               (@division_ring.to_domain.{u_1} K
                  (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
            _inst_2
            (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
            _inst_3
            (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)
            (@finsupp.lsingle.{u_3 u_2 u_1} ι V K
               (@domain.to_ring.{u_1} K
                  (@division_ring.to_domain.{u_1} K
                     (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
               _inst_2
               _inst_3
               i)
            (@submodule.span.{u_1 u_2} K V
               (@domain.to_ring.{u_1} K
                  (@division_ring.to_domain.{u_1} K
                     (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
               _inst_2
               _inst_3
               (@set.image.{u_4 u_2} (φ i) V (f i) (@set.univ.{u_4} (φ i))))))
    (@lattice.has_top.top.{(max u_3 u_2)}
       (@submodule.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_top.{u_1 (max u_3 u_2)} K
          (@finsupp.{u_3 u_2} ι V
             (@add_monoid.to_has_zero.{u_2} V
                (@add_group.to_add_monoid.{u_2} V (@add_comm_group.to_add_group.{u_2} V _inst_2))))
          (@domain.to_ring.{u_1} K
             (@division_ring.to_domain.{u_1} K
                (@field.to_division_ring.{u_1} K (@discrete_field.to_field.{u_1} K _inst_1))))
          (@finsupp.add_comm_group.{u_3 u_2} ι V _inst_2)
          (@finsupp.vector_space.{u_3 u_2 u_1} ι V K _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  end vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  section dim</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  variables {K : Type u} {V : Type v} {ι : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  variables [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  lemma dim_eq : vector_space.dim K (ι →₀ V) = cardinal.mk ι * vector_space.dim K V :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Π (β : Type v) [_inst_1 : has_zero.{v} β], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_mul.{v+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@finsupp.{v v} ι V
          (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{v v} ι V _inst_2)
       (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    rcases exists_is_basis K V with ⟨bs, hbs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_4 : @vector_space.{u v} K V _inst_1 _inst_2], @Exists.{(max (v+1) 1)} (set.{v} V) (λ (b : set.{v} V), @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@finsupp.{v v} ι V
          (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{v v} ι V _inst_2)
       (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@finsupp.{v v} ι V
          (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{v v} ι V _inst_2)
       (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    rw [← cardinal.lift_inj, cardinal.lift_mul, ← hbs.mk_eq_dim,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 498, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{v}}, iff (@eq.{v+2} cardinal.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b)) (@eq.{v+2} cardinal.{v} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : cardinal.{v}), @eq.{v+2} cardinal.{v} (cardinal.lift.{v v} (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} a b)) (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (cardinal.lift.{v v} (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))) (cardinal.lift.{v v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@finsupp.{v v} ι V
          (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
       _inst_1
       (@finsupp.add_comm_group.{v v} ι V _inst_2)
       (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{(max v ?l_1)+2} cardinal.{(max v ?l_1)}
    (cardinal.lift.{v ?l_1}
       (@vector_space.dim.{u v} K
          (@finsupp.{v v} ι V
             (@add_monoid.to_has_zero.{v} V
                (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{v v} ι V _inst_2)
          (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3)))
    (cardinal.lift.{v ?l_1}
       (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
          (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{(max v ?l_1)+2} cardinal.{(max v ?l_1)}
    (cardinal.lift.{v ?l_1}
       (@vector_space.dim.{u v} K
          (@finsupp.{v v} ι V
             (@add_monoid.to_has_zero.{v} V
                (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{v v} ι V _inst_2)
          (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3)))
    (@has_mul.mul.{(max v ?l_1)+1} cardinal.{(max v ?l_1)} cardinal.has_mul.{(max v ?l_1)}
       (cardinal.lift.{v ?l_1} (cardinal.mk.{v} ι))
       (cardinal.lift.{v ?l_1} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (@vector_space.dim.{u v} K
          (@finsupp.{v v} ι V
             (@add_monoid.to_has_zero.{v} V
                (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{v v} ι V _inst_2)
          (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3)))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} (cardinal.mk.{v} ι))
       (cardinal.lift.{v v}
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        ← (is_basis_single _ (λa:ι, hbs)).mk_eq_dim, ← cardinal.sum_mk,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finsupp.is_basis_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hbs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='cardinal.sum_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} {V ι : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] {φ : ι → Type v} (f : Π (ι : ι), φ ι → V), (∀ (i : ι), @is_basis.{v u v} (φ i) K V (f i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) → @is_basis.{v u v} (@sigma.{v v} ι (λ (i : ι), φ i)) K (@finsupp.{v v} ι V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))) (λ (ix : @sigma.{v v} ι (λ (i : ι), φ i)), @finsupp.single.{v v} ι V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))) (@sigma.fst.{v v} ι (λ (i : ι), φ i) ix) (f (@sigma.fst.{v v} ι (λ (i : ι), φ i) ix) (@sigma.snd.{v v} ι (λ (i : ι), φ i) ix))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@finsupp.add_comm_group.{v v} ι V _inst_2) (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type v} (f : ι → Type v), @eq.{v+2} cardinal.{v} (@cardinal.sum.{v v} ι (λ (i : ι), cardinal.mk.{v} (f i))) (cardinal.mk.{v} (@sigma.{v v} ι (λ (i : ι), f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (@vector_space.dim.{u v} K
          (@finsupp.{v v} ι V
             (@add_monoid.to_has_zero.{v} V
                (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))))
          _inst_1
          (@finsupp.add_comm_group.{v v} ι V _inst_2)
          (@finsupp.vector_space.{v v u} ι V K _inst_1 _inst_2 _inst_3)))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} (cardinal.mk.{v} ι))
       (cardinal.lift.{v v}
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (cardinal.mk.{v}
          (@sigma.{v v} ι
             (λ (i : ι), @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} (cardinal.mk.{v} ι))
       (cardinal.lift.{v v}
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (@cardinal.sum.{v v} ι
          (λ (i : ι),
             cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} (cardinal.mk.{v} ι))
       (cardinal.lift.{v v}
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75        ← cardinal.lift_mul, cardinal.lift_inj],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 498, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : cardinal.{v}), @eq.{v+2} cardinal.{v} (cardinal.lift.{v v} (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} a b)) (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{v}}, iff (@eq.{v+2} cardinal.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b)) (@eq.{v+2} cardinal.{v} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (@cardinal.sum.{v v} ι
          (λ (i : ι),
             cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.lift.{v v} (cardinal.mk.{v} ι))
       (cardinal.lift.{v v}
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (cardinal.lift.{v v}
       (@cardinal.sum.{v v} ι
          (λ (i : ι),
             cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))
    (cardinal.lift.{v v}
       (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
          (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (@cardinal.sum.{v v} ι
       (λ (i : ι),
          cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs)))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    { simp only [cardinal.mk_image_eq (injective_single.{u u} _), cardinal.sum_const] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='cardinal.mk_image_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.injective_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='cardinal.sum_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 884, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 389, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {s : set.{u} α}, @function.injective.{u+1 u+1} α β f → @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} β) (@set.has_coe_to_sort.{u} β) (@set.image.{u u} α β f s))) (cardinal.mk.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : has_zero.{u} β] (a : α), @function.injective.{u+1 u+1} β (@finsupp.{u u} α β _inst_1) (@finsupp.single.{u u} α β _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (ι : Type ?l_1) (a : cardinal.{?l_1}), @eq.{?l_1+2} cardinal.{?l_1} (@cardinal.sum.{?l_1 ?l_1} ι (λ (_x : ι), a)) (@has_mul.mul.{?l_1+1} cardinal.{?l_1} cardinal.has_mul.{?l_1} (cardinal.mk.{?l_1} ι) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V ι : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
bs : set.{v} V,
hbs :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x bs) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq.{v+2} cardinal.{v}
    (@cardinal.sum.{v v} ι
       (λ (i : ι),
          cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs)))
    (@has_mul.mul.{v+1} cardinal.{v} cardinal.has_mul.{v} (cardinal.mk.{v} ι)
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) bs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  end dim</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  end finsupp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  section vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  /- We use `universe variables` instead of `universes` here because universes introduced by the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85     `universes` keyword do not get replaced by metavariables once a lemma has been proven. So if you</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86     prove a lemma using universe `u`, you can only apply it to universe `u` in other lemmas of the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87     same section. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  universe variables u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  variables {K : Type u} {V V₁ V₂ : Type v} {V&#x27; : Type w}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  variables [discrete_field K]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  variables [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  variables [add_comm_group V₁] [vector_space K V₁]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  variables [add_comm_group V₂] [vector_space K V₂]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  variables [add_comm_group V&#x27;] [vector_space K V&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u) (β : Type w) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{w} β], Type (max u w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  open vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  set_option class.instance_max_depth 70</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  lemma equiv_of_dim_eq_lift_dim</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    (h : cardinal.lift.{v w} (dim K V) = cardinal.lift.{w v} (dim K V&#x27;)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type ((max v w)+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    nonempty (V ≃ₗ[K] V&#x27;) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type w) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{w} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u w} R M₂ _inst_1 _inst_3], Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type w) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{w} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u w} R M₂ _inst_1 _inst_3], Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    haveI := classical.dec_eq V,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type v), decidable_eq.{v+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    haveI := classical.dec_eq V&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='classical.dec_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 20}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type w), decidable_eq.{w+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    rcases exists_is_basis K V with ⟨m, hm⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_4 : @vector_space.{u v} K V _inst_1 _inst_2], @Exists.{(max (v+1) 1)} (set.{v} V) (λ (b : set.{v} V), @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) b), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x b) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    rcases exists_is_basis K V&#x27; with ⟨m&#x27;, hm&#x27;⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K : Type u) (V : Type w) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{w} V] [_inst_4 : @vector_space.{u w} K V _inst_1 _inst_2], @Exists.{(max (w+1) 1)} (set.{w} V) (λ (b : set.{w} V), @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V) (@set.has_coe_to_sort.{w} V) b) K V (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V) (@set.has_coe_to_sort.{w} V) b), @subtype.val.{w+1} V (λ (x : V), @has_mem.mem.{w w} V (set.{w} V) (@set.has_mem.{w} V) x b) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    rw [←cardinal.lift_inj.1 hm.mk_eq_dim, ←cardinal.lift_inj.1 hm&#x27;.mk_eq_dim] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hm&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{v}}, iff (@eq.{v+2} cardinal.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b)) (@eq.{v+2} cardinal.{v} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{w}}, iff (@eq.{w+2} cardinal.{w} (cardinal.lift.{w w} a) (cardinal.lift.{w w} b)) (@eq.{w+2} cardinal.{w} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27; (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;), @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_8 _inst_9'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{w v} (@vector_space.dim.{u w} K V&#x27; _inst_1 _inst_8 _inst_9)),
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    rcases quotient.exact h with ⟨e⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='quotient.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ((max v w)+1)} [s : setoid.{(max v w)+2} α] {a b : α}, @eq.{(max v w)+2} (@quotient.{(max v w)+2} α s) (@quotient.mk.{(max v w)+2} α s a) (@quotient.mk.{(max v w)+2} α s b) → @has_equiv.equiv.{(max v w)+2} α (@setoid_has_equiv.{(max v w)+2} α s) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v w)+2} cardinal.{(max v w)} (cardinal.lift.{v w} (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))) (cardinal.lift.{w v} (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    let e := (equiv.ulift.symm.trans e).trans equiv.ulift,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β γ : Type (max v w)}, equiv.{v+1 (max v w)+1} α β → equiv.{(max v w)+1 (max v w)+1} β γ → equiv.{v+1 (max v w)+1} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.{(max v w)+1 (max v w)+1} (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)) (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, equiv.{(max v w)+1 v+1} (ulift.{w v} α) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)),
e : equiv.{v+1 w+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
  (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) :=
  @equiv.trans.{v+1 (max v w)+1 w+1}
    (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
    (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)
    (@equiv.trans.{v+1 (max v w)+1 (max v w)+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
       (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
       (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
       (@equiv.symm.{(max v w)+1 v+1}
          (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
          (@equiv.ulift.{v w} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
       e)
    (@equiv.ulift.{w v} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    exact ⟨((module_equiv_finsupp hm).trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m), @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)),
e : equiv.{v+1 w+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
  (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) :=
  @equiv.trans.{v+1 (max v w)+1 w+1}
    (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
    (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)
    (@equiv.trans.{v+1 (max v w)+1 (max v w)+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
       (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
       (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
       (@equiv.symm.{(max v w)+1 v+1}
          (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
          (@equiv.ulift.{v w} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
       e)
    (@equiv.ulift.{w v} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112        (finsupp.dom_lcongr e)).trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finsupp.dom_lcongr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {M R : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : @module.{u u} R M _inst_1 _inst_2] {α₁ : Type v} {α₂ : Type w}, equiv.{v+1 w+1} α₁ α₂ → @linear_equiv.{u (max v u) (max w u)} R (@finsupp.{v u} α₁ M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) (@finsupp.{w u} α₂ M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{v u} α₁ M _inst_2) (@finsupp.add_comm_group.{w u} α₂ M _inst_2) (@finsupp.module.{v u u} α₁ M R _inst_1 _inst_2 _inst_3) (@finsupp.module.{w u u} α₂ M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.{v+1 w+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)),
e : equiv.{v+1 w+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
  (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) :=
  @equiv.trans.{v+1 (max v w)+1 w+1}
    (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
    (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)
    (@equiv.trans.{v+1 (max v w)+1 (max v w)+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
       (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
       (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
       (@equiv.symm.{(max v w)+1 v+1}
          (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
          (@equiv.ulift.{v w} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
       e)
    (@equiv.ulift.{w v} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113        (module_equiv_finsupp hm&#x27;).symm⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='module_equiv_finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 816, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {ι : Type v} {R : Type u} {M : Type v} {v : ι → M} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_4 : @module.{u v} R M _inst_1 _inst_2], @is_basis.{v u v} ι R M v _inst_1 _inst_2 _inst_4 → @linear_equiv.{u v (max v u)} R M (@finsupp.{v u} ι R (@mul_zero_class.to_has_zero.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group.{v u} ι R (@ring.to_add_comm_group.{u} R _inst_1)) _inst_4 (@finsupp.module.{v u u} ι R R _inst_1 (@ring.to_add_comm_group.{u} R _inst_1) (@ring.to_module.{u} R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27; (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;), @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_8 _inst_9'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Canonical equivalence between a module and the linear combinations of basis vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
V&#x27; : Type w,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
_inst_8 : add_comm_group.{w} V&#x27;,
_inst_9 : @vector_space.{u w} K V&#x27; _inst_1 _inst_8,
_inst : decidable_eq.{v+1} V,
_inst_4 : decidable_eq.{w+1} V&#x27;,
m : set.{v} V,
hm :
  @is_basis.{v u v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m) K V
    (λ (i : @coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m),
       @subtype.val.{v+1} V (λ (x : V), @has_mem.mem.{v v} V (set.{v} V) (@set.has_mem.{v} V) x m) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
m&#x27; : set.{w} V&#x27;,
hm&#x27; :
  @is_basis.{w u w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) K V&#x27;
    (λ (i : @coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;),
       @subtype.val.{w+1} V&#x27; (λ (x : V&#x27;), @has_mem.mem.{w w} V&#x27; (set.{w} V&#x27;) (@set.has_mem.{w} V&#x27;) x m&#x27;) i)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_8
    _inst_9,
h :
  @eq.{(max v w)+2} cardinal.{(max v w)}
    (cardinal.lift.{v w}
       (cardinal.mk.{v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
    (cardinal.lift.{w v}
       (cardinal.mk.{w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))),
e :
  equiv.{(max v w)+1 (max v w)+1}
    (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)),
e : equiv.{v+1 w+1} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
  (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;) :=
  @equiv.trans.{v+1 (max v w)+1 w+1}
    (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
    (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
    (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;)
    (@equiv.trans.{v+1 (max v w)+1 (max v w)+1}
       (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
       (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
       (ulift.{v w} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
       (@equiv.symm.{(max v w)+1 v+1}
          (ulift.{w v} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m))
          (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)
          (@equiv.ulift.{v w} (@coe_sort.{(max (v+1) 1) (max 1 (v+1))+1} (set.{v} V) (@set.has_coe_to_sort.{v} V) m)))
       e)
    (@equiv.ulift.{w v} (@coe_sort.{(max (w+1) 1) (max 1 (w+1))+1} (set.{w} V&#x27;) (@set.has_coe_to_sort.{w} V&#x27;) m&#x27;))
⊢ nonempty.{(max (v+1) (w+1))}
    (@linear_equiv.{u v w} K V V&#x27;
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_8
       _inst_3
       _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  def equiv_of_dim_eq_dim (h : dim K V₁ = dim K V₂) : V₁ ≃ₗ[K] V₂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M M₂ : Type v) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u v} R M₂ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (M M₂ : Type v) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u v} R M₂ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
h :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
⊢ @linear_equiv.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    classical,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
h :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
⊢ @linear_equiv.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
h :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7),
_inst : Π (a : Prop), decidable a
⊢ @linear_equiv.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    exact classical.choice (equiv_of_dim_eq_lift_dim (cardinal.lift_inj.2 h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='classical.choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv_of_dim_eq_lift_dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, nonempty.{v+1} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} {V V&#x27; : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [_inst_8 : add_comm_group.{v} V&#x27;] [_inst_9 : @vector_space.{u v} K V&#x27; _inst_1 _inst_8], @eq.{v+2} cardinal.{v} (cardinal.lift.{v v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)) (cardinal.lift.{v v} (@vector_space.dim.{u v} K V&#x27; _inst_1 _inst_8 _inst_9)) → nonempty.{v+1} (@linear_equiv.{u v v} K V V&#x27; (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_8 _inst_3 _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : cardinal.{v}}, iff (@eq.{v+2} cardinal.{v} (cardinal.lift.{v v} a) (cardinal.lift.{v v} b)) (@eq.{v+2} cardinal.{v} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5) (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
h :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7),
_inst : Π (a : Prop), decidable a
⊢ @linear_equiv.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  def fin_dim_vectorspace_equiv (n : ℕ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    (hn : (dim K V) = n) : V ≃ₗ[K] (fin n → K) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u u} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type u) (M : Type v) (M₂ : Type u) [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_4 : @module.{u v} R M _inst_1 _inst_2] [_inst_5 : @module.{u u} R M₂ _inst_1 _inst_3], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A linear equivalence is an invertible linear map.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n)
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    have : cardinal.lift.{v u} (n : cardinal.{v}) = cardinal.lift.{u v} (n : cardinal.{u}),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ((max v u)+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='cardinal.{u} → cardinal.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`cardinal.{u}` is the type of cardinal numbers in `Type u`,
 defined as the quotient of `Type u` by existence of an equivalence
 (a bijection with explicit inverse).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The universe lift operation on cardinals. You can specify the universes explicitly with
 `lift.{u v} : cardinal.{u} → cardinal.{max u v}`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`cardinal.{u}` is the type of cardinal numbers in `Type u`,
 defined as the quotient of `Type u` by existence of an equivalence
 (a bijection with explicit inverse).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n)
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    have hn := cardinal.lift_inj.{v u}.2 hn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{u_1}}, iff (@eq.{(max u_1 u_2)+2} cardinal.{(max u_1 u_2)} (cardinal.lift.{u_1 u_2} a) (cardinal.lift.{u_1 u_2} b)) (@eq.{u_1+2} cardinal.{u_1} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    rw this at hn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) n)) (cardinal.lift.{u v} (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    rw ←@dim_fin_fun K _ n at hn,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='dim_fin_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} [_inst_1 : discrete_field.{u} K] (n : nat), @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K (fin n → K) _inst_1 (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K) (λ (i : fin n), @ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (λ (i : fin n), @ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))) (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{u v}
       (@vector_space.dim.{u u} K (fin n → K) _inst_1
          (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
             (λ (i : fin n),
                @ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (λ (i : fin n),
                @ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    exact classical.choice (equiv_of_dim_eq_lift_dim hn),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='classical.choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv_of_dim_eq_lift_dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max v u)}, nonempty.{(max (v+1) (u+1))} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {K : Type u} {V : Type v} {V&#x27; : Type u} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [_inst_8 : add_comm_group.{u} V&#x27;] [_inst_9 : @vector_space.{u u} K V&#x27; _inst_1 _inst_8], @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)) (cardinal.lift.{u v} (@vector_space.dim.{u u} K V&#x27; _inst_1 _inst_8 _inst_9)) → nonempty.{(max (v+1) (u+1))} (@linear_equiv.{u v u} K V V&#x27; (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_8 _inst_3 _inst_9)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)) (cardinal.lift.{u v} (@vector_space.dim.{u u} K (fin n → K) _inst_1 (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K) (λ (i : fin n), @ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))) (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (λ (i : fin n), @ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))) (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
n : nat,
hn :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       n),
this :
  @eq.{(max v u)+2} cardinal.{(max v u)}
    (cardinal.lift.{v u}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          n))
    (cardinal.lift.{u v}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          n)),
hn :
  @eq.{(max v u)+2} cardinal.{(max v u)} (cardinal.lift.{v u} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3))
    (cardinal.lift.{u v}
       (@vector_space.dim.{u u} K (fin n → K) _inst_1
          (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
             (λ (i : fin n),
                @ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
          (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             (λ (i : fin n),
                @ring.to_add_comm_group.{u} K
                  (@domain.to_ring.{u} K
                     (@division_ring.to_domain.{u} K
                        (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
             (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))))
⊢ @linear_equiv.{u v u} K V (fin n → K)
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    (@pi.add_comm_group.{0 u} (fin n) (λ (a : fin n), K)
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))))
    _inst_3
    (@pi.module.{0 u u} (fin n) (λ (a : fin n), K) K
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       (λ (i : fin n),
          @ring.to_add_comm_group.{u} K
            (@domain.to_ring.{u} K
               (@division_ring.to_domain.{u} K
                  (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))))
       (λ (i : fin n), @discrete_field.to_vector_space.{u} K _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  lemma eq_bot_iff_dim_eq_zero (p : submodule K V) (h : dim K p = 0) : p = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    have : dim K p = dim K (⊥ : submodule K V) := by rwa [dim_bot],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='dim_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)))) (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v}),
this :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))))
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    let e := equiv_of_dim_eq_dim this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='equiv_of_dim_eq_dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 116, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {K : Type u} {V₁ V₂ : Type v} [_inst_1 : discrete_field.{u} K] [_inst_4 : add_comm_group.{v} V₁] [_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4] [_inst_6 : add_comm_group.{v} V₂] [_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6], @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5) (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7) → @linear_equiv.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) p) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 p) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)) (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v}),
this :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))))
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v}),
this :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))),
e : @linear_equiv.{u v v} K
  (@coe_sort.{v+1 (max 1 (v+1))+1}
     (@submodule.{u v} K V
        (@domain.to_ring.{u} K
           (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
        _inst_2
        _inst_3)
     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (set.{v} V)
        (@coe_base_aux.{v+1 (max (v+1) 1)}
           (@submodule.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3)
           (set.{v} V)
           (@submodule.has_coe.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3))
        (@set.has_coe_to_sort.{v} V))
     p)
  (@coe_sort.{v+1 (max 1 (v+1))+1}
     (@submodule.{u v} K V
        (@domain.to_ring.{u} K
           (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
        _inst_2
        _inst_3)
     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (set.{v} V)
        (@coe_base_aux.{v+1 (max (v+1) 1)}
           (@submodule.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3)
           (set.{v} V)
           (@submodule.has_coe.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3))
        (@set.has_coe_to_sort.{v} V))
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)))
  (@domain.to_ring.{u} K
     (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
  (@submodule.add_comm_group.{u v} K V
     (@domain.to_ring.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
     _inst_2
     _inst_3
     p)
  (@submodule.add_comm_group.{u v} K V
     (@domain.to_ring.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
     _inst_2
     _inst_3
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)))
  (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)
  (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3))) :=
  @equiv_of_dim_eq_dim.{u v} K
    (@coe_sort.{v+1 (max 1 (v+1))+1}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (set.{v} V)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@submodule.has_coe.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))
          (@set.has_coe_to_sort.{v} V))
       p)
    (@coe_sort.{v+1 (max 1 (v+1))+1}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (set.{v} V)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@submodule.has_coe.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))
          (@set.has_coe_to_sort.{v} V))
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    _inst_1
    (@submodule.add_comm_group.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       p)
    (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)
    (@submodule.add_comm_group.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    this
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    exact e.eq_bot_of_equiv _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1389, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@linear_equiv.{u v v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) p) (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 p) (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V : Type v,
_inst_1 : discrete_field.{u} K,
_inst_2 : add_comm_group.{v} V,
_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2,
p :
  @submodule.{u v} K V
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_2
    _inst_3,
h :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v}),
this :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          p)
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          p)
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3)
                (set.{v} V)
                (@submodule.has_coe.{u v} K V
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_2
                   _inst_3))
             (@set.has_coe_to_sort.{v} V))
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       _inst_1
       (@submodule.add_comm_group.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))
       (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
          (@lattice.has_bot.bot.{v}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (@submodule.lattice.has_bot.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)))),
e : @linear_equiv.{u v v} K
  (@coe_sort.{v+1 (max 1 (v+1))+1}
     (@submodule.{u v} K V
        (@domain.to_ring.{u} K
           (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
        _inst_2
        _inst_3)
     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (set.{v} V)
        (@coe_base_aux.{v+1 (max (v+1) 1)}
           (@submodule.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3)
           (set.{v} V)
           (@submodule.has_coe.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3))
        (@set.has_coe_to_sort.{v} V))
     p)
  (@coe_sort.{v+1 (max 1 (v+1))+1}
     (@submodule.{u v} K V
        (@domain.to_ring.{u} K
           (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
        _inst_2
        _inst_3)
     (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (set.{v} V)
        (@coe_base_aux.{v+1 (max (v+1) 1)}
           (@submodule.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3)
           (set.{v} V)
           (@submodule.has_coe.{u v} K V
              (@domain.to_ring.{u} K
                 (@division_ring.to_domain.{u} K
                    (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
              _inst_2
              _inst_3))
        (@set.has_coe_to_sort.{v} V))
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)))
  (@domain.to_ring.{u} K
     (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
  (@submodule.add_comm_group.{u v} K V
     (@domain.to_ring.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
     _inst_2
     _inst_3
     p)
  (@submodule.add_comm_group.{u v} K V
     (@domain.to_ring.{u} K
        (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
     _inst_2
     _inst_3
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)))
  (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)
  (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
     (@lattice.has_bot.bot.{v}
        (@submodule.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3)
        (@submodule.lattice.has_bot.{u v} K V
           (@domain.to_ring.{u} K
              (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
           _inst_2
           _inst_3))) :=
  @equiv_of_dim_eq_dim.{u v} K
    (@coe_sort.{v+1 (max 1 (v+1))+1}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (set.{v} V)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@submodule.has_coe.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))
          (@set.has_coe_to_sort.{v} V))
       p)
    (@coe_sort.{v+1 (max 1 (v+1))+1}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (set.{v} V)
          (@coe_base_aux.{v+1 (max (v+1) 1)}
             (@submodule.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3)
             (set.{v} V)
             (@submodule.has_coe.{u v} K V
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_2
                _inst_3))
          (@set.has_coe_to_sort.{v} V))
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    _inst_1
    (@submodule.add_comm_group.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       p)
    (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)
    (@submodule.add_comm_group.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3
       (@lattice.has_bot.bot.{v}
          (@submodule.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)
          (@submodule.lattice.has_bot.{u v} K V
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_2
             _inst_3)))
    this
⊢ @eq.{v+1}
    (@submodule.{u v} K V
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_2
       _inst_3)
    p
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3)
       (@submodule.lattice.has_bot.{u v} K V
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_2
          _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  lemma injective_of_surjective (f : V₁ →ₗ[K] V₂)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='V₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) (β γ : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{v} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u v} α γ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) (β γ : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : add_comm_group.{v} γ] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] [_inst_5 : @module.{u v} α γ _inst_1 _inst_3], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    (hV₁ : dim K V₁ &lt; cardinal.omega) (heq : dim K V₂ = dim K V₁) (hf : f.range = ⊤) : f.ker = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 885, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_lt.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@linear_map.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M M₂ : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u v} R M₂ _inst_1 _inst_3], @linear_map.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u v} R M₂ _inst_1 _inst_3 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_top.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@linear_map.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M M₂ : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u v} R M₂ _inst_1 _inst_3], @linear_map.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u v} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v) [c : lattice.has_bot.{v} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The range of a linear map `f : M → M₂` is a submodule of `M₂`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  have hk : dim K f.ker &lt; cardinal.omega := lt_of_le_of_lt (dim_submodule_le _) hV₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dim_submodule_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hV₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@linear_map.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {R : Type u} {M M₂ : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u v} R M₂ _inst_1 _inst_3], @linear_map.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u v} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)} [c : has_lt.{v+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (v+1)} [_inst_1 : preorder.{v+1} α] {a b c : α}, @has_le.le.{v+1} α (@preorder.to_has_le.{v+1} α _inst_1) a b → @has_lt.lt.{v+1} α (@preorder.to_has_lt.{v+1} α _inst_1) b c → @has_lt.lt.{v+1} α (@preorder.to_has_lt.{v+1} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] (s : @submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3), @has_le.le.{v+1} cardinal.{v} cardinal.has_le.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) s) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 s) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 s)) (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v}
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    rcases cardinal.lt_omega.1 hV₁ with ⟨d₁, eq₁⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cardinal.lt_omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hV₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 652, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : cardinal.{v}}, iff (@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) c cardinal.omega.{v}) (@Exists.{1} nat (λ (n : nat), @eq.{v+2} cardinal.{v} c (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v}
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁)
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    rcases cardinal.lt_omega.1 hk with ⟨d₂, eq₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cardinal.lt_omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 652, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : cardinal.{v}}, iff (@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) c cardinal.omega.{v}) (@Exists.{1} nat (λ (n : nat), @eq.{v+2} cardinal.{v} c (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{v+1} cardinal.{v} (@preorder.to_has_lt.{v+1} cardinal.{v} (@partial_order.to_preorder.{v+1} cardinal.{v} (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v} (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v} cardinal.canonically_ordered_monoid.{v})))) (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@submodule.has_coe.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} V₁)) (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) _inst_1 (@submodule.add_comm_group.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f))) cardinal.omega.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁)
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    have : 0 = d₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂

K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    { have := dim_eq_surjective f (linear_map.range_eq_top.1 hf),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='dim_eq_surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.range_eq_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 900, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V V₂ : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] [_inst_4 : add_comm_group.{v} V₂] [_inst_5 : @vector_space.{u v} K V₂ _inst_1 _inst_4] (f : @linear_map.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5), @function.surjective.{v+1 v+1} V V₂ (@coe_fn.{v+1 v+1} (@linear_map.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5) (@linear_map.has_coe_to_fun.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5) f) → @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V _inst_1 _inst_2 _inst_3) (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_4 _inst_5) (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) (@linear_map.ker.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5 f)) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 (@linear_map.ker.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5 f)) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 (@linear_map.ker.{u v v} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5 f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@linear_map.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {R : Type u} {M M₂ : Type v} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : add_comm_group.{v} M₂] [_inst_5 : @module.{u v} R M _inst_1 _inst_2] [_inst_6 : @module.{u v} R M₂ _inst_1 _inst_3] {f : @linear_map.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6}, iff (@eq.{v+1} (@submodule.{u v} R M₂ _inst_1 _inst_3 _inst_6) (@linear_map.range.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f) (@lattice.has_top.top.{v} (@submodule.{u v} R M₂ _inst_1 _inst_3 _inst_6) (@submodule.lattice.has_top.{u v} R M₂ _inst_1 _inst_3 _inst_6))) (@function.surjective.{v+1 v+1} M M₂ (@coe_fn.{v+1 v+1} (@linear_map.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u v v} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (@submodule.{u v} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7) (@linear_map.range.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f) (@lattice.has_top.top.{v} (@submodule.{u v} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7) (@submodule.lattice.has_top.{u v} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂

K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
       (@vector_space.dim.{u v} K
          (@coe_sort.{v+1 (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5)
                   (set.{v} V₁)
                   (@submodule.has_coe.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5))
                (@set.has_coe_to_sort.{v} V₁))
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          _inst_1
          (@submodule.add_comm_group.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148      rw [heq, eq₁, eq₂, ← nat.cast_add, cardinal.nat_cast_inj] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.cast_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.nat_cast_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7) (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5) (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) d₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@submodule.has_coe.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} V₁)) (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) _inst_1 (@submodule.add_comm_group.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f))) (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) d₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (v+1)} [_inst_1 : add_monoid.{v+1} α] [_inst_2 : has_one.{v+1} α] (m n : nat), @eq.{v+2} α (@coe.{1 v+2} nat α (@coe_to_lift.{1 v+2} nat α (@coe_base.{1 v+2} nat α (@nat.cast_coe.{v+1} α (@add_monoid.to_has_zero.{v+1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{v+1} α (@add_monoid.to_add_semigroup.{v+1} α _inst_1))))) (@has_add.add.{0} nat nat.has_add m n)) (@has_add.add.{v+1} α (@add_semigroup.to_has_add.{v+1} α (@add_monoid.to_add_semigroup.{v+1} α _inst_1)) (@coe.{1 v+2} nat α (@coe_to_lift.{1 v+2} nat α (@coe_base.{1 v+2} nat α (@nat.cast_coe.{v+1} α (@add_monoid.to_has_zero.{v+1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{v+1} α (@add_monoid.to_add_semigroup.{v+1} α _inst_1))))) m) (@coe.{1 v+2} nat α (@coe_to_lift.{1 v+2} nat α (@coe_base.{1 v+2} nat α (@nat.cast_coe.{v+1} α (@add_monoid.to_has_zero.{v+1} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{v+1} α (@add_monoid.to_add_semigroup.{v+1} α _inst_1))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, iff (@eq.{v+2} cardinal.{v} (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) m) (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) n)) (@eq.{1} nat m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
       (@vector_space.dim.{u v} K
          (@coe_sort.{v+1 (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5)
                   (set.{v} V₁)
                   (@submodule.has_coe.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5))
                (@set.has_coe_to_sort.{v} V₁))
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          _inst_1
          (@submodule.add_comm_group.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
       (@vector_space.dim.{u v} K
          (@coe_sort.{v+1 (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5)
                   (set.{v} V₁)
                   (@submodule.has_coe.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5))
                (@set.has_coe_to_sort.{v} V₁))
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          _inst_1
          (@submodule.add_comm_group.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v}
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          d₁)
       (@vector_space.dim.{u v} K
          (@coe_sort.{v+1 (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5)
                   (set.{v} V₁)
                   (@submodule.has_coe.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5))
                (@set.has_coe_to_sort.{v} V₁))
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          _inst_1
          (@submodule.add_comm_group.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v}
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v}
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          d₁)
       (@coe.{1 v+2} nat cardinal.{v}
          (@coe_to_lift.{1 v+2} nat cardinal.{v}
             (@coe_base.{1 v+2} nat cardinal.{v}
                (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
          d₂))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v}
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v}
                (@add_monoid.to_has_zero.{v+1} cardinal.{v}
                   (@add_comm_monoid.to_add_monoid.{v+1} cardinal.{v}
                      (@ordered_comm_monoid.to_add_comm_monoid.{v+1} cardinal.{v}
                         (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                            cardinal.canonically_ordered_monoid.{v}))))
                cardinal.has_one.{v}
                (@add_semigroup.to_has_add.{v+1} cardinal.{v}
                   (@add_monoid.to_add_semigroup.{v+1} cardinal.{v}
                      (@add_comm_monoid.to_add_monoid.{v+1} cardinal.{v}
                         (@ordered_comm_monoid.to_add_comm_monoid.{v+1} cardinal.{v}
                            (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                               cardinal.canonically_ordered_monoid.{v}))))))))
       (@has_add.add.{0} nat nat.has_add d₁ d₂))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat d₁ (@has_add.add.{0} nat nat.has_add d₁ d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@has_add.add.{v+1} cardinal.{v} cardinal.has_add.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
       (@vector_space.dim.{u v} K
          (@coe_sort.{v+1 (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@coe_base_aux.{v+1 (max (v+1) 1)}
                   (@submodule.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5)
                   (set.{v} V₁)
                   (@submodule.has_coe.{u v} K V₁
                      (@domain.to_ring.{u} K
                         (@division_ring.to_domain.{u} K
                            (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                      _inst_4
                      _inst_5))
                (@set.has_coe_to_sort.{v} V₁))
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          _inst_1
          (@submodule.add_comm_group.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))
          (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
             (@linear_map.ker.{u v v} K V₁ V₂
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_6
                _inst_5
                _inst_7
                f))))
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat d₁ (@has_add.add.{0} nat nat.has_add d₁ d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149      exact nat.add_left_cancel this },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nat.add_left_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m k : nat}, @eq.{1} nat (@has_add.add.{0} nat nat.has_add n m) (@has_add.add.{0} nat nat.has_add n k) → @eq.{1} nat m k'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat d₁ (@has_add.add.{0} nat nat.has_add d₁ d₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat d₁ (@has_add.add.{0} nat nat.has_add d₁ d₂)
⊢ @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    refine eq_bot_iff_dim_eq_zero _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq_bot_iff_dim_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} {V : Type v} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2] (p : @submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3), @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (set.{v} V) (@submodule.has_coe.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3)) (@set.has_coe_to_sort.{v} V)) p) _inst_1 (@submodule.add_comm_group.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3 p) (@subspace.vector_space.{u v} K V _inst_1 _inst_2 _inst_3 p)) (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v}) → @eq.{v+1} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) p (@lattice.has_bot.bot.{v} (@submodule.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3) (@submodule.lattice.has_bot.{u v} K V (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+1}
    (@submodule.{u v} K V₁
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_5)
    (@linear_map.ker.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_bot.bot.{v}
       (@submodule.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5)
       (@submodule.lattice.has_bot.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    rw [eq₂, ← this, nat.cast_zero]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='eq₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (set.{v} V₁) (@submodule.has_coe.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5)) (@set.has_coe_to_sort.{v} V₁)) (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) _inst_1 (@submodule.add_comm_group.{u v} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f)) (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5 (@linear_map.ker.{u v v} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f))) (@coe.{1 v+2} nat cardinal.{v} (@coe_to_lift.{1 v+2} nat cardinal.{v} (@coe_base.{1 v+2} nat cardinal.{v} (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v}))) d₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (v+1)} [_inst_1 : has_zero.{v+1} α] [_inst_2 : has_one.{v+1} α] [_inst_3 : has_add.{v+1} α], @eq.{v+2} α (@coe.{1 v+2} nat α (@coe_to_lift.{1 v+2} nat α (@coe_base.{1 v+2} nat α (@nat.cast_coe.{v+1} α _inst_1 _inst_2 _inst_3))) (@has_zero.zero.{0} nat nat.has_zero)) (@has_zero.zero.{v+1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+2} cardinal.{v}
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂)
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+2} cardinal.{v}
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       (@has_zero.zero.{0} nat nat.has_zero))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K : Type u,
V₁ V₂ : Type v,
_inst_1 : discrete_field.{u} K,
_inst_4 : add_comm_group.{v} V₁,
_inst_5 : @vector_space.{u v} K V₁ _inst_1 _inst_4,
_inst_6 : add_comm_group.{v} V₂,
_inst_7 : @vector_space.{u v} K V₂ _inst_1 _inst_6,
f :
  @linear_map.{u v v} K V₁ V₂
    (@domain.to_ring.{u} K
       (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
    _inst_4
    _inst_6
    _inst_5
    _inst_7,
hV₁ :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    cardinal.omega.{v},
heq :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₂ _inst_1 _inst_6 _inst_7)
    (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5),
hf :
  @eq.{v+1}
    (@submodule.{u v} K V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_6
       _inst_7)
    (@linear_map.range.{u v v} K V₁ V₂
       (@domain.to_ring.{u} K
          (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
       _inst_4
       _inst_6
       _inst_5
       _inst_7
       f)
    (@lattice.has_top.top.{v}
       (@submodule.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)
       (@submodule.lattice.has_top.{u v} K V₂
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_6
          _inst_7)),
hk :
  @has_lt.lt.{v+1} cardinal.{v}
    (@preorder.to_has_lt.{v+1} cardinal.{v}
       (@partial_order.to_preorder.{v+1} cardinal.{v}
          (@ordered_comm_monoid.to_partial_order.{v+1} cardinal.{v}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{v+1} cardinal.{v}
                cardinal.canonically_ordered_monoid.{v}))))
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    cardinal.omega.{v},
d₁ : nat,
eq₁ :
  @eq.{v+2} cardinal.{v} (@vector_space.dim.{u v} K V₁ _inst_1 _inst_4 _inst_5)
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₁),
d₂ : nat,
eq₂ :
  @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@coe.{1 v+2} nat cardinal.{v}
       (@coe_to_lift.{1 v+2} nat cardinal.{v}
          (@coe_base.{1 v+2} nat cardinal.{v}
             (@nat.cast_coe.{v+1} cardinal.{v} cardinal.has_zero.{v} cardinal.has_one.{v} cardinal.has_add.{v})))
       d₂),
this : @eq.{1} nat (@has_zero.zero.{0} nat nat.has_zero) d₂
⊢ @eq.{v+2} cardinal.{v}
    (@vector_space.dim.{u v} K
       (@coe_sort.{v+1 (max 1 (v+1))+1}
          (@submodule.{u v} K V₁
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_5)
          (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1}
             (@submodule.{u v} K V₁
                (@domain.to_ring.{u} K
                   (@division_ring.to_domain.{u} K
                      (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                _inst_4
                _inst_5)
             (set.{v} V₁)
             (@coe_base_aux.{v+1 (max (v+1) 1)}
                (@submodule.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5)
                (set.{v} V₁)
                (@submodule.has_coe.{u v} K V₁
                   (@domain.to_ring.{u} K
                      (@division_ring.to_domain.{u} K
                         (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
                   _inst_4
                   _inst_5))
             (@set.has_coe_to_sort.{v} V₁))
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       _inst_1
       (@submodule.add_comm_group.{u v} K V₁
          (@domain.to_ring.{u} K
             (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
          _inst_4
          _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f))
       (@subspace.vector_space.{u v} K V₁ _inst_1 _inst_4 _inst_5
          (@linear_map.ker.{u v v} K V₁ V₂
             (@domain.to_ring.{u} K
                (@division_ring.to_domain.{u} K
                   (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1))))
             _inst_4
             _inst_6
             _inst_5
             _inst_7
             f)))
    (@has_zero.zero.{v+1} cardinal.{v} cardinal.has_zero.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  end vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  section vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  open vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  set_option class.instance_max_depth 50</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  local attribute [instance] submodule.module</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='submodule.module'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 337, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_4 : @module.{u v} α β _inst_1 _inst_2] (p : @submodule.{u v} α β _inst_1 _inst_2 _inst_4), @module.{u v} α (@coe_sort.{v+1 (max 1 (v+1))+1} (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (@coe_sort_trans.{v+1 (max (v+1) 1) (max 1 (v+1))+1} (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (set.{v} β) (@coe_base_aux.{v+1 (max (v+1) 1)} (@submodule.{u v} α β _inst_1 _inst_2 _inst_4) (set.{v} β) (@submodule.has_coe.{u v} α β _inst_1 _inst_2 _inst_4)) (@set.has_coe_to_sort.{v} β)) p) _inst_1 (@submodule.add_comm_group.{u v} α β _inst_1 _inst_2 _inst_4 p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  variables {K V : Type u} [discrete_field K] [add_comm_group V] [vector_space K V]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α β : Type u) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{u} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  set_option pp.universes false</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(pretty printer) display universes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  lemma cardinal_mk_eq_cardinal_mk_field_pow_dim (h : dim K V &lt; cardinal.omega) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field K] [_inst_2 : add_comm_group V] [_inst_3 : @vector_space K V _inst_1 _inst_2], cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    cardinal.mk V = cardinal.mk K ^ dim K V :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type (u+1)} [c : has_pow α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field K] [_inst_2 : add_comm_group V] [_inst_3 : @vector_space K V _inst_1 _inst_2], cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    rcases exists_is_basis K V with ⟨s, hs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='exists_is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)) (λ (a : prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) (λ (a : sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat), @sum.has_reflect (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) (λ (a : prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) (λ (a : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)), @list.reflect (tactic.list_Pi tactic.rcases_patt) (λ (a : tactic.list_Pi tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi tactic.rcases_patt) a) `(option name) `(tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K V : Type u) [_inst_1 : discrete_field K] [_inst_2 : add_comm_group V] [_inst_4 : @vector_space K V _inst_1 _inst_2], @Exists (set V) (λ (b : set V), @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) b) K V (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) b), @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x b) i) (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1)))) _inst_2 _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)) (λ (a : prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) (λ (a : sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat), @sum.has_reflect (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) (λ (a : prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) (λ (a : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)), @list.reflect (tactic.list_Pi tactic.rcases_patt) (λ (a : tactic.list_Pi tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi tactic.rcases_patt) a) `(option name) `(tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)) (λ (a : prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) (λ (a : sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat), @sum.has_reflect (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) (λ (a : prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) (λ (a : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)), @list.reflect (tactic.list_Pi tactic.rcases_patt) (λ (a : tactic.list_Pi tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi tactic.rcases_patt) a) `(option name) `(tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)) (λ (a : prod pexpr (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) (λ (a : sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat), @sum.has_reflect (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) (λ (a : prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) (λ (a : tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)), @list.reflect (tactic.list_Pi tactic.rcases_patt) (λ (a : tactic.list_Pi tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi tactic.rcases_patt) a) `(option name) `(tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum (prod (option name) (tactic.list_Sigma (tactic.list_Pi tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    have : nonempty (fintype s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional lean.parser lean.parser.alternative name lean.parser.ident) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one)))))))) (char.of_nat (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional lean.parser lean.parser.alternative name lean.parser.ident) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one)))))))) (char.of_nat (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional lean.parser lean.parser.alternative name lean.parser.ident) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one)))))))) (char.of_nat (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional lean.parser lean.parser.alternative name lean.parser.ident) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@alternative.to_applicative lean.parser lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one)))))))) (char.of_nat (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))

K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
this : nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    { rwa [← cardinal.lt_omega_iff_fintype, cardinal.lift_inj.1 hs.mk_eq_dim] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='cardinal.lt_omega_iff_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 688, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u}, iff (@has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) (cardinal.mk α) cardinal.omega) (nonempty (fintype α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal}, iff (@eq cardinal (cardinal.lift a) (cardinal.lift b)) (@eq cardinal a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s), @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i) (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))

K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
this : nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (cardinal.mk (@coe_sort (set V) (@set.has_coe_to_sort V) s))
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3
⊢ nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
this : nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    cases this with hsf, letI := hsf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hsf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod (option name) pexpr) (λ (a : prod (option name) pexpr), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list name) (λ (a : list name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod (option name) pexpr) (λ (a : prod (option name) pexpr), @prod.has_reflect (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list name) (λ (a : list name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option name) (λ (a : option name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional lean.parser lean.parser.alternative name lean.parser.ident) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@monad.to_applicative lean.parser (@interaction_monad.monad lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option pexpr) (λ (a : option pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional lean.parser lean.parser.alternative pexpr (@has_seq_right.seq_right lean.parser (@applicative.to_has_seq_right lean.parser (@monad.to_applicative lean.parser (@interaction_monad.monad lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one)))))))) (char.of_nat (@bit1 nat nat.has_one nat.has_add (@bit0 nat nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@bit1 nat nat.has_one nat.has_add (@has_one.one nat nat.has_one))))))))) interactive.types.texpr)) → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `let`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='letI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
this : nonempty (fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s))
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s)
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    calc cardinal.mk V = cardinal.mk (s →₀ K) : quotient.sound ⟨(module_equiv_finsupp hs).to_equiv⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='module_equiv_finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_equiv.to_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 816, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1287, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type u) [_inst_1 : has_zero β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π {ι R M : Type u} {v : ι → M} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_4 : @module R M _inst_1 _inst_2], @is_basis ι R M v _inst_1 _inst_2 _inst_4 → @linear_equiv R M (@finsupp ι R (@mul_zero_class.to_has_zero R (@semiring.to_mul_zero_class R (@ring.to_semiring R _inst_1)))) _inst_1 _inst_2 (@finsupp.add_comm_group ι R (@ring.to_add_comm_group R _inst_1)) _inst_4 (@finsupp.module ι R R _inst_1 (@ring.to_add_comm_group R _inst_1) (@ring.to_module R _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s), @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i) (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R M M₂ : Type u} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : add_comm_group M₂] [_inst_4 : @module R M _inst_1 _inst_2] [_inst_5 : @module R M₂ _inst_1 _inst_3], @linear_equiv R M M₂ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 → equiv M M₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Canonical equivalence between a module and the linear combinations of basis vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      ... = cardinal.mk (s → K) : quotient.sound ⟨finsupp.equiv_fun_on_fintype⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.equiv_fun_on_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='∀ {α : Type (u+1)} [s : setoid α] {a b : α}, @has_equiv.equiv α (@setoid_has_equiv α s) a b → @eq (@quotient α s) (@quotient.mk α s a) (@quotient.mk α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} [_inst_1 : has_zero β] [_inst_2 : fintype α], equiv (@finsupp α β _inst_1) (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      ... = _ : by rw [← cardinal.lift_inj.1 hs.mk_eq_dim, cardinal.power_def]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.power_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal}, iff (@eq cardinal (cardinal.lift a) (cardinal.lift b)) (@eq cardinal a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s), @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i) (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1)))) _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α β : Type u), @eq cardinal (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk α) (cardinal.mk β)) (cardinal.mk (β → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk V)
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk (@coe_sort (set V) (@set.has_coe_to_sort V) s → K))
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk (@coe_sort (set V) (@set.has_coe_to_sort V) s → K))
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K)
       (cardinal.mk (@coe_sort (set V) (@set.has_coe_to_sort V) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega,
s : set V,
hs :
  @is_basis (@coe_sort (set V) (@set.has_coe_to_sort V) s) K V
    (λ (i : @coe_sort (set V) (@set.has_coe_to_sort V) s),
       @subtype.val V (λ (x : V), @has_mem.mem V (set V) (@set.has_mem V) x s) i)
    (@domain.to_ring K (@division_ring.to_domain K (@field.to_division_ring K (@discrete_field.to_field K _inst_1))))
    _inst_2
    _inst_3,
hsf : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s),
_inst : fintype (@coe_sort (set V) (@set.has_coe_to_sort V) s) := hsf
⊢ @eq cardinal (cardinal.mk (@coe_sort (set V) (@set.has_coe_to_sort V) s → K))
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  lemma cardinal_lt_omega_of_dim_lt_omega [fintype K] (h : dim K V &lt; cardinal.omega) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field K] [_inst_2 : add_comm_group V] [_inst_3 : @vector_space K V _inst_1 _inst_2], cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    cardinal.mk V &lt; cardinal.omega :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='V'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)} [c : has_lt α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='cardinal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`ω` is the smallest infinite cardinal, also known as ℵ₀.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
_inst_4 : fintype K,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (cardinal.mk V)
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    rw [cardinal_mk_eq_cardinal_mk_field_pow_dim h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) (@vector_space.dim K V _inst_1 _inst_2 _inst_3) cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
_inst_4 : fintype K,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (cardinal.mk V)
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
_inst_4 : fintype K,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    exact cardinal.power_lt_omega (cardinal.lt_omega_iff_fintype.2 ⟨infer_instance⟩) h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.power_lt_omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cardinal.lt_omega_iff_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='infer_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 730, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 688, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 566, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal}, @has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) a cardinal.omega → @has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) b cardinal.omega → @has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) (@has_pow.pow cardinal cardinal cardinal.has_pow a b) cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u}, iff (@has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) (cardinal.mk α) cardinal.omega) (nonempty (fintype α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [i : α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt cardinal (@preorder.to_has_lt cardinal (@partial_order.to_preorder cardinal (@ordered_comm_monoid.to_partial_order cardinal (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid)))) (@vector_space.dim K V _inst_1 _inst_2 _inst_3) cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `by apply_instance`, but not dependent on the tactic framework.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='K V : Type u,
_inst_1 : discrete_field K,
_inst_2 : add_comm_group V,
_inst_3 : @vector_space K V _inst_1 _inst_2,
_inst_4 : fintype K,
h :
  @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@vector_space.dim K V _inst_1 _inst_2 _inst_3)
    cardinal.omega
⊢ @has_lt.lt cardinal
    (@preorder.to_has_lt cardinal
       (@partial_order.to_preorder cardinal
          (@ordered_comm_monoid.to_partial_order cardinal
             (@canonically_ordered_monoid.to_ordered_comm_monoid cardinal cardinal.canonically_ordered_monoid))))
    (@has_pow.pow cardinal cardinal cardinal.has_pow (cardinal.mk K) (@vector_space.dim K V _inst_1 _inst_2 _inst_3))
    cardinal.omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  end vector_space</code></pre>
</body>