<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison, Yury Kudryashov</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.concrete_category.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.concrete_category.bundled</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # Category instances for algebraic structures that use bundled homs.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  Many algebraic structures in Lean initially used unbundled homs (e.g. a bare function between types,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  along with an `is_monoid_hom` typeclass), but the general trend is towards using bundled homs.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  This file provides a basic infrastructure to define concrete categories using bundled homs, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  define forgetful functors between them.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  variables {c : Type u → Type u} (hom : Π ⦃α β : Type u⦄ (Iα : c α) (Iβ : c β), Type u)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  /-- Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  structure bundled_hom :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  (to_fun : Π {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  (id : Π {α : Type u} (I : c α), hom I I)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} (I : c α), hom α α I I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  (comp : Π {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom β γ Iβ Iγ → hom α β Iα Iβ → hom α γ Iα Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  (hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), function.injective (to_fun Iα Iβ) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  (id_to_fun : ∀ {α : Type u} (I : c α), to_fun I I (id I) = _root_.id . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} (I : c α), hom α α I I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (comp_to_fun : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    (f : hom Iα Iβ) (g : hom Iβ Iγ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    to_fun Iα Iγ (comp Iα Iβ Iγ g f) = (to_fun Iβ Iγ g) ∘ (to_fun Iα Iβ f) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iα'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom β γ Iβ Iγ → hom α β Iα Iβ → hom α γ Iα Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='hom β γ Iβ Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='hom α β Iα Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='hom β γ Iβ Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} (Iα : c α) (Iβ : c β), hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='c β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='hom α β Iα Iβ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  attribute [class] bundled_hom</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.bundled_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {c : Type u → Type u}, (Π ⦃α β : Type u⦄, c α → c β → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.
This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  attribute [simp] bundled_hom.id_to_fun bundled_hom.comp_to_fun</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.bundled_hom.id_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.bundled_hom.comp_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u} (c_1 : @category_theory.bundled_hom.{u} c hom), auto_param.{0} (∀ {α : Type u} (I : c α), @eq.{u+1} (α → α) (@category_theory.bundled_hom.to_fun.{u} c hom c_1 α α I I (@category_theory.bundled_hom.id.{u} c hom c_1 α I)) (@id.{u+1} α)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u} (c_1 : @category_theory.bundled_hom.{u} c hom), auto_param.{0} (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : @hom α β Iα Iβ) (g : @hom β γ Iβ Iγ), @eq.{u+1} (α → γ) (@category_theory.bundled_hom.to_fun.{u} c hom c_1 α γ Iα Iγ (@category_theory.bundled_hom.comp.{u} c hom c_1 α β γ Iα Iβ Iγ g f)) (@function.comp.{u+1 u+1 u+1} α β γ (@category_theory.bundled_hom.to_fun.{u} c hom c_1 β γ Iβ Iγ g) (@category_theory.bundled_hom.to_fun.{u} c hom c_1 α β Iα Iβ f))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  namespace bundled_hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  variable [𝒞 : bundled_hom hom]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.bundled_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {c : Type u → Type u}, (Π ⦃α β : Type u⦄, c α → c β → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.
This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  /-- Every `@bundled_hom c _` defines a category with objects in `bundled c`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  This instance generates the type-class problem bundled_hom ?m (which is why this is marked as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  `[nolint]`). Currently that is not a problem, as there are almost no instances of `bundled_hom`. -/</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom,
X Y : category_theory.bundled.{u u} c,
f :
  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
    X
    Y
⊢ @eq.{u+1}
    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
       X
       Y)
    (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.bundled_hom.category.{u} c hom 𝒞))
       X
       X
       Y
       (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
          X)
       f)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  @[nolint] instance category : category (bundled c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  by refine</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  { hom := λ X Y, @hom X.1 Y.1 X.str Y.str,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    id := λ X, @bundled_hom.id c hom 𝒞 X X.str,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.bundled_hom.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u}, @category_theory.bundled_hom.{u} c hom → Π {α : Type u} (I : c α), @hom α α I I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    comp := λ X Y Z f g, @bundled_hom.comp c hom 𝒞 X Y Z X.str Y.str Z.str g f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.bundled_hom.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u}, @category_theory.bundled_hom.{u} c hom → Π {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), @hom β γ Iβ Iγ → @hom α β Iα Iβ → @hom α γ Iα Iγ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π ⦃α β : Type u⦄, c α → c β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    comp_id&#x27; := _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    id_comp&#x27; := _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    assoc&#x27; := _};</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  intros; apply 𝒞.hom_ext;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    simp only [𝒞.id_to_fun, 𝒞.comp_to_fun, function.left_id, function.right_id]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='function.left_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.right_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='auto_param.{0} (∀ {α : Type u} (I : (λ (α : Type u), c α) α), @eq.{u+1} (α → α) (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 α α I I (@category_theory.bundled_hom.id.{u} (λ (α : Type u), c α) hom 𝒞 α I)) (@id.{u+1} α)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='auto_param.{0} (∀ {α β γ : Type u} (Iα : (λ (α : Type u), c α) α) (Iβ : (λ (α : Type u), c α) β) (Iγ : (λ (α : Type u), c α) γ) (f : hom α β Iα Iβ) (g : hom β γ Iβ Iγ), @eq.{u+1} (α → γ) (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 α γ Iα Iγ (@category_theory.bundled_hom.comp.{u} (λ (α : Type u), c α) hom 𝒞 α β γ Iα Iβ Iγ g f)) (@function.comp.{u+1 u+1 u+1} α β γ (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 β γ Iβ Iγ g) (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 α β Iα Iβ f))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : Sort ?l_2} (f : α → β), @eq.{(imax ?l_1 ?l_2)} (α → β) (@function.comp.{?l_1 ?l_2 ?l_2} α β β (@id.{?l_2} β) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : Sort ?l_2} (f : α → β), @eq.{(imax ?l_1 ?l_2)} (α → β) (@function.comp.{?l_1 ?l_1 ?l_2} α α β f (@id.{?l_1} α)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ category_theory.category.{?l_1 u+1} (category_theory.bundled.{u u} c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  /-- A category given by `bundled_hom` is a concrete category.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  This instance generates the type-class problem bundled_hom ?m (which is why this is marked as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  `[nolint]`). Currently that is not a problem, as there are almost no instances of `bundled_hom`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[nolint] instance : concrete_category (bundled c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='category_theory.concrete_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type (u+1) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Do not report this declaration in any of the tests of `#lint`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A concrete category is a category `C` with a fixed faithful functor `forget : C ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  { forget := { obj := λ X, X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68                map := λ X Y f, 𝒞.to_fun X.str Y.str f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled_hom.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) (λ (X Y : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) X Y f) f f (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)))) trivial) (λ (X Y : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) X Y f) f f (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)))) trivial) (λ (W X Y Z : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W X) (g : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (h : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) Y Z), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) W X Y Z f g h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)))) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)))))) trivial)))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u}, @category_theory.bundled_hom.{u} c hom → Π {α β : Type u} (Iα : c α) (Iβ : c β), @hom α β Iα Iβ → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) (λ (X Y : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X X Y (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X) f) f (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) X Y f) f f (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)))) trivial) (λ (X Y : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Y f (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) Y)) f (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) X Y f) f f (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f f) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) f)))) trivial) (λ (W X Y Z : category_theory.bundled.{u u} c) (f : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W X) (g : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y) (h : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) Y Z), @eq.mpr.{0} (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true (@id.{0} (@eq.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true) (@eq.trans.{1} Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true ((λ (a a_1 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (e_1 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a a_1) (a_2 a_3 : @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (e_2 : @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a_2 a_3), @congr.{u+1 1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) Prop (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a) (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) a_1) a_2 a_3 (@congr_arg.{u+1 (max (u+1) 1)} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z → Prop) a a_1 (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z)) e_1) e_2) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W Y Z (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Y f g) h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞) W X Y Z f g h) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@eq.refl.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)))) (@propext (@eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h))) true (@eq_self_iff_true.{u+1} (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) W Z) (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) W X Z f (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞)) X Y Z g h)))))) trivial)))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69                map_id&#x27; := λ X, 𝒞.id_to_fun X.str,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled_hom.id_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → Type u} (c_1 : @category_theory.bundled_hom.{u} c hom), auto_param.{0} (∀ {α : Type u} (I : c α), @eq.{u+1} (α → α) (@category_theory.bundled_hom.to_fun.{u} c hom c_1 α α I I (@category_theory.bundled_hom.id.{u} c hom c_1 α I)) (@id.{u+1} α)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u → Type u} (c_1 : category_theory.bundled.{u u} c), auto_param.{u+1} (c (@category_theory.bundled.α.{u u} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70                map_comp&#x27; := by intros; erw 𝒞.comp_to_fun; refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='auto_param.{0} (∀ {α β γ : Type u} (Iα : (λ (α : Type u), c α) α) (Iβ : (λ (α : Type u), c α) β) (Iγ : (λ (α : Type u), c α) γ) (f : hom α β Iα Iβ) (g : hom β γ Iβ Iγ), @eq.{u+1} (α → γ) (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 α γ Iα Iγ (@category_theory.bundled_hom.comp.{u} (λ (α : Type u), c α) hom 𝒞 α β γ Iα Iβ Iγ g f)) (@function.comp.{u+1 u+1 u+1} α β γ (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 β γ Iβ Iγ g) (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞 α β Iα Iβ f))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ ∀ {X Y Z : category_theory.bundled.{u u} c}
  (f :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.bundled_hom.category.{u} c hom 𝒞))
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          X
                          Y
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X)
                          f)
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f
                             (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          Y
                          Y
                          f
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             Y))
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f
                             (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (W X Y Z : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    W
                    X)
                (g :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y)
                (h :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    Y
                    Z),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          W
                          Z)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          W
                          Y
                          Z
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             W
                             X
                             Y
                             f
                             g)
                          h)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          W
                          X
                          Z
                          f
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X
                             Y
                             Z
                             g
                             h)))
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                W
                                X
                                Y
                                Z
                                f
                                g
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h)))
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))))))
                    trivial))))
      X
      Y)
  (g :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.bundled_hom.category.{u} c hom 𝒞))
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          X
                          Y
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X)
                          f)
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f
                             (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          Y
                          Y
                          f
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             Y))
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (… Y Y f …)
                             f
                             …
                             f
                             f
                             …)
                          …))
                    trivial)
               …)))
      Y
      Z), …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom,
X Y Z : category_theory.bundled.{u u} c,
f :
  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
             (λ (X Y : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        X
                        Y)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        X
                        X
                        Y
                        (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X)
                        f)
                     f)
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f)
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f)
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           f
                           f)
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f
                           (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              X
                              Y
                              f)
                           f
                           f
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))))
                  trivial)
             (λ (X Y : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        X
                        Y)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        X
                        Y
                        Y
                        f
                        (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           Y))
                     f)
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f)
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f)
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           f
                           f)
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f
                           (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              X
                              Y
                              f)
                           f
                           f
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))))
                  trivial)
             (λ (W X Y Z : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  W
                  X)
              (g :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y)
              (h :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  Y
                  Z),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        W
                        Z)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        W
                        Y
                        Z
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           W
                           X
                           Y
                           f
                           g)
                        h)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        W
                        X
                        Z
                        f
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X
                           Y
                           Z
                           g
                           h)))
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              W
                              X
                              Y
                              Z
                              f
                              g
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h)))
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))))))
                  trivial))))
    X
    Y,
g :
  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
             (λ (X Y : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        X
                        Y)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        X
                        X
                        Y
                        (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X)
                        f)
                     f)
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f)
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f)
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           f
                           f)
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              X
                              Y
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X)
                              f)
                           f
                           (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              X
                              Y
                              f)
                           f
                           f
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))))
                  trivial)
             (λ (X Y : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        X
                        Y)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        X
                        Y
                        Y
                        f
                        (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           Y))
                     f)
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f)
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f)
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                           f
                           f)
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              X
                              Y)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Y
                              f
                              (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 Y))
                           f
                           (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              X
                              Y
                              f)
                           f
                           f
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f))))
                  trivial)
             (λ (W X Y Z : category_theory.bundled.{u u} c)
              (f :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  W
                  X)
              (g :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  X
                  Y)
              (h :
                @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                  Y
                  Z),
                @eq.mpr.{0}
                  (@eq.{u+1}
                     (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                        W
                        Z)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        W
                        Y
                        Z
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           W
                           X
                           Y
                           f
                           g)
                        h)
                     (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                        W
                        X
                        Z
                        f
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X
                           Y
                           Z
                           g
                           h)))
                  true
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        true)
                     (@eq.trans.{1} Prop
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        (@eq.{u+1}
                           (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h)))
                        true
                        ((λ
                          (a a_1 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                          (e_1 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              a
                              a_1)
                          (a_2 a_3 :
                            @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                              W
                              Z)
                          (e_2 :
                            @eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              a_2
                              a_3),
                            @congr.{u+1 1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              Prop
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a)
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a_1)
                              a_2
                              a_3
                              (@congr_arg.{u+1 (max (u+1) 1)}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z →
                                  Prop)
                                 a
                                 a_1
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z))
                                 e_1)
                              e_2)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              Y
                              Z
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Y
                                 f
                                 g)
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                              W
                              X
                              Y
                              Z
                              f
                              g
                              h)
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Z
                              f
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Z
                                 g
                                 h))
                           (@eq.refl.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))))
                        (@propext
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h)))
                           true
                           (@eq_self_iff_true.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))))))
                  trivial))))
    Y
    Z
⊢ @eq.{u+1}
    (@category_theory.has_hom.hom.{u u+1} (Type u)
       (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
          (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Z))
    (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Z)
       (@category_theory.bundled.str.{u u} c X)
       (@category_theory.bundled.str.{u u} c Z)
       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
             (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                (λ (X Y : category_theory.bundled.{u u} c)
                 (f :
                   @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                     X
                     Y),
                   @eq.mpr.{0}
                     (@eq.{u+1}
                        (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                           X
                           Y)
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X
                           X
                           Y
                           (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X)
                           f)
                        f)
                     true
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 X
                                 Y
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X)
                                 f)
                              f)
                           true)
                        (@eq.trans.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 X
                                 Y
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X)
                                 f)
                              f)
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           ((λ
                             (a a_1 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                             (e_1 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a
                                 a_1)
                             (a_2 a_3 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                             (e_2 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_2
                                 a_3),
                               @congr.{u+1 1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 Prop
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    a)
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    a_1)
                                 a_2
                                 a_3
                                 (@congr_arg.{u+1 (max (u+1) 1)}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y →
                                     Prop)
                                    a
                                    a_1
                                    (@eq.{u+1}
                                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                          (@category_theory.category_struct.to_has_hom.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.category.to_category_struct.{u u+1}
                                                (category_theory.bundled.{u u} c)
                                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                          X
                                          Y))
                                    e_1)
                                 e_2)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 X
                                 Y
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X)
                                 f)
                              f
                              (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                 X
                                 Y
                                 f)
                              f
                              f
                              (@eq.refl.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f))
                           (@propext
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f
                                 f)
                              true
                              (@eq_self_iff_true.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f))))
                     trivial)
                (λ (X Y : category_theory.bundled.{u u} c)
                 (f :
                   @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                     X
                     Y),
                   @eq.mpr.{0}
                     (@eq.{u+1}
                        (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                           X
                           Y)
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           X
                           Y
                           Y
                           f
                           (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              Y))
                        f)
                     true
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Y
                                 f
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    Y))
                              f)
                           true)
                        (@eq.trans.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Y
                                 f
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    Y))
                              f)
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                              f
                              f)
                           true
                           ((λ
                             (a a_1 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                             (e_1 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a
                                 a_1)
                             (a_2 a_3 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 X
                                 Y)
                             (e_2 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 a_2
                                 a_3),
                               @congr.{u+1 1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 Prop
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    a)
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    a_1)
                                 a_2
                                 a_3
                                 (@congr_arg.{u+1 (max (u+1) 1)}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y)
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       X
                                       Y →
                                     Prop)
                                    a
                                    a_1
                                    (@eq.{u+1}
                                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                          (@category_theory.category_struct.to_has_hom.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.category.to_category_struct.{u u+1}
                                                (category_theory.bundled.{u u} c)
                                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                          X
                                          Y))
                                    e_1)
                                 e_2)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 X
                                 Y
                                 Y
                                 f
                                 (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    Y))
                              f
                              (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                 X
                                 Y
                                 f)
                              f
                              f
                              (@eq.refl.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f))
                           (@propext
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f
                                 f)
                              true
                              (@eq_self_iff_true.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    X
                                    Y)
                                 f))))
                     trivial)
                (λ (W X Y Z : category_theory.bundled.{u u} c)
                 (f :
                   @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                     W
                     X)
                 (g :
                   @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                     X
                     Y)
                 (h :
                   @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                     Y
                     Z),
                   @eq.mpr.{0}
                     (@eq.{u+1}
                        (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                           W
                           Z)
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           W
                           Y
                           Z
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              W
                              X
                              Y
                              f
                              g)
                           h)
                        (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                           (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                           W
                           X
                           Z
                           f
                           (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                              (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                              X
                              Y
                              Z
                              g
                              h)))
                     true
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 Y
                                 Z
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Y
                                    f
                                    g)
                                 h)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h)))
                           true)
                        (@eq.trans.{1} Prop
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 Y
                                 Z
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Y
                                    f
                                    g)
                                 h)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h)))
                           (@eq.{u+1}
                              (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h)))
                           true
                           ((λ
                             (a a_1 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                             (e_1 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a
                                 a_1)
                             (a_2 a_3 :
                               @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                 W
                                 Z)
                             (e_2 :
                               @eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 a_2
                                 a_3),
                               @congr.{u+1 1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 Prop
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z)
                                    a)
                                 (@eq.{u+1}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z)
                                    a_1)
                                 a_2
                                 a_3
                                 (@congr_arg.{u+1 (max (u+1) 1)}
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z)
                                    (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category_struct.to_has_hom.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.category.to_category_struct.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                       W
                                       Z →
                                     Prop)
                                    a
                                    a_1
                                    (@eq.{u+1}
                                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                          (@category_theory.category_struct.to_has_hom.{u u+1}
                                             (category_theory.bundled.{u u} c)
                                             (@category_theory.category.to_category_struct.{u u+1}
                                                (category_theory.bundled.{u u} c)
                                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                          W
                                          Z))
                                    e_1)
                                 e_2)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 Y
                                 Z
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Y
                                    f
                                    g)
                                 h)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                 W
                                 X
                                 Y
                                 Z
                                 f
                                 g
                                 h)
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                 (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                 W
                                 X
                                 Z
                                 f
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    X
                                    Y
                                    Z
                                    g
                                    h))
                              (@eq.refl.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Z
                                    f
                                    (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                       X
                                       Y
                                       Z
                                       g
                                       h))))
                           (@propext
                              (@eq.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Z
                                    f
                                    (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                       X
                                       Y
                                       Z
                                       g
                                       h))
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Z
                                    f
                                    (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                       X
                                       Y
                                       Z
                                       g
                                       h)))
                              true
                              (@eq_self_iff_true.{u+1}
                                 (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category_struct.to_has_hom.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                    W
                                    Z)
                                 (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                    (@category_theory.category.to_category_struct.{u u+1}
                                       (category_theory.bundled.{u u} c)
                                       (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                    W
                                    X
                                    Z
                                    f
                                    (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                       (@category_theory.category.to_category_struct.{u u+1}
                                          (category_theory.bundled.{u u} c)
                                          (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                       X
                                       Y
                                       Z
                                       g
                                       h))))))
                     trivial)))
          X
          Y
          Z
          f
          g))
    (@category_theory.category_struct.comp.{u u+1} (Type u)
       (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Y)
       (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Z)
       (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞
          (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
          (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Y)
          (@category_theory.bundled.str.{u u} c X)
          (@category_theory.bundled.str.{u u} c Y)
          f)
       (@category_theory.bundled_hom.to_fun.{u} (λ (α : Type u), c α) hom 𝒞
          (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Y)
          (@coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) Z)
          (@category_theory.bundled.str.{u u} c Y)
          (@category_theory.bundled.str.{u u} c Z)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ ∀ {X Y Z : category_theory.bundled.{u u} c}
  (f :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.bundled_hom.category.{u} c hom 𝒞))
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          X
                          Y
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X)
                          f)
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f
                             (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          Y
                          Y
                          f
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             Y))
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f
                             (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (W X Y Z : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    W
                    X)
                (g :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y)
                (h :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    Y
                    Z),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          W
                          Z)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          W
                          Y
                          Z
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             W
                             X
                             Y
                             f
                             g)
                          h)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          W
                          X
                          Z
                          f
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X
                             Y
                             Z
                             g
                             h)))
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h)))
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                W
                                Z)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                Y
                                Z
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Y
                                   f
                                   g)
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                W
                                X
                                Y
                                Z
                                f
                                g
                                h)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Z
                                f
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Z
                                   g
                                   h))
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h)))
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))))))
                    trivial))))
      X
      Y)
  (g :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.bundled_hom.category.{u} c hom 𝒞))
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          X
                          Y
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X)
                          f)
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f
                             (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                X
                                Y
                                f)
                             f
                             f
                             (@eq.refl.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))
                          (@propext
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             (@eq_self_iff_true.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f))))
                    trivial)
               (λ (X Y : category_theory.bundled.{u u} c)
                (f :
                  @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                    (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                    X
                    Y),
                  @eq.mpr.{0}
                    (@eq.{u+1}
                       (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y)
                       (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                          X
                          Y
                          Y
                          f
                          (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             Y))
                       f)
                    true
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          true)
                       (@eq.trans.{1} Prop
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             f
                             f)
                          true
                          ((λ
                            (a a_1 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_1 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a
                                a_1)
                            (a_2 a_3 :
                              @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                            (e_2 :
                              @eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                a_2
                                a_3),
                              @congr.{u+1 1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_1)
                                a_2
                                a_3
                                (@congr_arg.{u+1 (max (u+1) 1)}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y →
                                    Prop)
                                   a
                                   a_1
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y))
                                   e_1)
                                e_2)
                             (… Y Y f …)
                             f
                             …
                             f
                             f
                             …)
                          …))
                    trivial)
               …)))
      Y
      Z), …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    forget_faithful := { injectivity&#x27; := by intros; apply 𝒞.hom_ext } }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom
⊢ ∀ {X Y : category_theory.bundled.{u u} c},
    @function.injective.{u+1 u+1}
      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                  (λ (X Y : category_theory.bundled.{u u} c)
                   (f :
                     @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                       X
                       Y),
                     @eq.mpr.{0}
                       (@eq.{u+1}
                          (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X
                             X
                             Y
                             (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X)
                             f)
                          f)
                       true
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   X
                                   Y
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X)
                                   f)
                                f)
                             true)
                          (@eq.trans.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   X
                                   Y
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X)
                                   f)
                                f)
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             ((λ
                               (a a_1 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                               (e_1 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a
                                   a_1)
                               (a_2 a_3 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                               (e_2 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_2
                                   a_3),
                                 @congr.{u+1 1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   Prop
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a)
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a_1)
                                   a_2
                                   a_3
                                   (@congr_arg.{u+1 (max (u+1) 1)}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y →
                                       Prop)
                                      a
                                      a_1
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y))
                                      e_1)
                                   e_2)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   X
                                   Y
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X)
                                   f)
                                f
                                (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                   X
                                   Y
                                   f)
                                f
                                f
                                (@eq.refl.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f))
                             (@propext
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f
                                   f)
                                true
                                (@eq_self_iff_true.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f))))
                       trivial)
                  (λ (X Y : category_theory.bundled.{u u} c)
                   (f :
                     @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                       X
                       Y),
                     @eq.mpr.{0}
                       (@eq.{u+1}
                          (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                             X
                             Y)
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             X
                             Y
                             Y
                             f
                             (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                Y))
                          f)
                       true
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Y
                                   f
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      Y))
                                f)
                             true)
                          (@eq.trans.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Y
                                   f
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      Y))
                                f)
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                                f
                                f)
                             true
                             ((λ
                               (a a_1 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                               (e_1 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a
                                   a_1)
                               (a_2 a_3 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   X
                                   Y)
                               (e_2 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   a_2
                                   a_3),
                                 @congr.{u+1 1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   Prop
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a)
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a_1)
                                   a_2
                                   a_3
                                   (@congr_arg.{u+1 (max (u+1) 1)}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y →
                                       Prop)
                                      a
                                      a_1
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y))
                                      e_1)
                                   e_2)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X
                                   Y
                                   Y
                                   f
                                   (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      Y))
                                f
                                (@category_theory.category.comp_id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                   X
                                   Y
                                   f)
                                f
                                f
                                (@eq.refl.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f))
                             (@propext
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f
                                   f)
                                true
                                (@eq_self_iff_true.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f))))
                       trivial)
                  (λ (W X Y Z : category_theory.bundled.{u u} c)
                   (f :
                     @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                       W
                       X)
                   (g :
                     @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                       X
                       Y)
                   (h :
                     @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                       (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                       Y
                       Z),
                     @eq.mpr.{0}
                       (@eq.{u+1}
                          (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                             W
                             Z)
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             W
                             Y
                             Z
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                W
                                X
                                Y
                                f
                                g)
                             h)
                          (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                             W
                             X
                             Z
                             f
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Z
                                g
                                h)))
                       true
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   Y
                                   Z
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Y
                                      f
                                      g)
                                   h)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h)))
                             true)
                          (@eq.trans.{1} Prop
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   Y
                                   Z
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Y
                                      f
                                      g)
                                   h)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h)))
                             (@eq.{u+1}
                                (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h)))
                             true
                             ((λ
                               (a a_1 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                               (e_1 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a
                                   a_1)
                               (a_2 a_3 :
                                 @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category_struct.to_has_hom.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                   W
                                   Z)
                               (e_2 :
                                 @eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   a_2
                                   a_3),
                                 @congr.{u+1 1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   Prop
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z)
                                      a)
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z)
                                      a_1)
                                   a_2
                                   a_3
                                   (@congr_arg.{u+1 (max (u+1) 1)}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z)
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         W
                                         Z →
                                       Prop)
                                      a
                                      a_1
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            W
                                            Z))
                                      e_1)
                                   e_2)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   Y
                                   Z
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Y
                                      f
                                      g)
                                   h)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@category_theory.category.assoc.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                   W
                                   X
                                   Y
                                   Z
                                   f
                                   g
                                   h)
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   W
                                   X
                                   Z
                                   f
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Z
                                      g
                                      h))
                                (@eq.refl.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Z
                                      f
                                      (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X
                                         Y
                                         Z
                                         g
                                         h))))
                             (@propext
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Z
                                      f
                                      (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X
                                         Y
                                         Z
                                         g
                                         h))
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Z
                                      f
                                      (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X
                                         Y
                                         Z
                                         g
                                         h)))
                                true
                                (@eq_self_iff_true.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      W
                                      Z)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      W
                                      X
                                      Z
                                      f
                                      (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X
                                         Y
                                         Z
                                         g
                                         h))))))
                       trivial))))
         X
         Y)
      (@category_theory.has_hom.hom.{u u+1} (Type u)
         (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
            (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
         ((λ (X : category_theory.bundled.{u u} c),
             @coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
            X)
         ((λ (X : category_theory.bundled.{u u} c),
             @coe_sort.{u+2 u+2} (category_theory.bundled.{u u} c) (@category_theory.bundled.has_coe_to_sort.{u u} c) X)
            Y))
      ((λ (X Y : category_theory.bundled.{u u} c)
        (f :
          @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.category.mk.{u u+1} (category_theory.bundled.{u u} c)
                     (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                        (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                     (λ (X Y : category_theory.bundled.{u u} c)
                      (f :
                        @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y),
                        @eq.mpr.{0}
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                X
                                Y
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   X)
                                f)
                             f)
                          true
                          (@id.{0}
                             (@eq.{1} Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      X
                                      Y
                                      (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X)
                                      f)
                                   f)
                                true)
                             (@eq.trans.{1} Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      X
                                      Y
                                      (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X)
                                      f)
                                   f)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f
                                   f)
                                true
                                ((λ
                                  (a a_1 :
                                    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                  (e_1 :
                                    @eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a
                                      a_1)
                                  (a_2 a_3 :
                                    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                  (e_2 :
                                    @eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a_2
                                      a_3),
                                    @congr.{u+1 1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      Prop
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         a)
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         a_1)
                                      a_2
                                      a_3
                                      (@congr_arg.{u+1 (max (u+1) 1)}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y →
                                          Prop)
                                         a
                                         a_1
                                         (@eq.{u+1}
                                            (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                               (@category_theory.category_struct.to_has_hom.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.category.to_category_struct.{u u+1}
                                                     (category_theory.bundled.{u u} c)
                                                     (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                               X
                                               Y))
                                         e_1)
                                      e_2)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      X
                                      Y
                                      (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         X)
                                      f)
                                   f
                                   (@category_theory.category.id_comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)
                                      X
                                      Y
                                      f)
                                   f
                                   f
                                   (@eq.refl.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      f))
                                (@propext
                                   (@eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      f
                                      f)
                                   true
                                   (@eq_self_iff_true.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      f))))
                          trivial)
                     (λ (X Y : category_theory.bundled.{u u} c)
                      (f :
                        @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                          (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                             (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                          X
                          Y),
                        @eq.mpr.{0}
                          (@eq.{u+1}
                             (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                X
                                Y)
                             (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                X
                                Y
                                Y
                                f
                                (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                   (@category_theory.category.to_category_struct.{u u+1}
                                      (category_theory.bundled.{u u} c)
                                      (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                   Y))
                             f)
                          true
                          (@id.{0}
                             (@eq.{1} Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Y
                                      f
                                      (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         Y))
                                   f)
                                true)
                             (@eq.trans.{1} Prop
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   (@category_theory.category_struct.comp.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category.to_category_struct.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                      X
                                      Y
                                      Y
                                      f
                                      (@category_theory.category_struct.id.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞))
                                         Y))
                                   f)
                                (@eq.{u+1}
                                   (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                   f
                                   f)
                                true
                                ((λ
                                  (a a_1 :
                                    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                  (e_1 :
                                    @eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a
                                      a_1)
                                  (a_2 a_3 :
                                    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                      (@category_theory.category_struct.to_has_hom.{u u+1}
                                         (category_theory.bundled.{u u} c)
                                         (@category_theory.category.to_category_struct.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                      X
                                      Y)
                                  (e_2 :
                                    @eq.{u+1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      a_2
                                      a_3),
                                    @congr.{u+1 1}
                                      (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                         (@category_theory.category_struct.to_has_hom.{u u+1}
                                            (category_theory.bundled.{u u} c)
                                            (@category_theory.category.to_category_struct.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                         X
                                         Y)
                                      Prop
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         a)
                                      (@eq.{u+1}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         a_1)
                                      a_2
                                      a_3
                                      (@congr_arg.{u+1 (max (u+1) 1)}
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1}
                                               (category_theory.bundled.{u u} c)
                                               (@category_theory.category.to_category_struct.{u u+1}
                                                  (category_theory.bundled.{u u} c)
                                                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
                                            X
                                            Y)
                                         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
                                            (@category_theory.category_struct.to_has_hom.{u u+1} … …)
                                            X
                                            Y →
                                          Prop)
                                         a
                                         a_1
                                         …
                                         e_1)
                                      e_2)
                                   …
                                   f
                                   …
                                   f
                                   f
                                   …)
                                …))
                          trivial)
                     …)))
            X
            Y), …)
         X
         Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  variables {hom}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  local attribute [instance] concrete_category.has_coe_to_fun</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.concrete_category.has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} C] {X Y : C}, has_coe_to_fun.{u+1 u+1} (@category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1))) X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Usually a bundled hom structure already has a coercion to function
that works with different universes. So we don&#x27;t use this as a global instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  /-- A version of `has_forget₂.mk&#x27;` for categories defined using `@bundled_hom`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  def mk_has_forget₂ {d : Type u → Type u} {hom_d : Π ⦃α β : Type u⦄ (Iα : d α) (Iβ : d β), Type u}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    [bundled_hom hom_d] (obj : Π ⦃α⦄, c α → d α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.bundled_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hom_d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {c : Type u → Type u}, (Π ⦃α β : Type u⦄, c α → c β → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π ⦃α β : Type u⦄, d α → d β → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Class for bundled homs. Note that the arguments order follows that of lemmas for `monoid_hom`.
This way we can use `⟨@monoid_hom.to_fun, @monoid_hom.id ...⟩` in an instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    (map : Π {X Y : bundled c}, (X ⟶ Y) → ((bundled.map obj X) ⟶ (bundled.map obj Y)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.bundled.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {c d : Type u → Type v}, (Π {α : Type u}, c α → d α) → category_theory.bundled.{u v} c → category_theory.bundled.{u v} d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π ⦃α : Type u⦄, c α → d α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {c d : Type u → Type v}, (Π {α : Type u}, c α → d α) → category_theory.bundled.{u v} c → category_theory.bundled.{u v} d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π ⦃α : Type u⦄, c α → d α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Map over the bundled structure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Map over the bundled structure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    (h_map : ∀ {X Y : bundled c} (f : X ⟶ Y), (map f : X → Y) = f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {X Y : category_theory.bundled.{u u} c}, @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.bundled_hom.category.{u} (λ (α : Type u), d α) hom_d _inst_1))) (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X) (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    : has_forget₂ (bundled c) (bundled d) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.has_forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`has_forget₂ C D`, where `C` and `D` are both concrete categories, provides a functor
`forget₂ C D : C ⥤ C` and a proof that `forget₂ ⋙ (forget D) = forget C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  has_forget₂.mk&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_forget₂.mk&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C D : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] (obj : C → D), (∀ (X : C), @eq.{u+2} (Type u) (@category_theory.functor.obj.{u u u+1 u+1} D (@category_theory.concrete_category.to_category.{u} D _inst_2) (Type u) category_theory.types.{u} (@category_theory.forget.{u} D _inst_2) (obj X)) (@category_theory.functor.obj.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u} (@category_theory.forget.{u} C _inst_1) X)) → Π (map : Π {X Y : C}, @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1))) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D (@category_theory.concrete_category.to_category.{u} D _inst_2))) (obj X) (obj Y)), (∀ {X Y : C} {f : @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1))) X Y}, @heq.{u+1} (@category_theory.has_hom.hom.{u u+1} (Type u) (@category_theory.category_struct.to_has_hom.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})) (@category_theory.functor.obj.{u u u+1 u+1} D (@category_theory.concrete_category.to_category.{u} D _inst_2) (Type u) category_theory.types.{u} (@category_theory.forget.{u} D _inst_2) (obj X)) (@category_theory.functor.obj.{u u u+1 u+1} D (@category_theory.concrete_category.to_category.{u} D _inst_2) (Type u) category_theory.types.{u} (@category_theory.forget.{u} D _inst_2) (obj Y))) (@category_theory.functor.map.{u u u+1 u+1} D (@category_theory.concrete_category.to_category.{u} D _inst_2) (Type u) category_theory.types.{u} (@category_theory.forget.{u} D _inst_2) (obj X) (obj Y) (@map X Y f)) (@category_theory.has_hom.hom.{u u+1} (Type u) (@category_theory.category_struct.to_has_hom.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})) (@category_theory.functor.obj.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u} (@category_theory.forget.{u} C _inst_1) X) (@category_theory.functor.obj.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u} (@category_theory.forget.{u} C _inst_1) Y)) (@category_theory.functor.map.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u} (@category_theory.forget.{u} C _inst_1) X Y f)) → @category_theory.has_forget₂.{u} C D _inst_1 _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='In order to construct a “partially forgetting” functor, we do not need to verify functor laws;
it suffices to ensure that compositions agree with `forget₂ C D ⋙ forget D = forget C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    (bundled.map @obj)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.bundled.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {c d : Type u → Type v}, (Π {α : Type u}, c α → d α) → category_theory.bundled.{u v} c → category_theory.bundled.{u v} d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π ⦃α : Type u⦄, c α → d α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Map over the bundled structure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    (λ _, rfl)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='category_theory.bundled.{u u} c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    @map</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {X Y : category_theory.bundled.{u u} c}, @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c) (@category_theory.bundled_hom.category.{u} c hom 𝒞))) X Y → @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α)) (@category_theory.bundled_hom.category.{u} (λ (α : Type u), d α) hom_d _inst_1))) (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X) (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    (by intros; apply heq_of_eq; apply h_map)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='heq_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a a&#x27; : α}, @eq.{u+1} α a a&#x27; → @heq.{u+1} α a α a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='c : Type u → Type u,
hom : Π ⦃α β : Type u⦄, c α → c β → Type u,
𝒞 : @category_theory.bundled_hom.{u} (λ (α : Type u), c α) hom,
d : Type u → Type u,
hom_d : Π ⦃α β : Type u⦄, d α → d β → Type u,
_inst_1 : @category_theory.bundled_hom.{u} (λ (α : Type u), d α) hom_d,
obj : Π ⦃α : Type u⦄, c α → d α,
map :
  Π {X Y : category_theory.bundled.{u u} c},
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
      X
      Y →
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α))
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α))
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α))
            (@category_theory.bundled_hom.category.{u} (λ (α : Type u), d α) hom_d _inst_1)))
      (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X)
      (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y),
h_map :
  ∀ {X Y : category_theory.bundled.{u u} c}
  (f :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
      X
      Y),
    @eq.{u+1}
      (@has_coe_to_fun.F.{u+1 u+1}
         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α))
            (@category_theory.category_struct.to_has_hom.{u u+1}
               (category_theory.bundled.{u u} (λ (α : Type u), d α))
               (@category_theory.category.to_category_struct.{u u+1}
                  (category_theory.bundled.{u u} (λ (α : Type u), d α))
                  (@category_theory.bundled_hom.category.{u} (λ (α : Type u), d α) hom_d _inst_1)))
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y))
         (@category_theory.concrete_category.has_coe_to_fun.{u} (category_theory.bundled.{u u} (λ (α : Type u), d α))
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} (λ (α : Type u), d α) hom_d _inst_1)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y))
         (@map X Y f))
      (@coe_fn.{u+1 u+1}
         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} (λ (α : Type u), d α))
            (@category_theory.category_struct.to_has_hom.{u u+1}
               (category_theory.bundled.{u u} (λ (α : Type u), d α))
               (@category_theory.category.to_category_struct.{u u+1}
                  (category_theory.bundled.{u u} (λ (α : Type u), d α))
                  (@category_theory.bundled_hom.category.{u} (λ (α : Type u), d α) hom_d _inst_1)))
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y))
         (@category_theory.concrete_category.has_coe_to_fun.{u} (category_theory.bundled.{u u} (λ (α : Type u), d α))
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} (λ (α : Type u), d α) hom_d _inst_1)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj X)
            (@category_theory.bundled.map.{u u} (λ (α : Type u), c α) (λ (α : Type u), d α) obj Y))
         (@map X Y f))
      (@coe_fn.{u+1 u+1}
         (@category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
               (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
                  (@category_theory.bundled_hom.category.{u} c hom 𝒞)))
            X
            Y)
         (@category_theory.concrete_category.has_coe_to_fun.{u} (category_theory.bundled.{u u} c)
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞)
            X
            Y)
         f)
⊢ ∀ {X Y : category_theory.bundled.{u u} c}
  {f :
    @category_theory.has_hom.hom.{u u+1} (category_theory.bundled.{u u} c)
      (@category_theory.category_struct.to_has_hom.{u u+1} (category_theory.bundled.{u u} c)
         (@category_theory.category.to_category_struct.{u u+1} (category_theory.bundled.{u u} c)
            (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} c)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))))
      X
      Y},
    @heq.{u+1}
      (@category_theory.has_hom.hom.{u u+1} (Type u)
         (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
            (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
         (@category_theory.functor.obj.{u u u+1 u+1} (category_theory.bundled.{u u} d)
            (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} d)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
            (Type u)
            category_theory.types.{u}
            (@category_theory.forget.{u} (category_theory.bundled.{u u} d)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
            (@category_theory.bundled.map.{u u} c d obj X))
         (@category_theory.functor.obj.{u u u+1 u+1} (category_theory.bundled.{u u} d)
            (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} d)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
            (Type u)
            category_theory.types.{u}
            (@category_theory.forget.{u} (category_theory.bundled.{u u} d)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
            (@category_theory.bundled.map.{u u} c d obj Y)))
      (@category_theory.functor.map.{u u u+1 u+1} (category_theory.bundled.{u u} d)
         (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} d)
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
         (Type u)
         category_theory.types.{u}
         (@category_theory.forget.{u} (category_theory.bundled.{u u} d)
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} d hom_d _inst_1))
         (@category_theory.bundled.map.{u u} c d obj X)
         (@category_theory.bundled.map.{u u} c d obj Y)
         (@map X Y f))
      (@category_theory.has_hom.hom.{u u+1} (Type u)
         (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
            (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
         (@category_theory.functor.obj.{u u u+1 u+1} (category_theory.bundled.{u u} c)
            (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} c)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
            (Type u)
            category_theory.types.{u}
            (@category_theory.forget.{u} (category_theory.bundled.{u u} c)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
            X)
         (@category_theory.functor.obj.{u u u+1 u+1} (category_theory.bundled.{u u} c)
            (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} c)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
            (Type u)
            category_theory.types.{u}
            (@category_theory.forget.{u} (category_theory.bundled.{u u} c)
               (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
            Y))
      (@category_theory.functor.map.{u u u+1 u+1} (category_theory.bundled.{u u} c)
         (@category_theory.concrete_category.to_category.{u} (category_theory.bundled.{u u} c)
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
         (Type u)
         category_theory.types.{u}
         (@category_theory.forget.{u} (category_theory.bundled.{u u} c)
            (@category_theory.bundled_hom.category_theory.concrete_category.{u} c hom 𝒞))
         X
         Y
         f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  end bundled_hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  end category_theory</code></pre>
</body>