<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison, Reid Barton</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.limits.limits</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  universes v u -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace category_theory.limits.types</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  variables {J : Type u} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  def limit (F : J ⥤ Type u) : cone F :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  { X := F.sections,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19    π := { app := λ j u, u.val j } }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  local attribute [elab_simple] congr_fun</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated from left to right, and without propagating information from the expected type to its arguments'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  def limit_is_limit (F : J ⥤ Type u) : is_limit (limit F) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  { lift := λ s v, ⟨λ j, s.π.app j v, λ j j&#x27; f, congr_fun (cone.w s f) _⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    uniq&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      intros, ext x, apply subtype.eq, ext j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27      exact congr_fun (w j) x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : α → Type u} {f g : Π (x : α), β x}, @eq.{u+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{u+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{u+1} (@category_theory.has_hom.hom.{u u+1} (Type u) (@category_theory.category_struct.to_has_hom.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})) (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s) (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)) (@category_theory.category_struct.comp.{u u+1} (Type u) (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}) (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s) (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)) (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) m (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F))) F (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)) j)) (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)) F (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
s : @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F,
m :
  @category_theory.has_hom.hom.{u u+1} (Type u)
    (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
       (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
    (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
    (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.limits.types.limit.{u} J _inst_1 F)),
w :
  ∀ (j : J),
    @eq.{u+1}
      (@category_theory.has_hom.hom.{u u+1} (Type u)
         (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
            (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
      (@category_theory.category_struct.comp.{u u+1} (Type u)
         (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@category_theory.limits.types.limit.{u} J _inst_1 F))
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
         m
         (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
            (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
               (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
                  (@category_theory.limits.types.limit.{u} J _inst_1 F)))
            F
            (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
               (@category_theory.limits.types.limit.{u} J _inst_1 F))
            j))
      (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
         (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
            (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
         F
         (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         j),
x : @category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s,
j : J
⊢ @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
    (@subtype.val.{u+1}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       (λ (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
          @has_mem.mem.{u u}
            (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            (set.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            (@set.has_mem.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            x
            (@category_theory.functor.sections.{u u u} J _inst_1 F))
       (m x)
       j)
    (@subtype.val.{u+1}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       (λ (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
          @has_mem.mem.{u u}
            (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            (set.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            (@set.has_mem.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            x
            (@category_theory.functor.sections.{u u u} J _inst_1 F))
       (@subtype.mk.{u+1}
          (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          (λ
           (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
             @has_mem.mem.{u u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               (set.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               (@set.has_mem.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               x
               (@category_theory.functor.sections.{u u u} J _inst_1 F))
          (λ (j : J),
             @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                  (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
               F
               (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
               j
               x)
          (λ (j j&#x27; : J)
           (f :
             @category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               j
               j&#x27;),
             @congr_fun.{u+1 u+1}
               (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                     (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                  j)
               (λ
                (x :
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                       (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                    j), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j&#x27;)
               (@category_theory.category_struct.comp.{u u+1} (Type u)
                  (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                     (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                        (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                     j)
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j&#x27;)
                  (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                     (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                        (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                     F
                     (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
                     j)
                  (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j j&#x27; f))
               (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                     (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                  F
                  (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
                  j&#x27;)
               (@category_theory.limits.cone.w.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s j j&#x27; f)
               x))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
s : @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F,
m :
  @category_theory.has_hom.hom.{u u+1} (Type u)
    (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
       (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
    (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
    (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.limits.types.limit.{u} J _inst_1 F)),
w :
  ∀ (j : J),
    @eq.{u+1}
      (@category_theory.has_hom.hom.{u u+1} (Type u)
         (@category_theory.category_struct.to_has_hom.{u u+1} (Type u)
            (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u}))
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
      (@category_theory.category_struct.comp.{u u+1} (Type u)
         (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@category_theory.limits.types.limit.{u} J _inst_1 F))
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
         m
         (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
            (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
               (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
               (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
                  (@category_theory.limits.types.limit.{u} J _inst_1 F)))
            F
            (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
               (@category_theory.limits.types.limit.{u} J _inst_1 F))
            j))
      (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
         (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
            (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
            (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
         F
         (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
         j),
x : @category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s,
j : J
⊢ @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
    (@subtype.val.{u+1}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       (λ (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
          @has_mem.mem.{u u}
            (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            (set.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            (@set.has_mem.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            x
            (@category_theory.functor.sections.{u u u} J _inst_1 F))
       (m x)
       j)
    (@subtype.val.{u+1}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       (λ (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
          @has_mem.mem.{u u}
            (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            (set.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            (@set.has_mem.{u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
            x
            (@category_theory.functor.sections.{u u u} J _inst_1 F))
       (@subtype.mk.{u+1}
          (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          (λ
           (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
             @has_mem.mem.{u u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               (set.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               (@set.has_mem.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               x
               (@category_theory.functor.sections.{u u u} J _inst_1 F))
          (λ (j : J),
             @category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
               (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                  (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                  (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
               F
               (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
               j
               x)
          (λ (j j&#x27; : J)
           (f :
             @category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               j
               j&#x27;),
             @congr_fun.{u+1 u+1}
               (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                     (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                  j)
               (λ
                (x :
                  @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                    (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                       (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                       (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                    j), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j&#x27;)
               (@category_theory.category_struct.comp.{u u+1} (Type u)
                  (@category_theory.category.to_category_struct.{u u+1} (Type u) category_theory.types.{u})
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                     (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                        (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                     j)
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                  (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j&#x27;)
                  (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                     (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                        (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                        (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                     F
                     (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
                     j)
                  (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j j&#x27; f))
               (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}
                  (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
                     (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
                     (@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s))
                  F
                  (@category_theory.limits.cone.π.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s)
                  j&#x27;)
               (@category_theory.limits.cone.w.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F s j j&#x27; f)
               x))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  instance : has_limits.{u} (Type u) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  { has_limits_of_shape := λ J 𝒥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{u} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    { has_limit := λ F, by exactI { cone := limit F, is_limit := limit_is_limit F } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.types.limit_is_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.is_limit.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u u u u+1} J 𝒥 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='J : Type u,
𝒥 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J 𝒥 (Type u) category_theory.types.{u}
⊢ @category_theory.limits.has_limit.{u u+1} J 𝒥 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  @[simp] lemma types_limit (F : J ⥤ Type u) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    limits.limit F = {u : Π j, F.obj j // ∀ {j j&#x27;} f, F.map f (u j) = u j&#x27;} := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 435, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D], @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type (u+1)} {a : α}, @eq.{u+2} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  @[simp] lemma types_limit_π (F : J ⥤ Type u) (j : J) (g : (limit F).X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    limit.π F j g = g.val j := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 437, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (j : J), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  @[simp] lemma types_limit_pre</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    (F : J ⥤ Type u) {K : Type u} [𝒦 : small_category K] (E : K ⥤ J) (g : (limit F).X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type u) [_inst_2 : category_theory.category.{u u} D], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    limit.pre F E g = (⟨λ k, g.val (E.obj k), by obviously⟩ : (limit (E ⋙ F)).X) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.pre'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 515, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J K : Type v} [_inst_1 : category_theory.small_category.{v} J] [_inst_2 : category_theory.small_category.{v} K] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (E : @category_theory.functor.{v v v v} K _inst_2 J _inst_1) [_inst_4 : @category_theory.limits.has_limit.{v u} K _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v v u} K _inst_2 J _inst_1 C 𝒞 E F)], @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.limits.limit.{v u} K _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v v u} K _inst_2 J _inst_1 C 𝒞 E F) _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@category_theory.limits.types.limit.{u} J _inst_1 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type u} [_inst_2 : category_theory.category.{u u} D], @category_theory.functor.{u u u u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type u} [𝒟 : category_theory.category.{u u} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u} C 𝒞 D 𝒟 → @category_theory.functor.{u u u u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
K : Type u,
𝒦 : category_theory.small_category.{u} K,
E : @category_theory.functor.{u u u u} K 𝒦 J _inst_1,
g :
  @category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
    (@category_theory.limits.types.limit.{u} J _inst_1 F)
⊢ @has_mem.mem.{u u}
    (Π (j : K),
       @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u}
         (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F)
         j)
    (set.{u}
       (Π (j : K),
          @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u}
            (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F)
            j))
    (@set.has_mem.{u}
       (Π (j : K),
          @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u}
            (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F)
            j))
    (λ (k : K),
       @subtype.val.{u+1}
         (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
         (λ
          (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
            @has_mem.mem.{u u}
              (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
              (set.{u}
                 (Π (j : J),
                    @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
              (@set.has_mem.{u}
                 (Π (j : J),
                    @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
              x
              (@category_theory.functor.sections.{u u u} J _inst_1 F))
         g
         (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E k))
    (@category_theory.functor.sections.{u u u} K 𝒦
       (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  @[simp] lemma types_limit_map {F G : J ⥤ Type u} (α : F ⟶ G) (g : (limit F).X) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    (lim.map α : (limit F).X → (limit G).X) g =</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    (⟨λ j, (α.app j) (g.val j), λ j j&#x27; f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44      by {rw ←functor_to_types.naturality, dsimp, rw ←(g.property f)}⟩ : (limit G).X) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F G : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
α :
  @category_theory.has_hom.hom.{u u+1}
    (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
    (@category_theory.category_struct.to_has_hom.{u u+1}
       (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
       (@category_theory.category.to_category_struct.{u u+1}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})))
    F
    G,
g :
  @category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F
    (@category_theory.limits.types.limit.{u} J _inst_1 F),
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{u u} J
    (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1))
    j
    j&#x27;
⊢ @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j&#x27;)
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α j&#x27;
       (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j j&#x27; f
          (@subtype.val.{u+1}
             (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             (λ
              (x :
                Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
                @has_mem.mem.{u u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                  (set.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  (@set.has_mem.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  x
                  (@category_theory.functor.sections.{u u u} J _inst_1 F))
             g
             j)))
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α j&#x27;
       (@subtype.val.{u+1}
          (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          (λ
           (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
             @has_mem.mem.{u u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               (set.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               (@set.has_mem.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               x
               (@category_theory.functor.sections.{u u u} J _inst_1 F))
          g
          j&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  @[simp] lemma types_limit_lift (F : J ⥤ Type u) (c : cone F) (x : c.X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    limit.lift F c x = (⟨λ j, c.π.app j x, λ j j&#x27; f, congr_fun (cone.w c f) x⟩ : (limit F).X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone.w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.types.limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{u u+1} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f g : Π (x : α), β x}, @eq.{(imax u v)} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) {j j&#x27; : J} (f : @category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) j j&#x27;), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  def colimit (F : J ⥤ Type u) : cocone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
K : Type u,
𝒦 : category_theory.small_category.{u} K,
E : @category_theory.functor.{u u u u} K 𝒦 J _inst_1,
j j&#x27; : K,
f :
  @category_theory.has_hom.hom.{u u} K
    (@category_theory.category_struct.to_has_hom.{u u} K (@category_theory.category.to_category_struct.{u u} K 𝒦))
    j
    j&#x27;,
g_val : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j,
g_property :
  @has_mem.mem.{u u}
    (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
    (set.{u} (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
    (@set.has_mem.{u}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
    g_val
    (@category_theory.functor.sections.{u u u} J _inst_1 F)
⊢ @eq.{u+1}
    (@category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u}
       (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F)
       j&#x27;)
    (@category_theory.functor.map.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u}
       (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F)
       j
       j&#x27;
       f
       ((λ (k : K),
           @subtype.val.{u+1}
             (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             (λ
              (x :
                Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
                @has_mem.mem.{u u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                  (set.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  (@set.has_mem.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  x
                  (@category_theory.functor.sections.{u u u} J _inst_1 F))
             (@subtype.mk.{u+1}
                (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                (λ
                 (x :
                   Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
                   @has_mem.mem.{u u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                     (set.{u}
                        (Π (j : J),
                           @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                     (@set.has_mem.{u}
                        (Π (j : J),
                           @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                     x
                     (@category_theory.functor.sections.{u u u} J _inst_1 F))
                g_val
                g_property)
             (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E k))
          j))
    ((λ (k : K),
        @subtype.val.{u+1}
          (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          (λ
           (x : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
             @has_mem.mem.{u u}
               (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               (set.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               (@set.has_mem.{u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
               x
               (@category_theory.functor.sections.{u u u} J _inst_1 F))
          (@subtype.mk.{u+1}
             (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             (λ
              (x :
                Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
                @has_mem.mem.{u u}
                  (Π (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                  (set.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  (@set.has_mem.{u}
                     (Π (j : J),
                        @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
                  x
                  (@category_theory.functor.sections.{u u u} J _inst_1 F))
             g_val
             g_property)
          (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E k))
       j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  { X := @quot (Σ j, F.obj j) (λ p p&#x27;, ∃ f : p.1 ⟶ p&#x27;.1, p&#x27;.2 = F.map f p.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='quot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u}, (α → α → Prop) → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type u) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type u) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D], @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{u u} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
K : Type u,
𝒦 : category_theory.small_category.{u} K,
E : @category_theory.functor.{u u u u} K 𝒦 J _inst_1,
j j&#x27; : K,
f :
  @category_theory.has_hom.hom.{u u} K
    (@category_theory.category_struct.to_has_hom.{u u} K (@category_theory.category.to_category_struct.{u u} K 𝒦))
    j
    j&#x27;,
g_val : Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j,
g_property :
  @has_mem.mem.{u u}
    (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
    (set.{u} (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
    (@set.has_mem.{u}
       (Π (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j))
    g_val
    (@category_theory.functor.sections.{u u u} J _inst_1 F)
⊢ @eq.{u+1}
    (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E j&#x27;))
    (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E j)
       (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E j&#x27;)
       (@category_theory.functor.map.{u u u u} K 𝒦 J _inst_1 E j j&#x27; f)
       (g_val (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E j)))
    (g_val (@category_theory.functor.obj.{u u u u} K 𝒦 J _inst_1 E j&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    ι :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    { app := λ j x, quot.mk _ ⟨j, x⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} (r : α → α → Prop), α → @quot.{u} α r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55      naturality&#x27; := λ j j&#x27; f, funext $ λ x, eq.symm (quot.sound ⟨f, rfl⟩) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, @eq.{u} α a b → @eq.{u} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → @eq.{u} (@quot.{u} α r) (@quot.mk.{u} α r a) (@quot.mk.{u} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  local attribute [elab_with_expected_type] quot.lift</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='quot.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Π {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β), (∀ (a b : α), r a b → @eq.{v} β (f a) (f b)) → @quot.{u} α r → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated using information about the expected type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  def colimit_is_colimit (F : J ⥤ Type u) : is_colimit (colimit F) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  { desc := λ s, quot.lift (λ (p : Σ j, F.obj j), s.ι.app p.1 p.2)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61      (assume ⟨j, x⟩ ⟨j&#x27;, x&#x27;⟩ ⟨f, hf⟩, by rw hf; exact (congr_fun (cocone.w s f) x).symm) }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  instance : has_colimits.{u} (Type u) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  { has_colimits_of_shape := λ J 𝒥,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    { has_colimit := λ F, by exactI { cocone := colimit F, is_colimit := colimit_is_colimit F } } }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but uses all variables in the context
 for typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exactI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] lemma types_colimit (F : J ⥤ Type u) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    limits.colimit F = @quot (Σ j, F.obj j) (λ p p&#x27;, ∃ f : p.1 ⟶ p&#x27;.1, p&#x27;.2 = F.map f p.2) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 696, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F], C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (u+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, (α → α → Prop) → Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Type u) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type u) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D], @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{u u} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type (u+1)} {a : α}, @eq.{u+2} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  @[simp] lemma types_colimit_ι (F : J ⥤ Type u) (j : J) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70    colimit.ι F j = λ x, quot.mk _ ⟨j, x⟩ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 698, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} (r : α → α → Prop), α → @quot.{u} α r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  @[simp] lemma types_colimit_pre</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (F : J ⥤ Type u) {K : Type u} [𝒦 : small_category K] (E : K ⥤ J) (g : (colimit (E ⋙ F)).X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.types.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type u) [_inst_2 : category_theory.category.{u u} D], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type u} [𝒟 : category_theory.category.{u u} D] {E : Type (u+1)} [ℰ : category_theory.category.{u u+1} E], @category_theory.functor.{u u u u} C 𝒞 D 𝒟 → @category_theory.functor.{u u u u+1} D 𝒟 E ℰ → @category_theory.functor.{u u u u+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    colimit.pre F E =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.pre'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 787, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J K : Type v} [_inst_1 : category_theory.small_category.{v} J] [_inst_2 : category_theory.small_category.{v} K] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (E : @category_theory.functor.{v v v v} K _inst_2 J _inst_1) [_inst_4 : @category_theory.limits.has_colimit.{v u} K _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v v u} K _inst_2 J _inst_1 C 𝒞 E F)], @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.colimit.{v u} K _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v v u} K _inst_2 J _inst_1 C 𝒞 E F) _inst_4) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    quot.lift (λ p, quot.mk _ ⟨E.obj p.1, p.2⟩) (λ p p&#x27; ⟨f, h⟩, quot.sound ⟨E.map f, h⟩) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β), (∀ (a b : α), r a b → @eq.{v} β (f a) (f b)) → @quot.{u} α r → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@sigma.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} (r : α → α → Prop), α → @quot.{u} α r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type u} [_inst_2 : category_theory.category.{u u} D], @category_theory.functor.{u u u u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@sigma.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@sigma.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (@category_theory.has_hom.hom.{u u} K (@category_theory.category_struct.to_has_hom.{u u} K (@category_theory.category.to_category_struct.{u u} K 𝒦)) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;)) (λ (f : @category_theory.has_hom.hom.{u u} K (@category_theory.category_struct.to_has_hom.{u u} K (@category_theory.category.to_category_struct.{u u} K 𝒦)) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;)), @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;)) (@sigma.snd.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;) (@category_theory.functor.map.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;) f (@sigma.snd.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} K (@category_theory.category_struct.to_has_hom.{u u} K (@category_theory.category.to_category_struct.{u u} K 𝒦)) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u+1} (@category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;)) (@sigma.snd.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;) (@category_theory.functor.map.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p) (@sigma.fst.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p&#x27;) f (@sigma.snd.{u u} K (λ (j : K), @category_theory.functor.obj.{u u u u+1} K 𝒦 (Type u) category_theory.types.{u} (@category_theory.functor.comp.{u u u u u u+1} K 𝒦 J _inst_1 (Type u) category_theory.types.{u} E F) j) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → @eq.{u} (@quot.{u} α r) (@quot.mk.{u} α r a) (@quot.mk.{u} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u u u u} K 𝒦 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type u} [_inst_2 : category_theory.category.{u u} D] (c : @category_theory.functor.{u u u u} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u} D (@category_theory.category_struct.to_has_hom.{u u} D (@category_theory.category.to_category_struct.{u u} D _inst_2)) (@category_theory.functor.obj.{u u u u} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  @[simp] lemma types_colimit_map {F G : J ⥤ Type u} (α : F ⟶ G) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    (colim.map α : (colimit F).X → (colimit G).X) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.colim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.types.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.types.colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 888, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] [_inst_3 : @category_theory.limits.has_colimits_of_shape.{u u+1} J _inst_1 C 𝒞], @category_theory.functor.{u u u+1 u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [_inst_1 : category_theory.category.{u u+1} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u+1 u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u+1 u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u+1 u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] (F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}), @category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`colimit F` is functorial in `F`, when `C` has all colimits of shape `J`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    quot.lift</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β), (∀ (a b : α), r a b → @eq.{v} β (f a) (f b)) → @quot.{u} α r → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      (λ p, quot.mk _ ⟨p.1, (α.app p.1) p.2⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} (r : α → α → Prop), α → @quot.{u} α r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79      (λ p p&#x27; ⟨f, h⟩, quot.sound ⟨f, by rw h; exact functor_to_types.naturality _ _ α f _⟩) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='quot.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (λ (f : @category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)), @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) f (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → @eq.{u} (@quot.{u} α r) (@quot.mk.{u} α r a) (@quot.mk.{u} α r b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) f (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{u u} C] (F G : @category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) {X Y : C} (σ : @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}))) F G) (f : @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C 𝒞)) X Y) (x : @category_theory.functor.obj.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F X), @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} G Y) (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F G σ Y (@category_theory.functor.map.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F X Y f x)) (@category_theory.functor.map.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} G X Y f (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F G : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
α :
  @category_theory.has_hom.hom.{u u+1}
    (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
    (@category_theory.category_struct.to_has_hom.{u u+1}
       (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
       (@category_theory.category.to_category_struct.{u u+1}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})))
    F
    G,
p p&#x27; :
  @sigma.{u u} J
    (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
_x :
  @Exists.{u+1}
    (@category_theory.has_hom.hom.{u u} J
       (@category_theory.category_struct.to_has_hom.{u u} J
          (@category_theory.category.to_category_struct.{u u} J _inst_1))
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (λ
     (f :
       @category_theory.has_hom.hom.{u u} J
         (@category_theory.category_struct.to_has_hom.{u u} J
            (@category_theory.category.to_category_struct.{u u} J _inst_1))
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p)
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)),
       @eq.{u+1}
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;))
         (@sigma.snd.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)
         (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p)
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;)
            f
            (@sigma.snd.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p))),
_fun_match :
  @Exists.{u+1}
    (@category_theory.has_hom.hom.{u u} J
       (@category_theory.category_struct.to_has_hom.{u u} J
          (@category_theory.category.to_category_struct.{u u} J _inst_1))
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (λ
     (f :
       @category_theory.has_hom.hom.{u u} J
         (@category_theory.category_struct.to_has_hom.{u u} J
            (@category_theory.category.to_category_struct.{u u} J _inst_1))
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p)
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)),
       @eq.{u+1}
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;))
         (@sigma.snd.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)
         (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p)
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;)
            f
            (@sigma.snd.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p))) →
  @eq.{u+1}
    (@category_theory.functor.obj.{u u u+1 u+1}
       (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
       (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
       (Type u)
       category_theory.types.{u}
       (@category_theory.limits.colim.{u u+1} J _inst_1 (Type u) category_theory.types.{u}
          (@category_theory.limits.has_colimits_of_shape_of_has_colimits.{u u+1} (Type u) category_theory.types.{u} J
             _inst_1
             category_theory.limits.types.category_theory.limits.has_colimits.{u}))
       G)
    (@quot.mk.{u+1}
       (@sigma.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j))
       (λ
        (p p&#x27; :
          @sigma.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)),
          @Exists.{u+1}
            (@category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                  p)
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                  p&#x27;))
            (λ
             (f :
               @category_theory.has_hom.hom.{u u} J
                 (@category_theory.category_struct.to_has_hom.{u u} J
                    (@category_theory.category.to_category_struct.{u u} J _inst_1))
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p)
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p&#x27;)),
               @eq.{u+1}
                 (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p&#x27;))
                 (@sigma.snd.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p&#x27;)
                 (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p)
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p&#x27;)
                    f
                    (@sigma.snd.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p))))
       (@sigma.mk.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.fst.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             p)
          (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p)
             (@sigma.snd.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p))))
    (@quot.mk.{u+1}
       (@sigma.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j))
       (λ
        (p p&#x27; :
          @sigma.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)),
          @Exists.{u+1}
            (@category_theory.has_hom.hom.{u u} J
               (@category_theory.category_struct.to_has_hom.{u u} J
                  (@category_theory.category.to_category_struct.{u u} J _inst_1))
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                  p)
               (@sigma.fst.{u u} J
                  (λ (j : J),
                     @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                  p&#x27;))
            (λ
             (f :
               @category_theory.has_hom.hom.{u u} J
                 (@category_theory.category_struct.to_has_hom.{u u} J
                    (@category_theory.category.to_category_struct.{u u} J _inst_1))
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p)
                 (@sigma.fst.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p&#x27;)),
               @eq.{u+1}
                 (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p&#x27;))
                 (@sigma.snd.{u u} J
                    (λ (j : J),
                       @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                    p&#x27;)
                 (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p)
                    (@sigma.fst.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p&#x27;)
                    f
                    (@sigma.snd.{u u} J
                       (λ (j : J),
                          @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
                       p))))
       (@sigma.mk.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.fst.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             p&#x27;)
          (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;)
             (@sigma.snd.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;)))),
f :
  @category_theory.has_hom.hom.{u u} J
    (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1))
    (@sigma.fst.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p)
    (@sigma.fst.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p&#x27;),
h :
  @eq.{u+1}
    (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (@sigma.snd.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p&#x27;)
    (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;)
       f
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p))
⊢ @eq.{u+1}
    (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.mk.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;)
             (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
                (@sigma.fst.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p&#x27;)
                (@sigma.snd.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p&#x27;)))))
    (@sigma.snd.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
       (@sigma.mk.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.fst.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
             p&#x27;)
          (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;)
             (@sigma.snd.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;))))
    (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.mk.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p)
             (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
                (@sigma.fst.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p)
                (@sigma.snd.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p))))
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.mk.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p&#x27;)
             (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
                (@sigma.fst.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p&#x27;)
                (@sigma.snd.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p&#x27;))))
       f
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
          (@sigma.mk.{u u} J
             (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} G j)
             (@sigma.fst.{u u} J
                (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                p)
             (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F G α
                (@sigma.fst.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p)
                (@sigma.snd.{u u} J
                   (λ (j : J),
                      @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
                   p)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  @[simp] lemma types_colimit_desc (F : J ⥤ Type u) (c : cocone F) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    colimit.desc F c =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.desc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    quot.lift</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='quot.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β), (∀ (a b : α), r a b → @eq.{v} β (f a) (f b)) → @quot.{u} α r → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      (λ p, c.ι.app p.1 p.2)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u}, @sigma.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type u} (c : @sigma.{u u} α β), β (@sigma.fst.{u u} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      (λ p p&#x27; ⟨f, h⟩, by rw h; exact (functor_to_types.naturality _ _ c.ι f _).symm) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{u+1} (@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (λ (f : @category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)), @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) f (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)) (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;) f (@sigma.snd.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{u u} C] (F G : @category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) {X Y : C} (σ : @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}) (@category_theory.functor.category.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u}))) F G) (f : @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C 𝒞)) X Y) (x : @category_theory.functor.obj.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F X), @eq.{u+1} (@category_theory.functor.obj.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} G Y) (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F G σ Y (@category_theory.functor.map.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F X Y f x)) (@category_theory.functor.map.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} G X Y f (@category_theory.nat_trans.app.{u u u u+1} C 𝒞 (Type u) category_theory.types.{u} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1)) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p) (@sigma.fst.{u u} J (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j) p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='J : Type u,
_inst_1 : category_theory.small_category.{u} J,
F : @category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u},
c : @category_theory.limits.cocone.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F,
p p&#x27; :
  @sigma.{u u} J
    (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j),
_x :
  @Exists.{u+1}
    (@category_theory.has_hom.hom.{u u} J
       (@category_theory.category_struct.to_has_hom.{u u} J
          (@category_theory.category.to_category_struct.{u u} J _inst_1))
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (λ
     (f :
       @category_theory.has_hom.hom.{u u} J
         (@category_theory.category_struct.to_has_hom.{u u} J
            (@category_theory.category.to_category_struct.{u u} J _inst_1))
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p)
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)),
       @eq.{u+1}
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;))
         (@sigma.snd.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)
         (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p)
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;)
            f
            (@sigma.snd.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p))),
_fun_match :
  @Exists.{u+1}
    (@category_theory.has_hom.hom.{u u} J
       (@category_theory.category_struct.to_has_hom.{u u} J
          (@category_theory.category.to_category_struct.{u u} J _inst_1))
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (λ
     (f :
       @category_theory.has_hom.hom.{u u} J
         (@category_theory.category_struct.to_has_hom.{u u} J
            (@category_theory.category.to_category_struct.{u u} J _inst_1))
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p)
         (@sigma.fst.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)),
       @eq.{u+1}
         (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;))
         (@sigma.snd.{u u} J
            (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
            p&#x27;)
         (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p)
            (@sigma.fst.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p&#x27;)
            f
            (@sigma.snd.{u u} J
               (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
               p))) →
  @eq.{u+1} (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c))
       (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p))
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c))
       (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;)
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;)),
f :
  @category_theory.has_hom.hom.{u u} J
    (@category_theory.category_struct.to_has_hom.{u u} J (@category_theory.category.to_category_struct.{u u} J _inst_1))
    (@sigma.fst.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p)
    (@sigma.fst.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p&#x27;),
h :
  @eq.{u+1}
    (@category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))
    (@sigma.snd.{u u} J
       (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
       p&#x27;)
    (@category_theory.functor.map.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;)
       f
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p))
⊢ @eq.{u+1} (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c))
       (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p)
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p))
    (@category_theory.nat_trans.app.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F
       (@category_theory.functor.obj.{u u u+1 u+1} (Type u) category_theory.types.{u}
          (@category_theory.functor.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.category.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.functor.const.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u})
          (@category_theory.limits.cocone.X.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c))
       (@category_theory.limits.cocone.ι.{u u+1} J _inst_1 (Type u) category_theory.types.{u} F c)
       (@sigma.fst.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;)
       (@sigma.snd.{u u} J
          (λ (j : J), @category_theory.functor.obj.{u u u u+1} J _inst_1 (Type u) category_theory.types.{u} F j)
          p&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  end category_theory.limits.types</code></pre>
</body>